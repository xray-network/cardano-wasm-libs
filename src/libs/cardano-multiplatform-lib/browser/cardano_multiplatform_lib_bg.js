let wasm;
export function __wbg_set_wasm(val) {
    wasm = val;
}


let WASM_VECTOR_LEN = 0;

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

const lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;

let cachedTextEncoder = new lTextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_4.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_4.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}
/**
 * Encrypt using Emip3: https://github.com/Emurgo/EmIPs/blob/master/specs/emip-003.md
 * @param {string} password
 * @param {string} salt
 * @param {string} nonce
 * @param {string} data
 * @returns {string}
 */
export function emip3_encrypt_with_password(password, salt, nonce, data) {
    let deferred6_0;
    let deferred6_1;
    try {
        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.emip3_encrypt_with_password(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        var ptr5 = ret[0];
        var len5 = ret[1];
        if (ret[3]) {
            ptr5 = 0; len5 = 0;
            throw takeFromExternrefTable0(ret[2]);
        }
        deferred6_0 = ptr5;
        deferred6_1 = len5;
        return getStringFromWasm0(ptr5, len5);
    } finally {
        wasm.__wbindgen_free(deferred6_0, deferred6_1, 1);
    }
}

/**
 * Decrypt using Emip3: https://github.com/Emurgo/EmIPs/blob/master/specs/emip-003.md
 * @param {string} password
 * @param {string} data
 * @returns {string}
 */
export function emip3_decrypt_with_password(password, data) {
    let deferred4_0;
    let deferred4_1;
    try {
        const ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.emip3_decrypt_with_password(ptr0, len0, ptr1, len1);
        var ptr3 = ret[0];
        var len3 = ret[1];
        if (ret[3]) {
            ptr3 = 0; len3 = 0;
            throw takeFromExternrefTable0(ret[2]);
        }
        deferred4_0 = ptr3;
        deferred4_1 = len3;
        return getStringFromWasm0(ptr3, len3);
    } finally {
        wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);
    }
}

/**
 * @param {TransactionHash} tx_body_hash
 * @param {PrivateKey} sk
 * @returns {Vkeywitness}
 */
export function make_vkey_witness(tx_body_hash, sk) {
    _assertClass(tx_body_hash, TransactionHash);
    _assertClass(sk, PrivateKey);
    const ret = wasm.make_vkey_witness(tx_body_hash.__wbg_ptr, sk.__wbg_ptr);
    return Vkeywitness.__wrap(ret);
}

let cachedUint16ArrayMemory0 = null;

function getUint16ArrayMemory0() {
    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {
        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);
    }
    return cachedUint16ArrayMemory0;
}

function getArrayU16FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);
}
/**
 * @param {TransactionHash} tx_body_hash
 * @param {ByronAddress} addr
 * @param {LegacyDaedalusPrivateKey} key
 * @returns {BootstrapWitness}
 */
export function make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {
    _assertClass(tx_body_hash, TransactionHash);
    _assertClass(addr, ByronAddress);
    _assertClass(key, LegacyDaedalusPrivateKey);
    const ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.__wbg_ptr, addr.__wbg_ptr, key.__wbg_ptr);
    return BootstrapWitness.__wrap(ret);
}

/**
 * @param {TransactionHash} tx_body_hash
 * @param {ByronAddress} addr
 * @param {Bip32PrivateKey} key
 * @returns {BootstrapWitness}
 */
export function make_icarus_bootstrap_witness(tx_body_hash, addr, key) {
    _assertClass(tx_body_hash, TransactionHash);
    var ptr0 = tx_body_hash.__destroy_into_raw();
    _assertClass(addr, ByronAddress);
    var ptr1 = addr.__destroy_into_raw();
    _assertClass(key, Bip32PrivateKey);
    const ret = wasm.make_icarus_bootstrap_witness(ptr0, ptr1, key.__wbg_ptr);
    return BootstrapWitness.__wrap(ret);
}

/**
 * @param {AuxiliaryData} auxiliary_data
 * @returns {AuxiliaryDataHash}
 */
export function hash_auxiliary_data(auxiliary_data) {
    _assertClass(auxiliary_data, AuxiliaryData);
    const ret = wasm.hash_auxiliary_data(auxiliary_data.__wbg_ptr);
    return AuxiliaryDataHash.__wrap(ret);
}

/**
 * @param {TransactionBody} tx_body
 * @returns {TransactionHash}
 */
export function hash_transaction(tx_body) {
    _assertClass(tx_body, TransactionBody);
    const ret = wasm.hash_transaction(tx_body.__wbg_ptr);
    return TransactionHash.__wrap(ret);
}

/**
 * @param {PlutusData} plutus_data
 * @returns {DatumHash}
 */
export function hash_plutus_data(plutus_data) {
    _assertClass(plutus_data, PlutusData);
    const ret = wasm.hash_plutus_data(plutus_data.__wbg_ptr);
    return DatumHash.__wrap(ret);
}

/**
 * Calculates the hash for script data (no plutus scripts) if it is necessary.
 * Returns None if it was not necessary (no datums/redeemers) to include.
 *
 * Most users will not directly need this as when using the builders
 * it will be invoked for you.
 *
 * Note: This WASM binding does not work with non-standard witness set
 * encodings. If you created the witness set manually this is not an issue
 * but for constructing it from deserializing a transaction/witness then
 * please use calc_script_data_hash_from_witness()
 * @param {Redeemers} redeemers
 * @param {CostModels} cost_models
 * @param {PlutusDataList | null} [datums]
 * @returns {ScriptDataHash}
 */
export function hash_script_data(redeemers, cost_models, datums) {
    _assertClass(redeemers, Redeemers);
    _assertClass(cost_models, CostModels);
    let ptr0 = 0;
    if (!isLikeNone(datums)) {
        _assertClass(datums, PlutusDataList);
        ptr0 = datums.__destroy_into_raw();
    }
    const ret = wasm.hash_script_data(redeemers.__wbg_ptr, cost_models.__wbg_ptr, ptr0);
    return ScriptDataHash.__wrap(ret);
}

/**
 * Calculates the hash for script data (with plutus scripts) if it is necessary.
 * Returns None if it was not necessary (no datums/redeemers) to include.
 *
 * Most users will not directly need this as when using the builders
 * it will be invoked for you.
 *
 * Note: This WASM binding does not work with non-standard witness set
 * encodings. If you created the witness set manually this is not an issue
 * but for constructing it from deserializing a transaction/witness then
 * please use calc_script_data_hash_from_witness()
 * @param {Redeemers} redeemers
 * @param {PlutusDataList} datums
 * @param {CostModels} cost_models
 * @param {LanguageList} used_langs
 * @returns {ScriptDataHash | undefined}
 */
export function calc_script_data_hash(redeemers, datums, cost_models, used_langs) {
    _assertClass(redeemers, Redeemers);
    _assertClass(datums, PlutusDataList);
    _assertClass(cost_models, CostModels);
    _assertClass(used_langs, LanguageList);
    const ret = wasm.calc_script_data_hash(redeemers.__wbg_ptr, datums.__wbg_ptr, cost_models.__wbg_ptr, used_langs.__wbg_ptr);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return ret[0] === 0 ? undefined : ScriptDataHash.__wrap(ret[0]);
}

/**
 * Calculates the hash for script data from a witness if it is necessary.
 * Returns None if it was not necessary (no datums/redeemers) to include.
 *
 * Most users will not directly need this as when using the builders
 * it will be invoked for you.
 * @param {TransactionWitnessSet} witnesses
 * @param {CostModels} cost_models
 * @returns {ScriptDataHash | undefined}
 */
export function calc_script_data_hash_from_witness(witnesses, cost_models) {
    _assertClass(witnesses, TransactionWitnessSet);
    _assertClass(cost_models, CostModels);
    const ret = wasm.calc_script_data_hash_from_witness(witnesses.__wbg_ptr, cost_models.__wbg_ptr);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return ret[0] === 0 ? undefined : ScriptDataHash.__wrap(ret[0]);
}

/**
 * @param {PublicKey} pubkey
 * @param {number | null} [protocol_magic]
 * @returns {ByronGenesisRedeem}
 */
export function genesis_txid_byron(pubkey, protocol_magic) {
    _assertClass(pubkey, PublicKey);
    const ret = wasm.genesis_txid_byron(pubkey.__wbg_ptr, isLikeNone(protocol_magic) ? 0x100000001 : (protocol_magic) >>> 0);
    return ByronGenesisRedeem.__wrap(ret);
}

/**
 * @param {Address} address
 * @returns {TransactionHash}
 */
export function genesis_txid_shelley(address) {
    _assertClass(address, Address);
    const ret = wasm.genesis_txid_shelley(address.__wbg_ptr);
    return TransactionHash.__wrap(ret);
}

/**
 * @param {Redeemers} redeemers
 * @returns {ExUnits}
 */
export function compute_total_ex_units(redeemers) {
    _assertClass(redeemers, Redeemers);
    const ret = wasm.compute_total_ex_units(redeemers.__wbg_ptr);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return ExUnits.__wrap(ret[0]);
}

/**
 * encodes arbitrary bytes into chunks of 64 bytes (the limit for bytes) as a list to be valid Metadata
 * @param {Uint8Array} bytes
 * @returns {TransactionMetadatum}
 */
export function encode_arbitrary_bytes_as_metadatum(bytes) {
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);
    return TransactionMetadatum.__wrap(ret);
}

/**
 * decodes from chunks of bytes in a list to a byte vector if that is the metadata format, otherwise returns None
 * @param {TransactionMetadatum} metadata
 * @returns {Uint8Array | undefined}
 */
export function decode_arbitrary_bytes_from_metadatum(metadata) {
    _assertClass(metadata, TransactionMetadatum);
    const ret = wasm.decode_arbitrary_bytes_from_metadatum(metadata.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
        v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
}

/**
 *
 * * Min fee for JUST the script, NOT including ref inputs
 *
 * @param {Transaction} tx
 * @param {ExUnitPrices} ex_unit_prices
 * @returns {bigint}
 */
export function min_script_fee(tx, ex_unit_prices) {
    _assertClass(tx, Transaction);
    _assertClass(ex_unit_prices, ExUnitPrices);
    const ret = wasm.min_script_fee(tx.__wbg_ptr, ex_unit_prices.__wbg_ptr);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return BigInt.asUintN(64, ret[0]);
}

/**
 * @param {Transaction} tx
 * @param {LinearFee} linear_fee
 * @returns {bigint}
 */
export function min_no_script_fee(tx, linear_fee) {
    _assertClass(tx, Transaction);
    _assertClass(linear_fee, LinearFee);
    const ret = wasm.min_no_script_fee(tx.__wbg_ptr, linear_fee.__wbg_ptr);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return BigInt.asUintN(64, ret[0]);
}

/**
 *
 * * Calculates the cost of all ref scripts
 * * * `total_ref_script_size` - Total size (original, not hashes) of all ref scripts. Duplicate scripts are counted as many times as they occur
 *
 * @param {Transaction} tx
 * @param {LinearFee} linear_fee
 * @param {ExUnitPrices} ex_unit_prices
 * @param {bigint} total_ref_script_size
 * @returns {bigint}
 */
export function min_fee(tx, linear_fee, ex_unit_prices, total_ref_script_size) {
    _assertClass(tx, Transaction);
    _assertClass(linear_fee, LinearFee);
    _assertClass(ex_unit_prices, ExUnitPrices);
    const ret = wasm.min_fee(tx.__wbg_ptr, linear_fee.__wbg_ptr, ex_unit_prices.__wbg_ptr, total_ref_script_size);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return BigInt.asUintN(64, ret[0]);
}

function passArray16ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 2, 2) >>> 0;
    getUint16ArrayMemory0().set(arg, ptr / 2);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
 * @param {TransactionBody} txbody
 * @param {bigint} pool_deposit
 * @param {bigint} key_deposit
 * @returns {Value}
 */
export function get_implicit_input(txbody, pool_deposit, key_deposit) {
    _assertClass(txbody, TransactionBody);
    const ret = wasm.get_implicit_input(txbody.__wbg_ptr, pool_deposit, key_deposit);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return Value.__wrap(ret[0]);
}

/**
 * @param {TransactionBody} txbody
 * @param {bigint} pool_deposit
 * @param {bigint} key_deposit
 * @returns {bigint}
 */
export function get_deposit(txbody, pool_deposit, key_deposit) {
    _assertClass(txbody, TransactionBody);
    const ret = wasm.get_deposit(txbody.__wbg_ptr, pool_deposit, key_deposit);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return BigInt.asUintN(64, ret[0]);
}

/**
 * Converts JSON to Metadata according to MetadataJsonSchema
 * @param {string} json
 * @param {MetadataJsonSchema} schema
 * @returns {TransactionMetadatum}
 */
export function encode_json_str_to_metadatum(json, schema) {
    const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.encode_json_str_to_metadatum(ptr0, len0, schema);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return TransactionMetadatum.__wrap(ret[0]);
}

/**
 * Converts Metadata to JSON according to MetadataJsonSchema
 * @param {TransactionMetadatum} metadatum
 * @param {MetadataJsonSchema} schema
 * @returns {string}
 */
export function decode_metadatum_to_json_str(metadatum, schema) {
    let deferred2_0;
    let deferred2_1;
    try {
        _assertClass(metadatum, TransactionMetadatum);
        const ret = wasm.decode_metadatum_to_json_str(metadatum.__wbg_ptr, schema);
        var ptr1 = ret[0];
        var len1 = ret[1];
        if (ret[3]) {
            ptr1 = 0; len1 = 0;
            throw takeFromExternrefTable0(ret[2]);
        }
        deferred2_0 = ptr1;
        deferred2_1 = len1;
        return getStringFromWasm0(ptr1, len1);
    } finally {
        wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
}

/**
 * @param {string} json
 * @param {CardanoNodePlutusDatumSchema} schema
 * @returns {PlutusData}
 */
export function encode_json_str_to_plutus_datum(json, schema) {
    const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.encode_json_str_to_plutus_datum(ptr0, len0, schema);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return PlutusData.__wrap(ret[0]);
}

/**
 * @param {PlutusData} datum
 * @param {CardanoNodePlutusDatumSchema} schema
 * @returns {string}
 */
export function decode_plutus_datum_to_json_str(datum, schema) {
    let deferred2_0;
    let deferred2_1;
    try {
        _assertClass(datum, PlutusData);
        const ret = wasm.decode_plutus_datum_to_json_str(datum.__wbg_ptr, schema);
        var ptr1 = ret[0];
        var len1 = ret[1];
        if (ret[3]) {
            ptr1 = 0; len1 = 0;
            throw takeFromExternrefTable0(ret[2]);
        }
        deferred2_0 = ptr1;
        deferred2_1 = len1;
        return getStringFromWasm0(ptr1, len1);
    } finally {
        wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
}

/**
 * @param {TransactionOutput} output
 * @param {bigint} coins_per_utxo_byte
 * @returns {bigint}
 */
export function min_ada_required(output, coins_per_utxo_byte) {
    _assertClass(output, TransactionOutput);
    const ret = wasm.min_ada_required(output.__wbg_ptr, coins_per_utxo_byte);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return BigInt.asUintN(64, ret[0]);
}

let cachedUint32ArrayMemory0 = null;

function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
}

function getArrayU32FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}

let cachedBigInt64ArrayMemory0 = null;

function getBigInt64ArrayMemory0() {
    if (cachedBigInt64ArrayMemory0 === null || cachedBigInt64ArrayMemory0.byteLength === 0) {
        cachedBigInt64ArrayMemory0 = new BigInt64Array(wasm.memory.buffer);
    }
    return cachedBigInt64ArrayMemory0;
}

function getArrayI64FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getBigInt64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);
}

let cachedBigUint64ArrayMemory0 = null;

function getBigUint64ArrayMemory0() {
    if (cachedBigUint64ArrayMemory0 === null || cachedBigUint64ArrayMemory0.byteLength === 0) {
        cachedBigUint64ArrayMemory0 = new BigUint64Array(wasm.memory.buffer);
    }
    return cachedBigUint64ArrayMemory0;
}

function passArray64ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 8, 8) >>> 0;
    getBigUint64ArrayMemory0().set(arg, ptr / 8);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU64FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getBigUint64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);
}
/**
 * Careful: this enum doesn't include the network ID part of the header
 * ex: base address isn't 0b0000_0000 but instead 0b0000
 * Use `header_matches_kind` if you don't want to implement the bitwise operators yourself
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 14 | 15}
 */
export const AddressHeaderKind = Object.freeze({
    BasePaymentKeyStakeKey: 0, "0": "BasePaymentKeyStakeKey",
    BasePaymentScriptStakeKey: 1, "1": "BasePaymentScriptStakeKey",
    BasePaymentKeyStakeScript: 2, "2": "BasePaymentKeyStakeScript",
    BasePaymentScriptStakeScript: 3, "3": "BasePaymentScriptStakeScript",
    PointerKey: 4, "4": "PointerKey",
    PointerScript: 5, "5": "PointerScript",
    EnterpriseKey: 6, "6": "EnterpriseKey",
    EnterpriseScript: 7, "7": "EnterpriseScript",
    Byron: 8, "8": "Byron",
    RewardKey: 14, "14": "RewardKey",
    RewardScript: 15, "15": "RewardScript",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const AddressKind = Object.freeze({
    Base: 0, "0": "Base",
    Ptr: 1, "1": "Ptr",
    Enterprise: 2, "2": "Enterprise",
    Reward: 3, "3": "Reward",
    Byron: 4, "4": "Byron",
});
/**
 * @enum {0 | 1 | 2}
 */
export const AuxiliaryDataKind = Object.freeze({
    Shelley: 0, "0": "Shelley",
    ShelleyMA: 1, "1": "ShelleyMA",
    Conway: 2, "2": "Conway",
});
/**
 * @enum {0 | 1 | 2}
 */
export const ByronAddrType = Object.freeze({
    PublicKey: 0, "0": "PublicKey",
    Script: 1, "1": "Script",
    Redeem: 2, "2": "Redeem",
});
/**
 * Which version of the CIP25 spec to use. See CIP25 for details.
 * This will change how things are encoded but for the most part contains
 * the same information.
 * @enum {0 | 1}
 */
export const CIP25Version = Object.freeze({
    /**
     * Initial version of CIP25 with only string (utf8) asset names allowed.
     */
    V1: 0, "0": "V1",
    /**
     * Second version of CIP25. Supports any type of asset names.
     */
    V2: 1, "1": "V2",
});
/**
 * JSON <-> PlutusData conversion schemas.
 * Follows ScriptDataJsonSchema in cardano-cli defined at:
 * https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/ScriptData.hs#L254
 *
 * All methods here have the following restrictions due to limitations on dependencies:
 * * JSON numbers above u64::MAX (positive) or below i64::MIN (negative) will throw errors
 * * Hex strings for bytes don't accept odd-length (half-byte) strings.
 *      cardano-cli seems to support these however but it seems to be different than just 0-padding
 *      on either side when tested so proceed with caution
 * @enum {0 | 1}
 */
export const CardanoNodePlutusDatumSchema = Object.freeze({
    /**
     * ScriptDataJsonNoSchema in cardano-node.
     *
     * This is the format used by --script-data-value in cardano-cli
     * This tries to accept most JSON but does not support the full spectrum of Plutus datums.
     * From JSON:
     * * null/true/false/floats NOT supported
     * * strings starting with 0x are treated as hex bytes. All other strings are encoded as their utf8 bytes.
     * To JSON:
     * * ConstrPlutusData not supported in ANY FORM (neither keys nor values)
     * * Lists not supported in keys
     * * Maps not supported in keys
     */
    BasicConversions: 0, "0": "BasicConversions",
    /**
     * ScriptDataJsonDetailedSchema in cardano-node.
     *
     * This is the format used by --script-data-file in cardano-cli
     * This covers almost all (only minor exceptions) Plutus datums, but the JSON must conform to a strict schema.
     * The schema specifies that ALL keys and ALL values must be contained in a JSON map with 2 cases:
     * 1. For ConstrPlutusData there must be two fields "constructor" contianing a number and "fields" containing its fields
     *    e.g. { "constructor": 2, "fields": [{"int": 2}, {"list": [{"bytes": "CAFEF00D"}]}]}
     * 2. For all other cases there must be only one field named "int", "bytes", "list" or "map"
     *    BigInteger's value is a JSON number e.g. {"int": 100}
     *    Bytes' value is a hex string representing the bytes WITHOUT any prefix e.g. {"bytes": "CAFEF00D"}
     *    Lists' value is a JSON list of its elements encoded via the same schema e.g. {"list": [{"bytes": "CAFEF00D"}]}
     *    Maps' value is a JSON list of objects, one for each key-value pair in the map, with keys "k" and "v"
     *          respectively with their values being the plutus datum encoded via this same schema
     *          e.g. {"map": [
     *              {"k": {"int": 2}, "v": {"int": 5}},
     *              {"k": {"map": [{"k": {"list": [{"int": 1}]}, "v": {"bytes": "FF03"}}]}, "v": {"list": []}}
     *          ]}
     * From JSON:
     * * null/true/false/floats NOT supported
     * * the JSON must conform to a very specific schema
     * To JSON:
     * * all Plutus datums should be fully supported outside of the integer range limitations outlined above.
     */
    DetailedSchema: 1, "1": "DetailedSchema",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16}
 */
export const CertificateKind = Object.freeze({
    StakeRegistration: 0, "0": "StakeRegistration",
    StakeDeregistration: 1, "1": "StakeDeregistration",
    StakeDelegation: 2, "2": "StakeDelegation",
    PoolRegistration: 3, "3": "PoolRegistration",
    PoolRetirement: 4, "4": "PoolRetirement",
    RegCert: 5, "5": "RegCert",
    UnregCert: 6, "6": "UnregCert",
    VoteDelegCert: 7, "7": "VoteDelegCert",
    StakeVoteDelegCert: 8, "8": "StakeVoteDelegCert",
    StakeRegDelegCert: 9, "9": "StakeRegDelegCert",
    VoteRegDelegCert: 10, "10": "VoteRegDelegCert",
    StakeVoteRegDelegCert: 11, "11": "StakeVoteRegDelegCert",
    AuthCommitteeHotCert: 12, "12": "AuthCommitteeHotCert",
    ResignCommitteeColdCert: 13, "13": "ResignCommitteeColdCert",
    RegDrepCert: 14, "14": "RegDrepCert",
    UnregDrepCert: 15, "15": "UnregDrepCert",
    UpdateDrepCert: 16, "16": "UpdateDrepCert",
});
/**
 * @enum {0}
 */
export const ChangeSelectionAlgo = Object.freeze({
    Default: 0, "0": "Default",
});
/**
 * @enum {0 | 1}
 */
export const ChunkableStringKind = Object.freeze({
    Single: 0, "0": "Single",
    Chunked: 1, "1": "Chunked",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
export const CoinSelectionStrategyCIP2 = Object.freeze({
    /**
     * Performs CIP2's Largest First ada-only selection. Will error if outputs contain non-ADA assets.
     */
    LargestFirst: 0, "0": "LargestFirst",
    /**
     * Performs CIP2's Random Improve ada-only selection. Will error if outputs contain non-ADA assets.
     */
    RandomImprove: 1, "1": "RandomImprove",
    /**
     * Same as LargestFirst, but before adding ADA, will insert by largest-first for each asset type.
     */
    LargestFirstMultiAsset: 2, "2": "LargestFirstMultiAsset",
    /**
     * Same as RandomImprove, but before adding ADA, will insert by random-improve for each asset type.
     */
    RandomImproveMultiAsset: 3, "3": "RandomImproveMultiAsset",
});
/**
 * @enum {0 | 1}
 */
export const CredentialKind = Object.freeze({
    PubKey: 0, "0": "PubKey",
    Script: 1, "1": "Script",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
export const DRepKind = Object.freeze({
    Key: 0, "0": "Key",
    Script: 1, "1": "Script",
    AlwaysAbstain: 2, "2": "AlwaysAbstain",
    AlwaysNoConfidence: 3, "3": "AlwaysNoConfidence",
});
/**
 * @enum {0 | 1}
 */
export const DatumOptionKind = Object.freeze({
    Hash: 0, "0": "Hash",
    Datum: 1, "1": "Datum",
});
/**
 * @enum {0 | 1}
 */
export const DelegationDistributionKind = Object.freeze({
    Weighted: 0, "0": "Weighted",
    Legacy: 1, "1": "Legacy",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
export const GovActionKind = Object.freeze({
    ParameterChangeAction: 0, "0": "ParameterChangeAction",
    HardForkInitiationAction: 1, "1": "HardForkInitiationAction",
    TreasuryWithdrawalsAction: 2, "2": "TreasuryWithdrawalsAction",
    NoConfidence: 3, "3": "NoConfidence",
    UpdateCommittee: 4, "4": "UpdateCommittee",
    NewConstitution: 5, "5": "NewConstitution",
    InfoAction: 6, "6": "InfoAction",
});
/**
 * @enum {0 | 1 | 2}
 */
export const Language = Object.freeze({
    PlutusV1: 0, "0": "PlutusV1",
    PlutusV2: 1, "1": "PlutusV2",
    PlutusV3: 2, "2": "PlutusV3",
});
/**
 * @enum {0 | 1 | 2}
 */
export const MetadataJsonSchema = Object.freeze({
    NoConversions: 0, "0": "NoConversions",
    BasicConversions: 1, "1": "BasicConversions",
    DetailedSchema: 2, "2": "DetailedSchema",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5}
 */
export const NativeScriptKind = Object.freeze({
    ScriptPubkey: 0, "0": "ScriptPubkey",
    ScriptAll: 1, "1": "ScriptAll",
    ScriptAny: 2, "2": "ScriptAny",
    ScriptNOfK: 3, "3": "ScriptNOfK",
    ScriptInvalidBefore: 4, "4": "ScriptInvalidBefore",
    ScriptInvalidHereafter: 5, "5": "ScriptInvalidHereafter",
});
/**
 * @enum {0 | 1}
 */
export const NonceKind = Object.freeze({
    Identity: 0, "0": "Identity",
    Hash: 1, "1": "Hash",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const PlutusDataKind = Object.freeze({
    ConstrPlutusData: 0, "0": "ConstrPlutusData",
    Map: 1, "1": "Map",
    List: 2, "2": "List",
    Integer: 3, "3": "Integer",
    Bytes: 4, "4": "Bytes",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5}
 */
export const RedeemerTag = Object.freeze({
    Spend: 0, "0": "Spend",
    Mint: 1, "1": "Mint",
    Cert: 2, "2": "Cert",
    Reward: 3, "3": "Reward",
    Voting: 4, "4": "Voting",
    Proposing: 5, "5": "Proposing",
});
/**
 * @enum {0 | 1}
 */
export const RedeemersKind = Object.freeze({
    ArrLegacyRedeemer: 0, "0": "ArrLegacyRedeemer",
    MapRedeemerKeyToRedeemerVal: 1, "1": "MapRedeemerKeyToRedeemerVal",
});
/**
 * @enum {0 | 1 | 2}
 */
export const RelayKind = Object.freeze({
    SingleHostAddr: 0, "0": "SingleHostAddr",
    SingleHostName: 1, "1": "SingleHostName",
    MultiHostName: 2, "2": "MultiHostName",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
export const ScriptKind = Object.freeze({
    Native: 0, "0": "Native",
    PlutusV1: 1, "1": "PlutusV1",
    PlutusV2: 2, "2": "PlutusV2",
    PlutusV3: 3, "3": "PlutusV3",
});
/**
 * @enum {0 | 1 | 2}
 */
export const SpendingDataKind = Object.freeze({
    SpendingDataPubKey: 0, "0": "SpendingDataPubKey",
    SpendingDataScript: 1, "1": "SpendingDataScript",
    SpendingDataRedeem: 2, "2": "SpendingDataRedeem",
});
/**
 * @enum {0 | 1}
 */
export const StakeDistributionKind = Object.freeze({
    SingleKey: 0, "0": "SingleKey",
    BootstrapEra: 1, "1": "BootstrapEra",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const TransactionMetadatumKind = Object.freeze({
    Map: 0, "0": "Map",
    List: 1, "1": "List",
    Int: 2, "2": "Int",
    Bytes: 3, "3": "Bytes",
    Text: 4, "4": "Text",
});
/**
 * @enum {0 | 1}
 */
export const TransactionOutputKind = Object.freeze({
    AlonzoFormatTxOut: 0, "0": "AlonzoFormatTxOut",
    ConwayFormatTxOut: 1, "1": "ConwayFormatTxOut",
});
/**
 * @enum {0 | 1 | 2}
 */
export const Vote = Object.freeze({
    No: 0, "0": "No",
    Yes: 1, "1": "Yes",
    Abstain: 2, "2": "Abstain",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const VoterKind = Object.freeze({
    ConstitutionalCommitteeHotKeyHash: 0, "0": "ConstitutionalCommitteeHotKeyHash",
    ConstitutionalCommitteeHotScriptHash: 1, "1": "ConstitutionalCommitteeHotScriptHash",
    DRepKeyHash: 2, "2": "DRepKeyHash",
    DRepScriptHash: 3, "3": "DRepScriptHash",
    StakingPoolKeyHash: 4, "4": "StakingPoolKeyHash",
});

const AddrAttributesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_addrattributes_free(ptr >>> 0, 1));

export class AddrAttributes {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AddrAttributes.prototype);
        obj.__wbg_ptr = ptr;
        AddrAttributesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddrAttributesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addrattributes_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.addrattributes_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AddrAttributes}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addrattributes_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddrAttributes.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.addrattributes_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AddrAttributes}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addrattributes_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddrAttributes.__wrap(ret[0]);
    }
    /**
     * @param {StakeDistribution} stake_distribution
     */
    set_stake_distribution(stake_distribution) {
        _assertClass(stake_distribution, StakeDistribution);
        wasm.addrattributes_set_stake_distribution(this.__wbg_ptr, stake_distribution.__wbg_ptr);
    }
    /**
     * @returns {StakeDistribution | undefined}
     */
    stake_distribution() {
        const ret = wasm.addrattributes_stake_distribution(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeDistribution.__wrap(ret);
    }
    /**
     * @param {HDAddressPayload} derivation_path
     */
    set_derivation_path(derivation_path) {
        _assertClass(derivation_path, HDAddressPayload);
        wasm.addrattributes_set_derivation_path(this.__wbg_ptr, derivation_path.__wbg_ptr);
    }
    /**
     * @returns {HDAddressPayload | undefined}
     */
    derivation_path() {
        const ret = wasm.addrattributes_derivation_path(this.__wbg_ptr);
        return ret === 0 ? undefined : HDAddressPayload.__wrap(ret);
    }
    /**
     * @param {ProtocolMagic} protocol_magic
     */
    set_protocol_magic(protocol_magic) {
        _assertClass(protocol_magic, ProtocolMagic);
        wasm.addrattributes_set_protocol_magic(this.__wbg_ptr, protocol_magic.__wbg_ptr);
    }
    /**
     * @returns {ProtocolMagic | undefined}
     */
    protocol_magic() {
        const ret = wasm.addrattributes_protocol_magic(this.__wbg_ptr);
        return ret === 0 ? undefined : ProtocolMagic.__wrap(ret);
    }
    /**
     * @returns {AddrAttributes}
     */
    static new() {
        const ret = wasm.addrattributes_new();
        return AddrAttributes.__wrap(ret);
    }
    /**
     * @param {HDAddressPayload | null} [hdap]
     * @param {ProtocolMagic | null} [protocol_magic]
     * @returns {AddrAttributes}
     */
    static new_bootstrap_era(hdap, protocol_magic) {
        let ptr0 = 0;
        if (!isLikeNone(hdap)) {
            _assertClass(hdap, HDAddressPayload);
            ptr0 = hdap.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr1 = protocol_magic.__destroy_into_raw();
        }
        const ret = wasm.addrattributes_new_bootstrap_era(ptr0, ptr1);
        return AddrAttributes.__wrap(ret);
    }
    /**
     * @param {Bip32PublicKey} pubk
     * @param {HDAddressPayload | null | undefined} hdap
     * @param {ProtocolMagic} protocol_magic
     * @returns {AddrAttributes}
     */
    static new_single_key(pubk, hdap, protocol_magic) {
        _assertClass(pubk, Bip32PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(hdap)) {
            _assertClass(hdap, HDAddressPayload);
            ptr0 = hdap.__destroy_into_raw();
        }
        _assertClass(protocol_magic, ProtocolMagic);
        var ptr1 = protocol_magic.__destroy_into_raw();
        const ret = wasm.addrattributes_new_single_key(pubk.__wbg_ptr, ptr0, ptr1);
        return AddrAttributes.__wrap(ret);
    }
}

const AddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));

export class Address {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Address.prototype);
        obj.__wbg_ptr = ptr;
        AddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_address_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.address_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.address_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Address}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Address.__wrap(ret[0]);
    }
    /**
     * header has 4 bits addr type discrim then 4 bits network discrim.
     * Copied from shelley.cddl:
     *
     * base address
     * bits 7-6: 00
     * bit 5: stake cred is keyhash/scripthash
     * bit 4: payment cred is keyhash/scripthash
     * bits 3-0: network id
     *
     * pointer address
     * bits 7-5: 010
     * bit 4: payment cred is keyhash/scripthash
     * bits 3-0: network id
     *
     * enterprise address
     * bits 7-5: 010
     * bit 4: payment cred is keyhash/scripthash
     * bits 3-0: network id
     *
     * reward addresses:
     * bits 7-5: 111
     * bit 4: credential is keyhash/scripthash
     * bits 3-0: network id
     *
     * byron addresses:
     * bits 7-4: 1000
     * bits 3-0: unrelated data (recall: no network ID in Byron addresses)
     * @returns {number}
     */
    header() {
        const ret = wasm.address_header(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} header
     * @param {AddressHeaderKind} kind
     * @returns {boolean}
     */
    static header_matches_kind(header, kind) {
        const ret = wasm.address_header_matches_kind(header, kind);
        return ret !== 0;
    }
    /**
     * @param {string | null} [prefix]
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            const ret = wasm.address_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech_str
     * @returns {Address}
     */
    static from_bech32(bech_str) {
        const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Address.__wrap(ret[0]);
    }
    /**
     *
     *     * Note: bech32-encoded Byron addresses will also pass validation here
     *
     * @param {string} bech_str
     * @returns {boolean}
     */
    static is_valid_bech32(bech_str) {
        const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_is_valid_bech32(ptr0, len0);
        return ret !== 0;
    }
    /**
     * @param {string} bech_str
     * @returns {boolean}
     */
    static is_valid(bech_str) {
        const ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_is_valid(ptr0, len0);
        return ret !== 0;
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.address_network_id(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0];
    }
    /**
     * Note: by convention, the key inside reward addresses are considered payment credentials
     * @returns {Credential | undefined}
     */
    payment_cred() {
        const ret = wasm.address_payment_cred(this.__wbg_ptr);
        return ret === 0 ? undefined : Credential.__wrap(ret);
    }
    /**
     * Note: by convention, the key inside reward addresses are NOT considered staking credentials
     * Note: None is returned pointer addresses as the chain history is required to resolve its associated cred
     * @returns {Credential | undefined}
     */
    staking_cred() {
        const ret = wasm.address_staking_cred(this.__wbg_ptr);
        return ret === 0 ? undefined : Credential.__wrap(ret);
    }
    /**
     * @returns {AddressKind}
     */
    kind() {
        const ret = wasm.address_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.address_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} data
     * @returns {Address}
     */
    static from_raw_bytes(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Address.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.address_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} hex
     * @returns {Address}
     */
    static from_hex(hex) {
        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Address.__wrap(ret[0]);
    }
}

const AddressContentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_addresscontent_free(ptr >>> 0, 1));

export class AddressContent {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AddressContent.prototype);
        obj.__wbg_ptr = ptr;
        AddressContentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddressContentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addresscontent_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.addresscontent_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AddressContent}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addresscontent_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressContent.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.addresscontent_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AddressContent}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addresscontent_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressContent.__wrap(ret[0]);
    }
    /**
     * @returns {AddressId}
     */
    address_id() {
        const ret = wasm.addresscontent_address_id(this.__wbg_ptr);
        return AddressId.__wrap(ret);
    }
    /**
     * @returns {AddrAttributes}
     */
    addr_attributes() {
        const ret = wasm.addresscontent_addr_attributes(this.__wbg_ptr);
        return AddrAttributes.__wrap(ret);
    }
    /**
     * @returns {ByronAddrType}
     */
    addr_type() {
        const ret = wasm.addresscontent_addr_type(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {AddressId} address_id
     * @param {AddrAttributes} addr_attributes
     * @param {ByronAddrType} addr_type
     * @returns {AddressContent}
     */
    static new(address_id, addr_attributes, addr_type) {
        _assertClass(address_id, AddressId);
        _assertClass(addr_attributes, AddrAttributes);
        const ret = wasm.addresscontent_new(address_id.__wbg_ptr, addr_attributes.__wbg_ptr, addr_type);
        return AddressContent.__wrap(ret);
    }
    /**
     * @param {ByronAddrType} addr_type
     * @param {SpendingData} spending_data
     * @param {AddrAttributes} attributes
     * @returns {AddressContent}
     */
    static hash_and_create(addr_type, spending_data, attributes) {
        _assertClass(spending_data, SpendingData);
        _assertClass(attributes, AddrAttributes);
        const ret = wasm.addresscontent_hash_and_create(addr_type, spending_data.__wbg_ptr, attributes.__wbg_ptr);
        return AddressContent.__wrap(ret);
    }
    /**
     * @param {PublicKey} pubkey
     * @param {ProtocolMagic | null} [protocol_magic]
     * @returns {AddressContent}
     */
    static new_redeem(pubkey, protocol_magic) {
        _assertClass(pubkey, PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr0 = protocol_magic.__destroy_into_raw();
        }
        const ret = wasm.addresscontent_new_redeem(pubkey.__wbg_ptr, ptr0);
        return AddressContent.__wrap(ret);
    }
    /**
     * @param {Bip32PublicKey} xpub
     * @param {ProtocolMagic | null} [protocol_magic]
     * @returns {AddressContent}
     */
    static new_simple(xpub, protocol_magic) {
        _assertClass(xpub, Bip32PublicKey);
        let ptr0 = 0;
        if (!isLikeNone(protocol_magic)) {
            _assertClass(protocol_magic, ProtocolMagic);
            ptr0 = protocol_magic.__destroy_into_raw();
        }
        const ret = wasm.addresscontent_new_simple(xpub.__wbg_ptr, ptr0);
        return AddressContent.__wrap(ret);
    }
    /**
     * Do we want to remove this or keep it for people who were using old Byron code?
     * @returns {ByronAddress}
     */
    to_address() {
        const ret = wasm.addresscontent_to_address(this.__wbg_ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
     * returns the byron protocol magic embedded in the address, or mainnet id if none is present
     * note: for bech32 addresses, you need to use network_id instead
     * @returns {ProtocolMagic}
     */
    byron_protocol_magic() {
        const ret = wasm.addresscontent_byron_protocol_magic(this.__wbg_ptr);
        return ProtocolMagic.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.addresscontent_network_id(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0];
    }
    /**
     * @param {Bip32PublicKey} key
     * @param {ProtocolMagic} protocol_magic
     * @returns {AddressContent}
     */
    static icarus_from_key(key, protocol_magic) {
        _assertClass(key, Bip32PublicKey);
        _assertClass(protocol_magic, ProtocolMagic);
        const ret = wasm.addresscontent_icarus_from_key(key.__wbg_ptr, protocol_magic.__wbg_ptr);
        return AddressContent.__wrap(ret);
    }
    /**
     * Check if the Addr can be reconstructed with a specific xpub
     * @param {Bip32PublicKey} xpub
     * @returns {boolean}
     */
    identical_with_pubkey(xpub) {
        _assertClass(xpub, Bip32PublicKey);
        const ret = wasm.addresscontent_identical_with_pubkey(this.__wbg_ptr, xpub.__wbg_ptr);
        return ret !== 0;
    }
}

const AddressIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_addressid_free(ptr >>> 0, 1));

export class AddressId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AddressId.prototype);
        obj.__wbg_ptr = ptr;
        AddressIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddressIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_addressid_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.addressid_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {AddressId}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addressid_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressId.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.addressid_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {AddressId}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addressid_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressId.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.addressid_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {AddressId}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.addressid_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressId.__wrap(ret[0]);
    }
    /**
     * @param {ByronAddrType} addr_type
     * @param {SpendingData} spending_data
     * @param {AddrAttributes} attrs
     * @returns {AddressId}
     */
    static new(addr_type, spending_data, attrs) {
        _assertClass(spending_data, SpendingData);
        _assertClass(attrs, AddrAttributes);
        const ret = wasm.addressid_new(addr_type, spending_data.__wbg_ptr, attrs.__wbg_ptr);
        return AddressId.__wrap(ret);
    }
}

const AlonzoFormatTxOutFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_alonzoformattxout_free(ptr >>> 0, 1));

export class AlonzoFormatTxOut {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AlonzoFormatTxOut.prototype);
        obj.__wbg_ptr = ptr;
        AlonzoFormatTxOutFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AlonzoFormatTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_alonzoformattxout_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.alonzoformattxout_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.alonzoformattxout_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AlonzoFormatTxOut}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.alonzoformattxout_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AlonzoFormatTxOut.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.alonzoformattxout_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.alonzoformattxout_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AlonzoFormatTxOut}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.alonzoformattxout_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AlonzoFormatTxOut.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.alonzoformattxout_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.alonzoformattxout_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {AlonzoFormatTxOut}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.alonzoformattxout_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AlonzoFormatTxOut.__wrap(ret[0]);
    }
    /**
     * @returns {Address}
     */
    address() {
        const ret = wasm.alonzoformattxout_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @returns {Value}
     */
    amount() {
        const ret = wasm.alonzoformattxout_amount(this.__wbg_ptr);
        return Value.__wrap(ret);
    }
    /**
     * @param {DatumHash} datum_hash
     */
    set_datum_hash(datum_hash) {
        _assertClass(datum_hash, DatumHash);
        wasm.alonzoformattxout_set_datum_hash(this.__wbg_ptr, datum_hash.__wbg_ptr);
    }
    /**
     * @returns {DatumHash | undefined}
     */
    datum_hash() {
        const ret = wasm.alonzoformattxout_datum_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @param {Value} amount
     * @returns {AlonzoFormatTxOut}
     */
    static new(address, amount) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        const ret = wasm.alonzoformattxout_new(address.__wbg_ptr, amount.__wbg_ptr);
        return AlonzoFormatTxOut.__wrap(ret);
    }
}

const AnchorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_anchor_free(ptr >>> 0, 1));

export class Anchor {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Anchor.prototype);
        obj.__wbg_ptr = ptr;
        AnchorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AnchorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_anchor_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.anchor_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.anchor_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Anchor}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchor_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Anchor.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.anchor_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.anchor_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Anchor}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchor_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Anchor.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.anchor_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.anchor_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Anchor}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchor_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Anchor.__wrap(ret[0]);
    }
    /**
     * @returns {Url}
     */
    anchor_url() {
        const ret = wasm.anchor_anchor_url(this.__wbg_ptr);
        return Url.__wrap(ret);
    }
    /**
     * @returns {AnchorDocHash}
     */
    anchor_doc_hash() {
        const ret = wasm.anchor_anchor_doc_hash(this.__wbg_ptr);
        return AnchorDocHash.__wrap(ret);
    }
    /**
     * @param {Url} anchor_url
     * @param {AnchorDocHash} anchor_doc_hash
     * @returns {Anchor}
     */
    static new(anchor_url, anchor_doc_hash) {
        _assertClass(anchor_url, Url);
        _assertClass(anchor_doc_hash, AnchorDocHash);
        const ret = wasm.anchor_new(anchor_url.__wbg_ptr, anchor_doc_hash.__wbg_ptr);
        return Anchor.__wrap(ret);
    }
}

const AnchorDocHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_anchordochash_free(ptr >>> 0, 1));

export class AnchorDocHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AnchorDocHash.prototype);
        obj.__wbg_ptr = ptr;
        AnchorDocHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AnchorDocHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_anchordochash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.anchordochash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {AnchorDocHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchordochash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AnchorDocHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.anchordochash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {AnchorDocHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchordochash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AnchorDocHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.anchordochash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {AnchorDocHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.anchordochash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AnchorDocHash.__wrap(ret[0]);
    }
}

const AssetNameFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_assetname_free(ptr >>> 0, 1));

export class AssetName {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AssetName.prototype);
        obj.__wbg_ptr = ptr;
        AssetNameFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AssetNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assetname_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.assetname_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.assetname_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AssetName}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetname_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetname_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AssetName}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.assetname_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.assetname_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {AssetName}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
    /**
     *
     *     * Create an AssetName from utf8 string. 64 byte (not char!) maximum.
     *
     * @param {string} utf8_str
     * @returns {AssetName}
     */
    static from_str(utf8_str) {
        const ptr0 = passStringToWasm0(utf8_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_str(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
    /**
     *
     *     * AssetName as a utf8 string if it's possible. Will error if the asset is not utf8
     *
     * @returns {string}
     */
    to_str() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.assetname_to_str(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.assetname_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {AssetName}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.assetname_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {AssetName}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.assetname_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AssetName.__wrap(ret[0]);
    }
}

const AssetNameListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_assetnamelist_free(ptr >>> 0, 1));

export class AssetNameList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AssetNameList.prototype);
        obj.__wbg_ptr = ptr;
        AssetNameListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AssetNameListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assetnamelist_free(ptr, 0);
    }
    /**
     * @returns {AssetNameList}
     */
    static new() {
        const ret = wasm.assetnamelist_new();
        return AssetNameList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.assetnamelist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {AssetName}
     */
    get(index) {
        const ret = wasm.assetnamelist_get(this.__wbg_ptr, index);
        return AssetName.__wrap(ret);
    }
    /**
     * @param {AssetName} elem
     */
    add(elem) {
        _assertClass(elem, AssetName);
        wasm.assetnamelist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const AuthCommitteeHotCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_authcommitteehotcert_free(ptr >>> 0, 1));

export class AuthCommitteeHotCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AuthCommitteeHotCert.prototype);
        obj.__wbg_ptr = ptr;
        AuthCommitteeHotCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AuthCommitteeHotCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_authcommitteehotcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.authcommitteehotcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.authcommitteehotcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AuthCommitteeHotCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.authcommitteehotcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuthCommitteeHotCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.authcommitteehotcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.authcommitteehotcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AuthCommitteeHotCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.authcommitteehotcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuthCommitteeHotCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.authcommitteehotcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.authcommitteehotcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {AuthCommitteeHotCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.authcommitteehotcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuthCommitteeHotCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    committee_cold_credential() {
        const ret = wasm.authcommitteehotcert_committee_cold_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Credential}
     */
    committee_hot_credential() {
        const ret = wasm.authcommitteehotcert_committee_hot_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @param {Credential} committee_cold_credential
     * @param {Credential} committee_hot_credential
     * @returns {AuthCommitteeHotCert}
     */
    static new(committee_cold_credential, committee_hot_credential) {
        _assertClass(committee_cold_credential, Credential);
        _assertClass(committee_hot_credential, Credential);
        const ret = wasm.authcommitteehotcert_new(committee_cold_credential.__wbg_ptr, committee_hot_credential.__wbg_ptr);
        return AuthCommitteeHotCert.__wrap(ret);
    }
}

const AuxiliaryDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_auxiliarydata_free(ptr >>> 0, 1));

export class AuxiliaryData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AuxiliaryData.prototype);
        obj.__wbg_ptr = ptr;
        AuxiliaryDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AuxiliaryDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_auxiliarydata_free(ptr, 0);
    }
    /**
     * @returns {AuxiliaryData}
     */
    static new() {
        const ret = wasm.auxiliarydata_new();
        return AuxiliaryData.__wrap(ret);
    }
    /**
     * @returns {Metadata | undefined}
     */
    metadata() {
        const ret = wasm.auxiliarydata_metadata(this.__wbg_ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
     * @returns {NativeScriptList | undefined}
     */
    native_scripts() {
        const ret = wasm.auxiliarydata_native_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
     * @returns {PlutusV1ScriptList | undefined}
     */
    plutus_v1_scripts() {
        const ret = wasm.auxiliarydata_plutus_v1_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
     * @returns {PlutusV2ScriptList | undefined}
     */
    plutus_v2_scripts() {
        const ret = wasm.auxiliarydata_plutus_v2_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
     * Warning: overwrites any conflicting metadatum labels present
     * @param {Metadata} other
     */
    add_metadata(other) {
        _assertClass(other, Metadata);
        wasm.auxiliarydata_add_metadata(this.__wbg_ptr, other.__wbg_ptr);
    }
    /**
     * Warning: does not check for duplicates and may migrate eras
     * @param {NativeScriptList} scripts
     */
    add_native_scripts(scripts) {
        _assertClass(scripts, NativeScriptList);
        wasm.auxiliarydata_add_native_scripts(this.__wbg_ptr, scripts.__wbg_ptr);
    }
    /**
     * Warning: does not check for duplicates and may migrate eras
     * @param {PlutusV1ScriptList} scripts
     */
    add_plutus_v1_scripts(scripts) {
        _assertClass(scripts, PlutusV1ScriptList);
        wasm.auxiliarydata_add_plutus_v1_scripts(this.__wbg_ptr, scripts.__wbg_ptr);
    }
    /**
     * Warning: does not check for duplicates and may migrate eras
     * @param {PlutusV2ScriptList} scripts
     */
    add_plutus_v2_scripts(scripts) {
        _assertClass(scripts, PlutusV2ScriptList);
        wasm.auxiliarydata_add_plutus_v2_scripts(this.__wbg_ptr, scripts.__wbg_ptr);
    }
    /**
     * Adds everything present in other to self
     * May change the era the aux data is in if necessary
     * Warning: overwrites any metadatum labels present
     * also does not check for duplicates in scripts
     * @param {AuxiliaryData} other
     */
    add(other) {
        _assertClass(other, AuxiliaryData);
        wasm.auxiliarydata_add(this.__wbg_ptr, other.__wbg_ptr);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.auxiliarydata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.auxiliarydata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {AuxiliaryData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.auxiliarydata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.auxiliarydata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {AuxiliaryData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryData.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.auxiliarydata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.auxiliarydata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {AuxiliaryData}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryData.__wrap(ret[0]);
    }
    /**
     * @param {Metadata} shelley
     * @returns {AuxiliaryData}
     */
    static new_shelley(shelley) {
        _assertClass(shelley, Metadata);
        const ret = wasm.auxiliarydata_new_shelley(shelley.__wbg_ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
     * @param {ShelleyMAFormatAuxData} shelley_ma
     * @returns {AuxiliaryData}
     */
    static new_shelley_ma(shelley_ma) {
        _assertClass(shelley_ma, ShelleyMAFormatAuxData);
        const ret = wasm.auxiliarydata_new_shelley_ma(shelley_ma.__wbg_ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
     * @param {ConwayFormatAuxData} conway
     * @returns {AuxiliaryData}
     */
    static new_conway(conway) {
        _assertClass(conway, ConwayFormatAuxData);
        const ret = wasm.auxiliarydata_new_conway(conway.__wbg_ptr);
        return AuxiliaryData.__wrap(ret);
    }
    /**
     * @returns {AuxiliaryDataKind}
     */
    kind() {
        const ret = wasm.auxiliarydata_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Metadata | undefined}
     */
    as_shelley() {
        const ret = wasm.auxiliarydata_as_shelley(this.__wbg_ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
     * @returns {ShelleyMAFormatAuxData | undefined}
     */
    as_shelley_ma() {
        const ret = wasm.auxiliarydata_as_shelley_ma(this.__wbg_ptr);
        return ret === 0 ? undefined : ShelleyMAFormatAuxData.__wrap(ret);
    }
    /**
     * @returns {ConwayFormatAuxData | undefined}
     */
    as_conway() {
        const ret = wasm.auxiliarydata_as_conway(this.__wbg_ptr);
        return ret === 0 ? undefined : ConwayFormatAuxData.__wrap(ret);
    }
}

const AuxiliaryDataHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_auxiliarydatahash_free(ptr >>> 0, 1));

export class AuxiliaryDataHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AuxiliaryDataHash.prototype);
        obj.__wbg_ptr = ptr;
        AuxiliaryDataHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AuxiliaryDataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_auxiliarydatahash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.auxiliarydatahash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {AuxiliaryDataHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydatahash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryDataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.auxiliarydatahash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {AuxiliaryDataHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydatahash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryDataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.auxiliarydatahash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {AuxiliaryDataHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.auxiliarydatahash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AuxiliaryDataHash.__wrap(ret[0]);
    }
}

const BaseAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_baseaddress_free(ptr >>> 0, 1));

export class BaseAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BaseAddress.prototype);
        obj.__wbg_ptr = ptr;
        BaseAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BaseAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_baseaddress_free(ptr, 0);
    }
    /**
     * @param {number} network
     * @param {Credential} payment
     * @param {Credential} stake
     * @returns {BaseAddress}
     */
    static new(network, payment, stake) {
        _assertClass(payment, Credential);
        _assertClass(stake, Credential);
        const ret = wasm.baseaddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);
        return BaseAddress.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    to_address() {
        const ret = wasm.baseaddress_to_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @returns {BaseAddress | undefined}
     */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.baseaddress_from_address(address.__wbg_ptr);
        return ret === 0 ? undefined : BaseAddress.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.baseaddress_network_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Credential}
     */
    payment() {
        const ret = wasm.baseaddress_payment(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Credential}
     */
    stake() {
        const ret = wasm.baseaddress_stake(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
}

const BigIntegerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_biginteger_free(ptr >>> 0, 1));

export class BigInteger {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BigInteger.prototype);
        obj.__wbg_ptr = ptr;
        BigIntegerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BigIntegerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_biginteger_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.biginteger_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.biginteger_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {BigInteger}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.biginteger_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInteger.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.biginteger_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.biginteger_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {BigInteger}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.biginteger_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInteger.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.biginteger_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.biginteger_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {BigInteger}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.biginteger_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInteger.__wrap(ret[0]);
    }
    /**
     * @param {Int} x
     * @returns {BigInteger}
     */
    static from_int(x) {
        _assertClass(x, Int);
        const ret = wasm.biginteger_from_int(x.__wbg_ptr);
        return BigInteger.__wrap(ret);
    }
    /**
     * @param {string} s
     * @returns {BigInteger}
     */
    static from_str(s) {
        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.biginteger_from_str(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInteger.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_str() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.biginteger_to_str(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Converts to a u64
     * Returns None if the number was negative or too big for a u64
     * @returns {bigint | undefined}
     */
    as_u64() {
        const ret = wasm.biginteger_as_u64(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * Converts to an Int
     * Returns None when the number is too big for an Int (outside +/- 64-bit unsigned)
     * Retains encoding info if the original was encoded as an Int
     * @returns {Int | undefined}
     */
    as_int() {
        const ret = wasm.biginteger_as_int(this.__wbg_ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
}

const Bip32PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bip32privatekey_free(ptr >>> 0, 1));

export class Bip32PrivateKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Bip32PrivateKey.prototype);
        obj.__wbg_ptr = ptr;
        Bip32PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Bip32PrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bip32privatekey_free(ptr, 0);
    }
    /**
     * derive this private key with the given index.
     *
     * # Security considerations
     *
     * * hard derivation index cannot be soft derived with the public key
     *
     * # Hard derivation vs Soft derivation
     *
     * If you pass an index below 0x80000000 then it is a soft derivation.
     * The advantage of soft derivation is that it is possible to derive the
     * public key too. I.e. derivation the private key with a soft derivation
     * index and then retrieving the associated public key is equivalent to
     * deriving the public key associated to the parent private key.
     *
     * Hard derivation index does not allow public key derivation.
     *
     * This is why deriving the private key should not fail while deriving
     * the public key may fail (if the derivation index is invalid).
     * @param {number} index
     * @returns {Bip32PrivateKey}
     */
    derive(index) {
        const ret = wasm.bip32privatekey_derive(this.__wbg_ptr, index);
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
     * 128-byte xprv a key format in Cardano that some software still uses or requires
     * the traditional 96-byte xprv is simply encoded as
     * prv | chaincode
     * however, because some software may not know how to compute a public key from a private key,
     * the 128-byte inlines the public key in the following format
     * prv | pub | chaincode
     * so be careful if you see the term "xprv" as it could refer to either one
     * our library does not require the pub (instead we compute the pub key when needed)
     * @param {Uint8Array} bytes
     * @returns {Bip32PrivateKey}
     */
    static from_128_xprv(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bip32privatekey_from_128_xprv(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PrivateKey.__wrap(ret[0]);
    }
    /**
     * see from_128_xprv
     * @returns {Uint8Array}
     */
    to_128_xprv() {
        const ret = wasm.bip32privatekey_to_128_xprv(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {Bip32PrivateKey}
     */
    static generate_ed25519_bip32() {
        const ret = wasm.bip32privatekey_generate_ed25519_bip32();
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
     * @returns {PrivateKey}
     */
    to_raw_key() {
        const ret = wasm.bip32privatekey_to_raw_key(this.__wbg_ptr);
        return PrivateKey.__wrap(ret);
    }
    /**
     * @returns {Bip32PublicKey}
     */
    to_public() {
        const ret = wasm.bip32privatekey_to_public(this.__wbg_ptr);
        return Bip32PublicKey.__wrap(ret);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {Bip32PrivateKey}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bip32privatekey_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PrivateKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.bip32privatekey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {string} bech32_str
     * @returns {Bip32PrivateKey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bip32privatekey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PrivateKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_bech32() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.bip32privatekey_to_bech32(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {Uint8Array} entropy
     * @param {Uint8Array} password
     * @returns {Bip32PrivateKey}
     */
    static from_bip39_entropy(entropy, password) {
        const ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);
        return Bip32PrivateKey.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    chaincode() {
        const ret = wasm.bip32privatekey_chaincode(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const Bip32PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bip32publickey_free(ptr >>> 0, 1));

export class Bip32PublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Bip32PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        Bip32PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Bip32PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bip32publickey_free(ptr, 0);
    }
    /**
     * derive this public key with the given index.
     *
     * # Errors
     *
     * If the index is not a soft derivation index (< 0x80000000) then
     * calling this method will fail.
     *
     * # Security considerations
     *
     * * hard derivation index cannot be soft derived with the public key
     *
     * # Hard derivation vs Soft derivation
     *
     * If you pass an index below 0x80000000 then it is a soft derivation.
     * The advantage of soft derivation is that it is possible to derive the
     * public key too. I.e. derivation the private key with a soft derivation
     * index and then retrieving the associated public key is equivalent to
     * deriving the public key associated to the parent private key.
     *
     * Hard derivation index does not allow public key derivation.
     *
     * This is why deriving the private key should not fail while deriving
     * the public key may fail (if the derivation index is invalid).
     * @param {number} index
     * @returns {Bip32PublicKey}
     */
    derive(index) {
        const ret = wasm.bip32publickey_derive(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {PublicKey}
     */
    to_raw_key() {
        const ret = wasm.bip32publickey_to_raw_key(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {Bip32PublicKey}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bip32publickey_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.bip32publickey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {string} bech32_str
     * @returns {Bip32PublicKey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bip32publickey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Bip32PublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_bech32() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.bip32publickey_to_bech32(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    chaincode() {
        const ret = wasm.bip32publickey_chaincode(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const BlockFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_block_free(ptr >>> 0, 1));

export class Block {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Block.prototype);
        obj.__wbg_ptr = ptr;
        BlockFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BlockFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_block_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.block_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.block_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Block}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.block_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Block.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.block_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.block_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Block}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.block_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Block.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.block_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.block_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Block}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.block_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Block.__wrap(ret[0]);
    }
    /**
     * @returns {Header}
     */
    header() {
        const ret = wasm.block_header(this.__wbg_ptr);
        return Header.__wrap(ret);
    }
    /**
     * @returns {TransactionBodyList}
     */
    transaction_bodies() {
        const ret = wasm.block_transaction_bodies(this.__wbg_ptr);
        return TransactionBodyList.__wrap(ret);
    }
    /**
     * @returns {TransactionWitnessSetList}
     */
    transaction_witness_sets() {
        const ret = wasm.block_transaction_witness_sets(this.__wbg_ptr);
        return TransactionWitnessSetList.__wrap(ret);
    }
    /**
     * @returns {MapTransactionIndexToAuxiliaryData}
     */
    auxiliary_data_set() {
        const ret = wasm.block_auxiliary_data_set(this.__wbg_ptr);
        return MapTransactionIndexToAuxiliaryData.__wrap(ret);
    }
    /**
     * @returns {Uint16Array}
     */
    invalid_transactions() {
        const ret = wasm.block_invalid_transactions(this.__wbg_ptr);
        var v1 = getArrayU16FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);
        return v1;
    }
    /**
     * @param {Header} header
     * @param {TransactionBodyList} transaction_bodies
     * @param {TransactionWitnessSetList} transaction_witness_sets
     * @param {MapTransactionIndexToAuxiliaryData} auxiliary_data_set
     * @param {Uint16Array} invalid_transactions
     * @returns {Block}
     */
    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {
        _assertClass(header, Header);
        _assertClass(transaction_bodies, TransactionBodyList);
        _assertClass(transaction_witness_sets, TransactionWitnessSetList);
        _assertClass(auxiliary_data_set, MapTransactionIndexToAuxiliaryData);
        const ptr0 = passArray16ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.block_new(header.__wbg_ptr, transaction_bodies.__wbg_ptr, transaction_witness_sets.__wbg_ptr, auxiliary_data_set.__wbg_ptr, ptr0, len0);
        return Block.__wrap(ret);
    }
}

const BlockBodyHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_blockbodyhash_free(ptr >>> 0, 1));

export class BlockBodyHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BlockBodyHash.prototype);
        obj.__wbg_ptr = ptr;
        BlockBodyHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BlockBodyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockbodyhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.blockbodyhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {BlockBodyHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockbodyhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockBodyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.blockbodyhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {BlockBodyHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockbodyhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockBodyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.blockbodyhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {BlockBodyHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockbodyhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockBodyHash.__wrap(ret[0]);
    }
}

const BlockHeaderHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_blockheaderhash_free(ptr >>> 0, 1));

export class BlockHeaderHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BlockHeaderHash.prototype);
        obj.__wbg_ptr = ptr;
        BlockHeaderHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BlockHeaderHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_blockheaderhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.blockheaderhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {BlockHeaderHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockheaderhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockHeaderHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.blockheaderhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {BlockHeaderHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockheaderhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockHeaderHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.blockheaderhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {BlockHeaderHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.blockheaderhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BlockHeaderHash.__wrap(ret[0]);
    }
}

const BootstrapWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bootstrapwitness_free(ptr >>> 0, 1));

export class BootstrapWitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BootstrapWitness.prototype);
        obj.__wbg_ptr = ptr;
        BootstrapWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BootstrapWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bootstrapwitness_free(ptr, 0);
    }
    /**
     * @returns {AddressContent}
     */
    to_address() {
        const ret = wasm.bootstrapwitness_to_address(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return AddressContent.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.bootstrapwitness_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.bootstrapwitness_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {BootstrapWitness}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bootstrapwitness_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BootstrapWitness.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.bootstrapwitness_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.bootstrapwitness_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {BootstrapWitness}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bootstrapwitness_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BootstrapWitness.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.bootstrapwitness_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.bootstrapwitness_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {BootstrapWitness}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.bootstrapwitness_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BootstrapWitness.__wrap(ret[0]);
    }
    /**
     * @returns {PublicKey}
     */
    public_key() {
        const ret = wasm.bootstrapwitness_public_key(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {Ed25519Signature}
     */
    signature() {
        const ret = wasm.bootstrapwitness_signature(this.__wbg_ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
     * @returns {Uint8Array}
     */
    chain_code() {
        const ret = wasm.bootstrapwitness_chain_code(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {AddrAttributes}
     */
    attributes() {
        const ret = wasm.bootstrapwitness_attributes(this.__wbg_ptr);
        return AddrAttributes.__wrap(ret);
    }
    /**
     * @param {PublicKey} public_key
     * @param {Ed25519Signature} signature
     * @param {Uint8Array} chain_code
     * @param {AddrAttributes} attributes
     * @returns {BootstrapWitness}
     */
    static new(public_key, signature, chain_code, attributes) {
        _assertClass(public_key, PublicKey);
        _assertClass(signature, Ed25519Signature);
        const ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(attributes, AddrAttributes);
        const ret = wasm.bootstrapwitness_new(public_key.__wbg_ptr, signature.__wbg_ptr, ptr0, len0, attributes.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BootstrapWitness.__wrap(ret[0]);
    }
}

const BootstrapWitnessListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bootstrapwitnesslist_free(ptr >>> 0, 1));

export class BootstrapWitnessList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BootstrapWitnessList.prototype);
        obj.__wbg_ptr = ptr;
        BootstrapWitnessListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BootstrapWitnessListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bootstrapwitnesslist_free(ptr, 0);
    }
    /**
     * @returns {BootstrapWitnessList}
     */
    static new() {
        const ret = wasm.bootstrapwitnesslist_new();
        return BootstrapWitnessList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.bootstrapwitnesslist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {BootstrapWitness}
     */
    get(index) {
        const ret = wasm.bootstrapwitnesslist_get(this.__wbg_ptr, index);
        return BootstrapWitness.__wrap(ret);
    }
    /**
     * @param {BootstrapWitness} elem
     */
    add(elem) {
        _assertClass(elem, BootstrapWitness);
        wasm.bootstrapwitnesslist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const ByronAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_byronaddress_free(ptr >>> 0, 1));

export class ByronAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ByronAddress.prototype);
        obj.__wbg_ptr = ptr;
        ByronAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ByronAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byronaddress_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.byronaddress_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ByronAddress}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronaddress_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronAddress.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.byronaddress_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ByronAddress}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronaddress_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronAddress.__wrap(ret[0]);
    }
    /**
     * @returns {AddressContent}
     */
    content() {
        const ret = wasm.byronaddress_content(this.__wbg_ptr);
        return AddressContent.__wrap(ret);
    }
    /**
     * @returns {Crc32}
     */
    crc() {
        const ret = wasm.byronaddress_crc(this.__wbg_ptr);
        return Crc32.__wrap(ret);
    }
    /**
     * @param {AddressContent} content
     * @param {Crc32} crc
     * @returns {ByronAddress}
     */
    static new(content, crc) {
        _assertClass(content, AddressContent);
        _assertClass(crc, Crc32);
        const ret = wasm.byronaddress_new(content.__wbg_ptr, crc.__wbg_ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    to_base58() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.byronaddress_to_base58(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} s
     * @returns {ByronAddress}
     */
    static from_base58(s) {
        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronaddress_from_base58(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronAddress.__wrap(ret[0]);
    }
    /**
     * @param {string} s
     * @returns {boolean}
     */
    static is_valid(s) {
        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronaddress_is_valid(ptr0, len0);
        return ret !== 0;
    }
    /**
     * @returns {Address}
     */
    to_address() {
        const ret = wasm.byronaddress_to_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} addr
     * @returns {ByronAddress | undefined}
     */
    static from_address(addr) {
        _assertClass(addr, Address);
        const ret = wasm.byronaddress_from_address(addr.__wbg_ptr);
        return ret === 0 ? undefined : ByronAddress.__wrap(ret);
    }
    /**
     * @param {AddressContent} address_content
     * @returns {ByronAddress}
     */
    static from_address_content(address_content) {
        _assertClass(address_content, AddressContent);
        const ret = wasm.byronaddress_from_address_content(address_content.__wbg_ptr);
        return ByronAddress.__wrap(ret);
    }
}

const ByronGenesisRedeemFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_byrongenesisredeem_free(ptr >>> 0, 1));

export class ByronGenesisRedeem {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ByronGenesisRedeem.prototype);
        obj.__wbg_ptr = ptr;
        ByronGenesisRedeemFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ByronGenesisRedeemFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byrongenesisredeem_free(ptr, 0);
    }
    /**
     * @param {TransactionHash} txid
     * @param {ByronAddress} address
     * @returns {ByronGenesisRedeem}
     */
    static new(txid, address) {
        _assertClass(txid, TransactionHash);
        _assertClass(address, ByronAddress);
        const ret = wasm.byrongenesisredeem_new(txid.__wbg_ptr, address.__wbg_ptr);
        return ByronGenesisRedeem.__wrap(ret);
    }
    /**
     * @returns {TransactionHash}
     */
    txid() {
        const ret = wasm.byrongenesisredeem_txid(this.__wbg_ptr);
        return TransactionHash.__wrap(ret);
    }
    /**
     * @returns {ByronAddress}
     */
    address() {
        const ret = wasm.byrongenesisredeem_address(this.__wbg_ptr);
        return ByronAddress.__wrap(ret);
    }
}

const ByronScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_byronscript_free(ptr >>> 0, 1));

export class ByronScript {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ByronScript.prototype);
        obj.__wbg_ptr = ptr;
        ByronScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ByronScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byronscript_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.byronscript_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {ByronScript}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronscript_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronScript.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.byronscript_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {ByronScript}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronscript_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronScript.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.byronscript_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {ByronScript}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byronscript_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronScript.__wrap(ret[0]);
    }
}

const ByronTxOutFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_byrontxout_free(ptr >>> 0, 1));

export class ByronTxOut {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ByronTxOut.prototype);
        obj.__wbg_ptr = ptr;
        ByronTxOutFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ByronTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_byrontxout_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.byrontxout_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ByronTxOut}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byrontxout_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronTxOut.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.byrontxout_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ByronTxOut}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.byrontxout_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ByronTxOut.__wrap(ret[0]);
    }
    /**
     * @returns {ByronAddress}
     */
    address() {
        const ret = wasm.byrontxout_address(this.__wbg_ptr);
        return ByronAddress.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    amount() {
        const ret = wasm.byrontxout_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {ByronAddress} address
     * @param {bigint} amount
     * @returns {ByronTxOut}
     */
    static new(address, amount) {
        _assertClass(address, ByronAddress);
        const ret = wasm.byrontxout_new(address.__wbg_ptr, amount);
        return ByronTxOut.__wrap(ret);
    }
}

const CIP25ChunkableStringFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25chunkablestring_free(ptr >>> 0, 1));
/**
 * A String that may or may not be chunked into 64-byte chunks to be able
 * to conform to Cardano TX Metadata limitations.
 * Most users should simply use CIP25ChunkableString::from_string() and CIP25ChunkableString::to_string()
 * and avoid the explicit single/chunk interface:
 * ```javascript
 * let chunkableString = CIP25.CIP25ChunkableString.from_string("this can be any length and will automatically be chunked if needed");
 * ```
 */
export class CIP25ChunkableString {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25ChunkableString.prototype);
        obj.__wbg_ptr = ptr;
        CIP25ChunkableStringFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25ChunkableStringFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25chunkablestring_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25chunkablestring_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP25ChunkableString}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25chunkablestring_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25ChunkableString.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25chunkablestring_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP25ChunkableString}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25chunkablestring_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25ChunkableString.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25chunkablestring_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25chunkablestring_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25ChunkableString}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25chunkablestring_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25ChunkableString.__wrap(ret[0]);
    }
    /**
     * @param {CIP25String64} single
     * @returns {CIP25ChunkableString}
     */
    static new_single(single) {
        _assertClass(single, CIP25String64);
        const ret = wasm.cip25chunkablestring_new_single(single.__wbg_ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @param {CIP25String64List} chunked
     * @returns {CIP25ChunkableString}
     */
    static new_chunked(chunked) {
        _assertClass(chunked, CIP25String64List);
        const ret = wasm.cip25chunkablestring_new_chunked(chunked.__wbg_ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @returns {ChunkableStringKind}
     */
    kind() {
        const ret = wasm.cip25chunkablestring_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {CIP25String64 | undefined}
     */
    as_single() {
        const ret = wasm.cip25chunkablestring_as_single(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
     * @returns {CIP25String64List | undefined}
     */
    as_chunked() {
        const ret = wasm.cip25chunkablestring_as_chunked(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25String64List.__wrap(ret);
    }
    /**
     * @param {string} str
     * @returns {CIP25ChunkableString}
     */
    static from_string(str) {
        const ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25chunkablestring_from_string(ptr0, len0);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    to_string() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25chunkablestring_to_string(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const CIP25FilesDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25filesdetails_free(ptr >>> 0, 1));

export class CIP25FilesDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25FilesDetails.prototype);
        obj.__wbg_ptr = ptr;
        CIP25FilesDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25FilesDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25filesdetails_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25filesdetails_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP25FilesDetails}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25filesdetails_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25FilesDetails.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25filesdetails_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP25FilesDetails}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25filesdetails_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25FilesDetails.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25filesdetails_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25filesdetails_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25FilesDetails}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25filesdetails_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25FilesDetails.__wrap(ret[0]);
    }
    /**
     * @returns {CIP25String64}
     */
    name() {
        const ret = wasm.cip25filesdetails_name(this.__wbg_ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
     * @returns {CIP25String64}
     */
    media_type() {
        const ret = wasm.cip25filesdetails_media_type(this.__wbg_ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
     * @returns {CIP25ChunkableString}
     */
    src() {
        const ret = wasm.cip25filesdetails_src(this.__wbg_ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @param {CIP25String64} name
     * @param {CIP25String64} media_type
     * @param {CIP25ChunkableString} src
     * @returns {CIP25FilesDetails}
     */
    static new(name, media_type, src) {
        _assertClass(name, CIP25String64);
        _assertClass(media_type, CIP25String64);
        _assertClass(src, CIP25ChunkableString);
        const ret = wasm.cip25filesdetails_new(name.__wbg_ptr, media_type.__wbg_ptr, src.__wbg_ptr);
        return CIP25FilesDetails.__wrap(ret);
    }
}

const CIP25LabelMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25labelmetadata_free(ptr >>> 0, 1));

export class CIP25LabelMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25LabelMetadata.prototype);
        obj.__wbg_ptr = ptr;
        CIP25LabelMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25LabelMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25labelmetadata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25labelmetadata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP25LabelMetadata}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25labelmetadata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25LabelMetadata.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25labelmetadata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP25LabelMetadata}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25labelmetadata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25LabelMetadata.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25labelmetadata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25labelmetadata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25LabelMetadata}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25labelmetadata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25LabelMetadata.__wrap(ret[0]);
    }
    /**
     * Note that Version 1 can only support utf8 string asset names.
     * Version 2 can support any asset name.
     * @param {CIP25Version} version
     * @returns {CIP25LabelMetadata}
     */
    static new(version) {
        const ret = wasm.cip25labelmetadata_new(version);
        return CIP25LabelMetadata.__wrap(ret);
    }
    /**
     * If this is version 1 and the asset name is not a utf8 asset name
     * then this will return an error.
     * This function will never return an error for version 2.
     * On success, returns the previous details that were overwritten, or None otherwise.
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset_name
     * @param {CIP25MetadataDetails} details
     * @returns {CIP25MetadataDetails | undefined}
     */
    set(policy_id, asset_name, details) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset_name, AssetName);
        _assertClass(details, CIP25MetadataDetails);
        const ret = wasm.cip25labelmetadata_set(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr, details.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] === 0 ? undefined : CIP25MetadataDetails.__wrap(ret[0]);
    }
    /**
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset_name
     * @returns {CIP25MetadataDetails | undefined}
     */
    get(policy_id, asset_name) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset_name, AssetName);
        const ret = wasm.cip25labelmetadata_get(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr);
        return ret === 0 ? undefined : CIP25MetadataDetails.__wrap(ret);
    }
    /**
     * @returns {CIP25Version}
     */
    version() {
        const ret = wasm.cip25labelmetadata_version(this.__wbg_ptr);
        return ret;
    }
}

const CIP25MetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25metadata_free(ptr >>> 0, 1));
/**
 * This is the entire metadata schema for CIP-25
 * It can be parsed by passing in the CBOR bytes of the entire transaction metadata
 * or by passing in an existing Metadata struct.
 * Parsing from CBOR bytes should be marginally faster.
 */
export class CIP25Metadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25Metadata.prototype);
        obj.__wbg_ptr = ptr;
        CIP25MetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25metadata_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25metadata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25metadata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25Metadata}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25metadata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25Metadata.__wrap(ret[0]);
    }
    /**
     * Serialize to CBOR bytes compatible with tx metadata
     * Does not guarantee any specific type of CBOR format and should NOT
     * be used with round-tripping. It will ignore all non-CIP25 keys.
     * Use cml_cip25::metadate crate for round-tripping metadata.
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25metadata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * Deserialize from CBOR bytes compatible with tx metadata
     * Does not guarantee any specific type of CBOR format and should NOT
     * be used with round-tripping. It will ignore all non-CIP25 keys.
     * Use cml_cip25::metadate crate for round-tripping metadata.
     * @param {Uint8Array} data
     * @returns {CIP25Metadata}
     */
    static from_cbor_bytes(data) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25metadata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25Metadata.__wrap(ret[0]);
    }
    /**
     * The core details of the CIP25 spec
     * @returns {CIP25LabelMetadata}
     */
    key_721() {
        const ret = wasm.cip25metadata_key_721(this.__wbg_ptr);
        return CIP25LabelMetadata.__wrap(ret);
    }
    /**
     * @param {CIP25LabelMetadata} key_721
     * @returns {CIP25Metadata}
     */
    static new(key_721) {
        _assertClass(key_721, CIP25LabelMetadata);
        const ret = wasm.cip25metadata_new(key_721.__wbg_ptr);
        return CIP25Metadata.__wrap(ret);
    }
    /**
     * Create a Metadata containing only the CIP25 schema
     * @returns {Metadata}
     */
    to_metadata() {
        const ret = wasm.cip25metadata_to_metadata(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Metadata.__wrap(ret[0]);
    }
    /**
     * Read the CIP25 schema from a Metadata. Ignores all other data besides CIP25
     * Can fail if the Metadata does not conform to CIP25
     * @param {Metadata} metadata
     * @returns {CIP25Metadata}
     */
    static from_metadata(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.cip25metadata_from_metadata(metadata.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25Metadata.__wrap(ret[0]);
    }
    /**
     * Add to an existing metadata (could be empty) the full CIP25 metadata
     * @param {Metadata} metadata
     */
    add_to_metadata(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.cip25metadata_add_to_metadata(this.__wbg_ptr, metadata.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
}

const CIP25MetadataDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25metadatadetails_free(ptr >>> 0, 1));

export class CIP25MetadataDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25MetadataDetails.prototype);
        obj.__wbg_ptr = ptr;
        CIP25MetadataDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25MetadataDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25metadatadetails_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25metadatadetails_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP25MetadataDetails}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25metadatadetails_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25MetadataDetails.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25metadatadetails_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP25MetadataDetails}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25metadatadetails_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25MetadataDetails.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25metadatadetails_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25metadatadetails_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25MetadataDetails}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25metadatadetails_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25MetadataDetails.__wrap(ret[0]);
    }
    /**
     * @returns {CIP25String64}
     */
    name() {
        const ret = wasm.cip25metadatadetails_name(this.__wbg_ptr);
        return CIP25String64.__wrap(ret);
    }
    /**
     * @returns {CIP25ChunkableString}
     */
    image() {
        const ret = wasm.cip25metadatadetails_image(this.__wbg_ptr);
        return CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @param {CIP25String64} media_type
     */
    set_media_type(media_type) {
        _assertClass(media_type, CIP25String64);
        wasm.cip25metadatadetails_set_media_type(this.__wbg_ptr, media_type.__wbg_ptr);
    }
    /**
     * @returns {CIP25String64 | undefined}
     */
    media_type() {
        const ret = wasm.cip25metadatadetails_media_type(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
     * @param {CIP25ChunkableString} description
     */
    set_description(description) {
        _assertClass(description, CIP25ChunkableString);
        wasm.cip25metadatadetails_set_description(this.__wbg_ptr, description.__wbg_ptr);
    }
    /**
     * @returns {CIP25ChunkableString | undefined}
     */
    description() {
        const ret = wasm.cip25metadatadetails_description(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25ChunkableString.__wrap(ret);
    }
    /**
     * @param {FilesDetailsList} files
     */
    set_files(files) {
        _assertClass(files, FilesDetailsList);
        wasm.cip25metadatadetails_set_files(this.__wbg_ptr, files.__wbg_ptr);
    }
    /**
     * @returns {FilesDetailsList | undefined}
     */
    files() {
        const ret = wasm.cip25metadatadetails_files(this.__wbg_ptr);
        return ret === 0 ? undefined : FilesDetailsList.__wrap(ret);
    }
    /**
     * @param {CIP25String64} name
     * @param {CIP25ChunkableString} image
     * @returns {CIP25MetadataDetails}
     */
    static new(name, image) {
        _assertClass(name, CIP25String64);
        _assertClass(image, CIP25ChunkableString);
        const ret = wasm.cip25metadatadetails_new(name.__wbg_ptr, image.__wbg_ptr);
        return CIP25MetadataDetails.__wrap(ret);
    }
}

const CIP25MiniMetadataDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25minimetadatadetails_free(ptr >>> 0, 1));

export class CIP25MiniMetadataDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25MiniMetadataDetails.prototype);
        obj.__wbg_ptr = ptr;
        CIP25MiniMetadataDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25MiniMetadataDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25minimetadatadetails_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25minimetadatadetails_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25minimetadatadetails_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25MiniMetadataDetails}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25minimetadatadetails_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25MiniMetadataDetails.__wrap(ret[0]);
    }
    /**
     * @returns {CIP25MiniMetadataDetails}
     */
    static new() {
        const ret = wasm.cip25minimetadatadetails_new();
        return CIP25MiniMetadataDetails.__wrap(ret);
    }
    /**
     * @param {CIP25String64} name
     */
    set_name(name) {
        _assertClass(name, CIP25String64);
        wasm.cip25minimetadatadetails_set_name(this.__wbg_ptr, name.__wbg_ptr);
    }
    /**
     * @returns {CIP25String64 | undefined}
     */
    name() {
        const ret = wasm.cip25minimetadatadetails_name(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25String64.__wrap(ret);
    }
    /**
     * @param {CIP25ChunkableString} image
     */
    set_image(image) {
        _assertClass(image, CIP25ChunkableString);
        wasm.cip25minimetadatadetails_set_image(this.__wbg_ptr, image.__wbg_ptr);
    }
    /**
     * @returns {CIP25ChunkableString | undefined}
     */
    image() {
        const ret = wasm.cip25minimetadatadetails_image(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP25ChunkableString.__wrap(ret);
    }
    /**
     * loose parsing of CIP25 metadata to allow for common exceptions to the format
     * `metadatum` should represent the data where the `CIP25MetadataDetails` is in the cip25 structure
     * @param {TransactionMetadatum} metadatum
     * @returns {CIP25MiniMetadataDetails}
     */
    static loose_parse(metadatum) {
        _assertClass(metadatum, TransactionMetadatum);
        const ret = wasm.cip25minimetadatadetails_loose_parse(metadatum.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25MiniMetadataDetails.__wrap(ret[0]);
    }
}

const CIP25String64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25string64_free(ptr >>> 0, 1));
/**
 * A String of at most 64 bytes.
 * This is to conform with Cardano metadata restrictions.
 */
export class CIP25String64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25String64.prototype);
        obj.__wbg_ptr = ptr;
        CIP25String64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25String64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25string64_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip25string64_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP25String64}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25string64_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25String64.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25string64_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP25String64}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25string64_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25String64.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip25string64_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip25string64_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP25String64}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25string64_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25String64.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25string64_get(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} s
     * @returns {CIP25String64}
     */
    static new(s) {
        const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip25string64_new(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP25String64.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_str() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25string64_to_str(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    get_str() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip25string64_get_str(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const CIP25String64ListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip25string64list_free(ptr >>> 0, 1));

export class CIP25String64List {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP25String64List.prototype);
        obj.__wbg_ptr = ptr;
        CIP25String64ListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP25String64ListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip25string64list_free(ptr, 0);
    }
    /**
     * @returns {CIP25String64List}
     */
    static new() {
        const ret = wasm.cip25string64list_new();
        return CIP25String64List.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.cip25string64list_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {CIP25String64}
     */
    get(index) {
        const ret = wasm.cip25string64list_get(this.__wbg_ptr, index);
        return CIP25String64.__wrap(ret);
    }
    /**
     * @param {CIP25String64} elem
     */
    add(elem) {
        _assertClass(elem, CIP25String64);
        wasm.cip25string64list_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const CIP36DelegationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36delegation_free(ptr >>> 0, 1));

export class CIP36Delegation {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36Delegation.prototype);
        obj.__wbg_ptr = ptr;
        CIP36DelegationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36DelegationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegation_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36delegation_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36delegation_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36Delegation}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegation_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36Delegation.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36delegation_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36delegation_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36Delegation}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegation_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36Delegation.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36delegation_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36delegation_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36Delegation}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegation_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36Delegation.__wrap(ret[0]);
    }
    /**
     * @returns {PublicKey}
     */
    voting_pub_key() {
        const ret = wasm.cip36delegation_voting_pub_key(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    weight() {
        const ret = wasm.cip36delegation_weight(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {PublicKey} voting_pub_key
     * @param {number} weight
     * @returns {CIP36Delegation}
     */
    static new(voting_pub_key, weight) {
        _assertClass(voting_pub_key, PublicKey);
        const ret = wasm.cip36delegation_new(voting_pub_key.__wbg_ptr, weight);
        return CIP36Delegation.__wrap(ret);
    }
}

const CIP36DelegationDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36delegationdistribution_free(ptr >>> 0, 1));

export class CIP36DelegationDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36DelegationDistribution.prototype);
        obj.__wbg_ptr = ptr;
        CIP36DelegationDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36DelegationDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegationdistribution_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36delegationdistribution_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36delegationdistribution_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36DelegationDistribution}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegationdistribution_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DelegationDistribution.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36delegationdistribution_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36delegationdistribution_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36DelegationDistribution}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegationdistribution_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DelegationDistribution.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36delegationdistribution_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36delegationdistribution_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36DelegationDistribution}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36delegationdistribution_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DelegationDistribution.__wrap(ret[0]);
    }
    /**
     * @param {CIP36DelegationList} delegations
     * @returns {CIP36DelegationDistribution}
     */
    static new_weighted(delegations) {
        _assertClass(delegations, CIP36DelegationList);
        const ret = wasm.cip36delegationdistribution_new_weighted(delegations.__wbg_ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
     * @param {PublicKey} legacy
     * @returns {CIP36DelegationDistribution}
     */
    static new_legacy(legacy) {
        _assertClass(legacy, PublicKey);
        const ret = wasm.cip36delegationdistribution_new_legacy(legacy.__wbg_ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
     * @returns {DelegationDistributionKind}
     */
    kind() {
        const ret = wasm.cip36delegationdistribution_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {CIP36DelegationList | undefined}
     */
    as_weighted() {
        const ret = wasm.cip36delegationdistribution_as_weighted(this.__wbg_ptr);
        return ret === 0 ? undefined : CIP36DelegationList.__wrap(ret);
    }
    /**
     * @returns {PublicKey | undefined}
     */
    as_legacy() {
        const ret = wasm.cip36delegationdistribution_as_legacy(this.__wbg_ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
}

const CIP36DelegationListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36delegationlist_free(ptr >>> 0, 1));

export class CIP36DelegationList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36DelegationList.prototype);
        obj.__wbg_ptr = ptr;
        CIP36DelegationListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36DelegationListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36delegationlist_free(ptr, 0);
    }
    /**
     * @returns {CIP36DelegationList}
     */
    static new() {
        const ret = wasm.cip36delegationlist_new();
        return CIP36DelegationList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.cip36delegationlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {CIP36Delegation}
     */
    get(index) {
        const ret = wasm.cip36delegationlist_get(this.__wbg_ptr, index);
        return CIP36Delegation.__wrap(ret);
    }
    /**
     * @param {CIP36Delegation} elem
     */
    add(elem) {
        _assertClass(elem, CIP36Delegation);
        wasm.cip36delegationlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const CIP36DeregistrationCborFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36deregistrationcbor_free(ptr >>> 0, 1));

export class CIP36DeregistrationCbor {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36DeregistrationCbor.prototype);
        obj.__wbg_ptr = ptr;
        CIP36DeregistrationCborFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36DeregistrationCborFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36deregistrationcbor_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36deregistrationcbor_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36deregistrationcbor_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36DeregistrationCbor}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36deregistrationcbor_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DeregistrationCbor.__wrap(ret[0]);
    }
    /**
     * @returns {CIP36KeyDeregistration}
     */
    key_deregistration() {
        const ret = wasm.cip36deregistrationcbor_key_deregistration(this.__wbg_ptr);
        return CIP36KeyDeregistration.__wrap(ret);
    }
    /**
     * @returns {CIP36DeregistrationWitness}
     */
    deregistration_witness() {
        const ret = wasm.cip36deregistrationcbor_deregistration_witness(this.__wbg_ptr);
        return CIP36DeregistrationWitness.__wrap(ret);
    }
    /**
     * @param {CIP36KeyDeregistration} key_deregistration
     * @param {CIP36DeregistrationWitness} deregistration_witness
     * @returns {CIP36DeregistrationCbor}
     */
    static new(key_deregistration, deregistration_witness) {
        _assertClass(key_deregistration, CIP36KeyDeregistration);
        _assertClass(deregistration_witness, CIP36DeregistrationWitness);
        const ret = wasm.cip36deregistrationcbor_new(key_deregistration.__wbg_ptr, deregistration_witness.__wbg_ptr);
        return CIP36DeregistrationCbor.__wrap(ret);
    }
}

const CIP36DeregistrationWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36deregistrationwitness_free(ptr >>> 0, 1));

export class CIP36DeregistrationWitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36DeregistrationWitness.prototype);
        obj.__wbg_ptr = ptr;
        CIP36DeregistrationWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36DeregistrationWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36deregistrationwitness_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36deregistrationwitness_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36deregistrationwitness_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36DeregistrationWitness}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36deregistrationwitness_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DeregistrationWitness.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36deregistrationwitness_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36deregistrationwitness_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36DeregistrationWitness}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36deregistrationwitness_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DeregistrationWitness.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36deregistrationwitness_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36deregistrationwitness_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36DeregistrationWitness}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36deregistrationwitness_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36DeregistrationWitness.__wrap(ret[0]);
    }
    /**
     * @returns {Ed25519Signature}
     */
    stake_witness() {
        const ret = wasm.cip36deregistrationwitness_stake_witness(this.__wbg_ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
     * @param {Ed25519Signature} stake_witness
     * @returns {CIP36DeregistrationWitness}
     */
    static new(stake_witness) {
        _assertClass(stake_witness, Ed25519Signature);
        const ret = wasm.cip36deregistrationwitness_new(stake_witness.__wbg_ptr);
        return CIP36DeregistrationWitness.__wrap(ret);
    }
}

const CIP36KeyDeregistrationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36keyderegistration_free(ptr >>> 0, 1));

export class CIP36KeyDeregistration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36KeyDeregistration.prototype);
        obj.__wbg_ptr = ptr;
        CIP36KeyDeregistrationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36KeyDeregistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36keyderegistration_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36keyderegistration_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36keyderegistration_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36KeyDeregistration}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyderegistration_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyDeregistration.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36keyderegistration_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36keyderegistration_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36KeyDeregistration}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyderegistration_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyDeregistration.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36keyderegistration_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36keyderegistration_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36KeyDeregistration}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyderegistration_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyDeregistration.__wrap(ret[0]);
    }
    /**
     * @returns {PublicKey}
     */
    stake_credential() {
        const ret = wasm.cip36keyderegistration_stake_credential(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    nonce() {
        const ret = wasm.cip36keyderegistration_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} voting_purpose
     */
    set_voting_purpose(voting_purpose) {
        wasm.cip36keyderegistration_set_voting_purpose(this.__wbg_ptr, voting_purpose);
    }
    /**
     * @returns {bigint}
     */
    voting_purpose() {
        const ret = wasm.cip36keyderegistration_voting_purpose(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
}

const CIP36KeyRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36keyregistration_free(ptr >>> 0, 1));

export class CIP36KeyRegistration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36KeyRegistration.prototype);
        obj.__wbg_ptr = ptr;
        CIP36KeyRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36KeyRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36keyregistration_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36keyregistration_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36keyregistration_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36KeyRegistration}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyregistration_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyRegistration.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36keyregistration_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36keyregistration_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36KeyRegistration}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyregistration_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36keyregistration_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36keyregistration_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36KeyRegistration}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36keyregistration_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36KeyRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {CIP36DelegationDistribution}
     */
    delegation() {
        const ret = wasm.cip36keyregistration_delegation(this.__wbg_ptr);
        return CIP36DelegationDistribution.__wrap(ret);
    }
    /**
     * @returns {PublicKey}
     */
    stake_credential() {
        const ret = wasm.cip36keyregistration_stake_credential(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    payment_address() {
        const ret = wasm.cip36keyregistration_payment_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    nonce() {
        const ret = wasm.cip36keyregistration_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} voting_purpose
     */
    set_voting_purpose(voting_purpose) {
        wasm.cip36keyregistration_set_voting_purpose(this.__wbg_ptr, voting_purpose);
    }
    /**
     * @returns {bigint}
     */
    voting_purpose() {
        const ret = wasm.cip36keyregistration_voting_purpose(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
}

const CIP36RegistrationCborFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36registrationcbor_free(ptr >>> 0, 1));

export class CIP36RegistrationCbor {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36RegistrationCbor.prototype);
        obj.__wbg_ptr = ptr;
        CIP36RegistrationCborFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36RegistrationCborFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36registrationcbor_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36registrationcbor_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36registrationcbor_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36RegistrationCbor}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36registrationcbor_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36RegistrationCbor.__wrap(ret[0]);
    }
    /**
     * @returns {CIP36KeyRegistration}
     */
    key_registration() {
        const ret = wasm.cip36registrationcbor_key_registration(this.__wbg_ptr);
        return CIP36KeyRegistration.__wrap(ret);
    }
    /**
     * @returns {CIP36RegistrationWitness}
     */
    registration_witness() {
        const ret = wasm.cip36registrationcbor_registration_witness(this.__wbg_ptr);
        return CIP36RegistrationWitness.__wrap(ret);
    }
    /**
     * @param {CIP36KeyRegistration} key_registration
     * @param {CIP36RegistrationWitness} registration_witness
     * @returns {CIP36RegistrationCbor}
     */
    static new(key_registration, registration_witness) {
        _assertClass(key_registration, CIP36KeyRegistration);
        _assertClass(registration_witness, CIP36RegistrationWitness);
        const ret = wasm.cip36registrationcbor_new(key_registration.__wbg_ptr, registration_witness.__wbg_ptr);
        return CIP36RegistrationCbor.__wrap(ret);
    }
}

const CIP36RegistrationWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cip36registrationwitness_free(ptr >>> 0, 1));

export class CIP36RegistrationWitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CIP36RegistrationWitness.prototype);
        obj.__wbg_ptr = ptr;
        CIP36RegistrationWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CIP36RegistrationWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cip36registrationwitness_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.cip36registrationwitness_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.cip36registrationwitness_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CIP36RegistrationWitness}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36registrationwitness_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36RegistrationWitness.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36registrationwitness_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.cip36registrationwitness_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CIP36RegistrationWitness}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36registrationwitness_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36RegistrationWitness.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.cip36registrationwitness_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.cip36registrationwitness_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CIP36RegistrationWitness}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.cip36registrationwitness_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CIP36RegistrationWitness.__wrap(ret[0]);
    }
    /**
     * @returns {Ed25519Signature}
     */
    stake_witness() {
        const ret = wasm.cip36registrationwitness_stake_witness(this.__wbg_ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
     * @param {Ed25519Signature} stake_witness
     * @returns {CIP36RegistrationWitness}
     */
    static new(stake_witness) {
        _assertClass(stake_witness, Ed25519Signature);
        const ret = wasm.cip36registrationwitness_new(stake_witness.__wbg_ptr);
        return CIP36RegistrationWitness.__wrap(ret);
    }
}

const CertificateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_certificate_free(ptr >>> 0, 1));

export class Certificate {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Certificate.prototype);
        obj.__wbg_ptr = ptr;
        CertificateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CertificateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificate_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.certificate_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.certificate_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Certificate}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.certificate_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Certificate.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.certificate_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.certificate_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Certificate}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.certificate_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Certificate.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.certificate_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.certificate_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Certificate}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.certificate_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Certificate.__wrap(ret[0]);
    }
    /**
     * Will be deprecated in the next era. Use RegCert instead which takes an explicit deposit amount, as that can change.
     * @param {Credential} stake_credential
     * @returns {Certificate}
     */
    static new_stake_registration(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_stake_registration(stake_credential.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * Will be deprecated in the next era. Use UnregCert instead which takes an explicit deposit amount, as that can change.
     * @param {Credential} stake_credential
     * @returns {Certificate}
     */
    static new_stake_deregistration(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_stake_deregistration(stake_credential.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * Delegate to a take pool only
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @returns {Certificate}
     */
    static new_stake_delegation(stake_credential, pool) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_stake_delegation(stake_credential.__wbg_ptr, pool.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {PoolParams} pool_params
     * @returns {Certificate}
     */
    static new_pool_registration(pool_params) {
        _assertClass(pool_params, PoolParams);
        const ret = wasm.certificate_new_pool_registration(pool_params.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} pool
     * @param {bigint} epoch
     * @returns {Certificate}
     */
    static new_pool_retirement(pool, epoch) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_pool_retirement(pool.__wbg_ptr, epoch);
        return Certificate.__wrap(ret);
    }
    /**
     * Registers a stake credential.
     * @param {Credential} stake_credential
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_reg_cert(stake_credential, deposit) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_reg_cert(stake_credential.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * Unregisters a stake credential.
     * @param {Credential} stake_credential
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_unreg_cert(stake_credential, deposit) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.certificate_new_unreg_cert(stake_credential.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * Delegate to a DRep for voting only
     * @param {Credential} stake_credential
     * @param {DRep} d_rep
     * @returns {Certificate}
     */
    static new_vote_deleg_cert(stake_credential, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_vote_deleg_cert(stake_credential.__wbg_ptr, d_rep.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * Delegate to a stake pool and a DRep
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {DRep} d_rep
     * @returns {Certificate}
     */
    static new_stake_vote_deleg_cert(stake_credential, pool, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_stake_vote_deleg_cert(stake_credential.__wbg_ptr, pool.__wbg_ptr, d_rep.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * Register a stake credential and delegate to a pool in a single cert
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_stake_reg_deleg_cert(stake_credential, pool, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.certificate_new_stake_reg_deleg_cert(stake_credential.__wbg_ptr, pool.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * Register a stake credential and delegate to a DRep in a single cert
     * @param {Credential} stake_credential
     * @param {DRep} d_rep
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_vote_reg_deleg_cert(stake_credential, d_rep, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_vote_reg_deleg_cert(stake_credential.__wbg_ptr, d_rep.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * Register a stake credential and delegate to a pool and a DRep in a single cert
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {DRep} d_rep
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_stake_vote_reg_deleg_cert(stake_credential, pool, d_rep, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.certificate_new_stake_vote_reg_deleg_cert(stake_credential.__wbg_ptr, pool.__wbg_ptr, d_rep.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Credential} committee_cold_credential
     * @param {Credential} committee_hot_credential
     * @returns {Certificate}
     */
    static new_auth_committee_hot_cert(committee_cold_credential, committee_hot_credential) {
        _assertClass(committee_cold_credential, Credential);
        _assertClass(committee_hot_credential, Credential);
        const ret = wasm.certificate_new_auth_committee_hot_cert(committee_cold_credential.__wbg_ptr, committee_hot_credential.__wbg_ptr);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Credential} committee_cold_credential
     * @param {Anchor | null} [anchor]
     * @returns {Certificate}
     */
    static new_resign_committee_cold_cert(committee_cold_credential, anchor) {
        _assertClass(committee_cold_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.certificate_new_resign_committee_cold_cert(committee_cold_credential.__wbg_ptr, ptr0);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {bigint} deposit
     * @param {Anchor | null} [anchor]
     * @returns {Certificate}
     */
    static new_reg_drep_cert(drep_credential, deposit, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.certificate_new_reg_drep_cert(drep_credential.__wbg_ptr, deposit, ptr0);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {bigint} deposit
     * @returns {Certificate}
     */
    static new_unreg_drep_cert(drep_credential, deposit) {
        _assertClass(drep_credential, Credential);
        const ret = wasm.certificate_new_unreg_drep_cert(drep_credential.__wbg_ptr, deposit);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {Anchor | null} [anchor]
     * @returns {Certificate}
     */
    static new_update_drep_cert(drep_credential, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.certificate_new_update_drep_cert(drep_credential.__wbg_ptr, ptr0);
        return Certificate.__wrap(ret);
    }
    /**
     * @returns {CertificateKind}
     */
    kind() {
        const ret = wasm.certificate_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {StakeRegistration | undefined}
     */
    as_stake_registration() {
        const ret = wasm.certificate_as_stake_registration(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);
    }
    /**
     * @returns {StakeDeregistration | undefined}
     */
    as_stake_deregistration() {
        const ret = wasm.certificate_as_stake_deregistration(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);
    }
    /**
     * @returns {StakeDelegation | undefined}
     */
    as_stake_delegation() {
        const ret = wasm.certificate_as_stake_delegation(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);
    }
    /**
     * @returns {PoolRegistration | undefined}
     */
    as_pool_registration() {
        const ret = wasm.certificate_as_pool_registration(this.__wbg_ptr);
        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);
    }
    /**
     * @returns {PoolRetirement | undefined}
     */
    as_pool_retirement() {
        const ret = wasm.certificate_as_pool_retirement(this.__wbg_ptr);
        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);
    }
    /**
     * @returns {RegCert | undefined}
     */
    as_reg_cert() {
        const ret = wasm.certificate_as_reg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : RegCert.__wrap(ret);
    }
    /**
     * @returns {UnregCert | undefined}
     */
    as_unreg_cert() {
        const ret = wasm.certificate_as_unreg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : UnregCert.__wrap(ret);
    }
    /**
     * @returns {VoteDelegCert | undefined}
     */
    as_vote_deleg_cert() {
        const ret = wasm.certificate_as_vote_deleg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : VoteDelegCert.__wrap(ret);
    }
    /**
     * @returns {StakeVoteDelegCert | undefined}
     */
    as_stake_vote_deleg_cert() {
        const ret = wasm.certificate_as_stake_vote_deleg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeVoteDelegCert.__wrap(ret);
    }
    /**
     * @returns {StakeRegDelegCert | undefined}
     */
    as_stake_reg_deleg_cert() {
        const ret = wasm.certificate_as_stake_reg_deleg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeRegDelegCert.__wrap(ret);
    }
    /**
     * @returns {VoteRegDelegCert | undefined}
     */
    as_vote_reg_deleg_cert() {
        const ret = wasm.certificate_as_vote_reg_deleg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : VoteRegDelegCert.__wrap(ret);
    }
    /**
     * @returns {StakeVoteRegDelegCert | undefined}
     */
    as_stake_vote_reg_deleg_cert() {
        const ret = wasm.certificate_as_stake_vote_reg_deleg_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeVoteRegDelegCert.__wrap(ret);
    }
    /**
     * @returns {AuthCommitteeHotCert | undefined}
     */
    as_auth_committee_hot_cert() {
        const ret = wasm.certificate_as_auth_committee_hot_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : AuthCommitteeHotCert.__wrap(ret);
    }
    /**
     * @returns {ResignCommitteeColdCert | undefined}
     */
    as_resign_committee_cold_cert() {
        const ret = wasm.certificate_as_resign_committee_cold_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : ResignCommitteeColdCert.__wrap(ret);
    }
    /**
     * @returns {RegDrepCert | undefined}
     */
    as_reg_drep_cert() {
        const ret = wasm.certificate_as_reg_drep_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : RegDrepCert.__wrap(ret);
    }
    /**
     * @returns {UnregDrepCert | undefined}
     */
    as_unreg_drep_cert() {
        const ret = wasm.certificate_as_unreg_drep_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : UnregDrepCert.__wrap(ret);
    }
    /**
     * @returns {UpdateDrepCert | undefined}
     */
    as_update_drep_cert() {
        const ret = wasm.certificate_as_update_drep_cert(this.__wbg_ptr);
        return ret === 0 ? undefined : UpdateDrepCert.__wrap(ret);
    }
}

const CertificateBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_certificatebuilderresult_free(ptr >>> 0, 1));

export class CertificateBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CertificateBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        CertificateBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CertificateBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificatebuilderresult_free(ptr, 0);
    }
}

const CertificateListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_certificatelist_free(ptr >>> 0, 1));

export class CertificateList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CertificateList.prototype);
        obj.__wbg_ptr = ptr;
        CertificateListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CertificateListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_certificatelist_free(ptr, 0);
    }
    /**
     * @returns {CertificateList}
     */
    static new() {
        const ret = wasm.certificatelist_new();
        return CertificateList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.certificatelist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Certificate}
     */
    get(index) {
        const ret = wasm.certificatelist_get(this.__wbg_ptr, index);
        return Certificate.__wrap(ret);
    }
    /**
     * @param {Certificate} elem
     */
    add(elem) {
        _assertClass(elem, Certificate);
        wasm.certificatelist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const CommitteeColdCredentialListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_committeecoldcredentiallist_free(ptr >>> 0, 1));

export class CommitteeColdCredentialList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CommitteeColdCredentialList.prototype);
        obj.__wbg_ptr = ptr;
        CommitteeColdCredentialListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CommitteeColdCredentialListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_committeecoldcredentiallist_free(ptr, 0);
    }
    /**
     * @returns {CommitteeColdCredentialList}
     */
    static new() {
        const ret = wasm.committeecoldcredentiallist_new();
        return CommitteeColdCredentialList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.committeecoldcredentiallist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Credential}
     */
    get(index) {
        const ret = wasm.committeecoldcredentiallist_get(this.__wbg_ptr, index);
        return Credential.__wrap(ret);
    }
    /**
     * @param {Credential} elem
     */
    add(elem) {
        _assertClass(elem, Credential);
        wasm.committeecoldcredentiallist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const ConstitutionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_constitution_free(ptr >>> 0, 1));

export class Constitution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Constitution.prototype);
        obj.__wbg_ptr = ptr;
        ConstitutionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConstitutionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_constitution_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.constitution_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.constitution_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Constitution}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constitution_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Constitution.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.constitution_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.constitution_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Constitution}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constitution_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Constitution.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.constitution_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.constitution_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Constitution}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constitution_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Constitution.__wrap(ret[0]);
    }
    /**
     * @returns {Anchor}
     */
    anchor() {
        const ret = wasm.constitution_anchor(this.__wbg_ptr);
        return Anchor.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    script_hash() {
        const ret = wasm.constitution_script_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     * @param {Anchor} anchor
     * @param {ScriptHash | null} [script_hash]
     * @returns {Constitution}
     */
    static new(anchor, script_hash) {
        _assertClass(anchor, Anchor);
        let ptr0 = 0;
        if (!isLikeNone(script_hash)) {
            _assertClass(script_hash, ScriptHash);
            ptr0 = script_hash.__destroy_into_raw();
        }
        const ret = wasm.constitution_new(anchor.__wbg_ptr, ptr0);
        return Constitution.__wrap(ret);
    }
}

const ConstrPlutusDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_constrplutusdata_free(ptr >>> 0, 1));

export class ConstrPlutusData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ConstrPlutusData.prototype);
        obj.__wbg_ptr = ptr;
        ConstrPlutusDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConstrPlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_constrplutusdata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.constrplutusdata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.constrplutusdata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ConstrPlutusData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constrplutusdata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConstrPlutusData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.constrplutusdata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.constrplutusdata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ConstrPlutusData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constrplutusdata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConstrPlutusData.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.constrplutusdata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.constrplutusdata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ConstrPlutusData}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.constrplutusdata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConstrPlutusData.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    alternative() {
        const ret = wasm.constrplutusdata_alternative(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {PlutusDataList}
     */
    fields() {
        const ret = wasm.constrplutusdata_fields(this.__wbg_ptr);
        return PlutusDataList.__wrap(ret);
    }
    /**
     * @param {bigint} alternative
     * @param {PlutusDataList} fields
     * @returns {ConstrPlutusData}
     */
    static new(alternative, fields) {
        _assertClass(fields, PlutusDataList);
        const ret = wasm.constrplutusdata_new(alternative, fields.__wbg_ptr);
        return ConstrPlutusData.__wrap(ret);
    }
}

const ConwayFormatAuxDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_conwayformatauxdata_free(ptr >>> 0, 1));

export class ConwayFormatAuxData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ConwayFormatAuxData.prototype);
        obj.__wbg_ptr = ptr;
        ConwayFormatAuxDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConwayFormatAuxDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_conwayformatauxdata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.conwayformatauxdata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.conwayformatauxdata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ConwayFormatAuxData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformatauxdata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatAuxData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.conwayformatauxdata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.conwayformatauxdata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ConwayFormatAuxData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformatauxdata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatAuxData.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.conwayformatauxdata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.conwayformatauxdata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ConwayFormatAuxData}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformatauxdata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatAuxData.__wrap(ret[0]);
    }
    /**
     * @param {Metadata} metadata
     */
    set_metadata(metadata) {
        _assertClass(metadata, Metadata);
        wasm.conwayformatauxdata_set_metadata(this.__wbg_ptr, metadata.__wbg_ptr);
    }
    /**
     * @returns {Metadata | undefined}
     */
    metadata() {
        const ret = wasm.conwayformatauxdata_metadata(this.__wbg_ptr);
        return ret === 0 ? undefined : Metadata.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     */
    set_native_scripts(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        wasm.conwayformatauxdata_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);
    }
    /**
     * @returns {NativeScriptList | undefined}
     */
    native_scripts() {
        const ret = wasm.conwayformatauxdata_native_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusV1ScriptList} plutus_v1_scripts
     */
    set_plutus_v1_scripts(plutus_v1_scripts) {
        _assertClass(plutus_v1_scripts, PlutusV1ScriptList);
        wasm.conwayformatauxdata_set_plutus_v1_scripts(this.__wbg_ptr, plutus_v1_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV1ScriptList | undefined}
     */
    plutus_v1_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v1_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusV2ScriptList} plutus_v2_scripts
     */
    set_plutus_v2_scripts(plutus_v2_scripts) {
        _assertClass(plutus_v2_scripts, PlutusV2ScriptList);
        wasm.conwayformatauxdata_set_plutus_v2_scripts(this.__wbg_ptr, plutus_v2_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV2ScriptList | undefined}
     */
    plutus_v2_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v2_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusV3ScriptList} plutus_v3_scripts
     */
    set_plutus_v3_scripts(plutus_v3_scripts) {
        _assertClass(plutus_v3_scripts, PlutusV3ScriptList);
        wasm.conwayformatauxdata_set_plutus_v3_scripts(this.__wbg_ptr, plutus_v3_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV3ScriptList | undefined}
     */
    plutus_v3_scripts() {
        const ret = wasm.conwayformatauxdata_plutus_v3_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV3ScriptList.__wrap(ret);
    }
    /**
     * @returns {ConwayFormatAuxData}
     */
    static new() {
        const ret = wasm.conwayformatauxdata_new();
        return ConwayFormatAuxData.__wrap(ret);
    }
}

const ConwayFormatTxOutFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_conwayformattxout_free(ptr >>> 0, 1));

export class ConwayFormatTxOut {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ConwayFormatTxOut.prototype);
        obj.__wbg_ptr = ptr;
        ConwayFormatTxOutFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConwayFormatTxOutFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_conwayformattxout_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.conwayformattxout_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.conwayformattxout_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ConwayFormatTxOut}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformattxout_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatTxOut.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.conwayformattxout_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.conwayformattxout_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ConwayFormatTxOut}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformattxout_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatTxOut.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.conwayformattxout_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.conwayformattxout_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ConwayFormatTxOut}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.conwayformattxout_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ConwayFormatTxOut.__wrap(ret[0]);
    }
    /**
     * @returns {Address}
     */
    address() {
        const ret = wasm.conwayformattxout_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @returns {Value}
     */
    amount() {
        const ret = wasm.conwayformattxout_amount(this.__wbg_ptr);
        return Value.__wrap(ret);
    }
    /**
     * @param {DatumOption} datum_option
     */
    set_datum_option(datum_option) {
        _assertClass(datum_option, DatumOption);
        wasm.conwayformattxout_set_datum_option(this.__wbg_ptr, datum_option.__wbg_ptr);
    }
    /**
     * @returns {DatumOption | undefined}
     */
    datum_option() {
        const ret = wasm.conwayformattxout_datum_option(this.__wbg_ptr);
        return ret === 0 ? undefined : DatumOption.__wrap(ret);
    }
    /**
     * @param {Script} script_reference
     */
    set_script_reference(script_reference) {
        _assertClass(script_reference, Script);
        wasm.conwayformattxout_set_script_reference(this.__wbg_ptr, script_reference.__wbg_ptr);
    }
    /**
     * @returns {Script | undefined}
     */
    script_reference() {
        const ret = wasm.conwayformattxout_script_reference(this.__wbg_ptr);
        return ret === 0 ? undefined : Script.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @param {Value} amount
     * @returns {ConwayFormatTxOut}
     */
    static new(address, amount) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        const ret = wasm.conwayformattxout_new(address.__wbg_ptr, amount.__wbg_ptr);
        return ConwayFormatTxOut.__wrap(ret);
    }
}

const CostModelsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_costmodels_free(ptr >>> 0, 1));

export class CostModels {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CostModels.prototype);
        obj.__wbg_ptr = ptr;
        CostModelsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CostModelsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_costmodels_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.costmodels_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.costmodels_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {CostModels}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.costmodels_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CostModels.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.costmodels_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.costmodels_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {CostModels}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.costmodels_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CostModels.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.costmodels_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.costmodels_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {CostModels}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.costmodels_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CostModels.__wrap(ret[0]);
    }
    /**
     * @returns {MapU64ToArrI64}
     */
    inner() {
        const ret = wasm.costmodels_inner(this.__wbg_ptr);
        return MapU64ToArrI64.__wrap(ret);
    }
}

const Crc32Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_crc32_free(ptr >>> 0, 1));

export class Crc32 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Crc32.prototype);
        obj.__wbg_ptr = ptr;
        Crc32Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Crc32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_crc32_free(ptr, 0);
    }
    /**
     * initialise a new CRC32 state
     * @returns {Crc32}
     */
    static new() {
        const ret = wasm.crc32_new();
        return Crc32.__wrap(ret);
    }
    /**
     * update the CRC32 with the given bytes.
     *
     * beware that the order in which you update the Crc32
     * matter
     * @param {Uint8Array} bytes
     */
    update(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.crc32_update(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * finalize the CRC32, recovering the computed value
     * @returns {number}
     */
    finalize() {
        const ret = wasm.crc32_finalize(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const CredentialFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_credential_free(ptr >>> 0, 1));

export class Credential {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Credential.prototype);
        obj.__wbg_ptr = ptr;
        CredentialFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CredentialFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_credential_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.credential_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.credential_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Credential}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.credential_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Credential.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.credential_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.credential_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Credential}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.credential_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Credential.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.credential_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.credential_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Credential}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.credential_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Credential.__wrap(ret[0]);
    }
    /**
     * @param {Ed25519KeyHash} hash
     * @returns {Credential}
     */
    static new_pub_key(hash) {
        _assertClass(hash, Ed25519KeyHash);
        const ret = wasm.credential_new_pub_key(hash.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @param {ScriptHash} hash
     * @returns {Credential}
     */
    static new_script(hash) {
        _assertClass(hash, ScriptHash);
        const ret = wasm.credential_new_script(hash.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {CredentialKind}
     */
    kind() {
        const ret = wasm.credential_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    as_pub_key() {
        const ret = wasm.credential_as_pub_key(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    as_script() {
        const ret = wasm.credential_as_script(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
}

const DNSNameFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_dnsname_free(ptr >>> 0, 1));

export class DNSName {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DNSName.prototype);
        obj.__wbg_ptr = ptr;
        DNSNameFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DNSNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_dnsname_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.dnsname_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.dnsname_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {DNSName}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.dnsname_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DNSName.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.dnsname_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.dnsname_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {DNSName}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.dnsname_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DNSName.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.dnsname_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.dnsname_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {DNSName}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.dnsname_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DNSName.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.dnsname_get(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const DRepFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_drep_free(ptr >>> 0, 1));

export class DRep {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DRep.prototype);
        obj.__wbg_ptr = ptr;
        DRepFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DRepFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_drep_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.drep_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.drep_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {DRep}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drep_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRep.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.drep_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.drep_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {DRep}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drep_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRep.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.drep_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.drep_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {DRep}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drep_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRep.__wrap(ret[0]);
    }
    /**
     * @param {Ed25519KeyHash} pool
     * @returns {DRep}
     */
    static new_key(pool) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.drep_new_key(pool.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @param {ScriptHash} script_hash
     * @returns {DRep}
     */
    static new_script(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.drep_new_script(script_hash.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    static new_always_abstain() {
        const ret = wasm.drep_new_always_abstain();
        return DRep.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    static new_always_no_confidence() {
        const ret = wasm.drep_new_always_no_confidence();
        return DRep.__wrap(ret);
    }
    /**
     * @returns {DRepKind}
     */
    kind() {
        const ret = wasm.drep_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    as_key() {
        const ret = wasm.drep_as_key(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    as_script() {
        const ret = wasm.drep_as_script(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
}

const DRepVotingThresholdsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_drepvotingthresholds_free(ptr >>> 0, 1));

export class DRepVotingThresholds {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DRepVotingThresholds.prototype);
        obj.__wbg_ptr = ptr;
        DRepVotingThresholdsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DRepVotingThresholdsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_drepvotingthresholds_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.drepvotingthresholds_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.drepvotingthresholds_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {DRepVotingThresholds}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drepvotingthresholds_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRepVotingThresholds.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.drepvotingthresholds_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.drepvotingthresholds_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {DRepVotingThresholds}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drepvotingthresholds_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRepVotingThresholds.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.drepvotingthresholds_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.drepvotingthresholds_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {DRepVotingThresholds}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.drepvotingthresholds_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DRepVotingThresholds.__wrap(ret[0]);
    }
    /**
     * @returns {UnitInterval}
     */
    motion_no_confidence() {
        const ret = wasm.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    committee_normal() {
        const ret = wasm.drepvotingthresholds_committee_normal(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    committee_no_confidence() {
        const ret = wasm.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    update_constitution() {
        const ret = wasm.drepvotingthresholds_update_constitution(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    hard_fork_initiation() {
        const ret = wasm.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    pp_network_group() {
        const ret = wasm.drepvotingthresholds_pp_network_group(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    pp_economic_group() {
        const ret = wasm.drepvotingthresholds_pp_economic_group(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    pp_technical_group() {
        const ret = wasm.drepvotingthresholds_pp_technical_group(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    pp_governance_group() {
        const ret = wasm.drepvotingthresholds_pp_governance_group(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    treasury_withdrawal() {
        const ret = wasm.drepvotingthresholds_treasury_withdrawal(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @param {UnitInterval} motion_no_confidence
     * @param {UnitInterval} committee_normal
     * @param {UnitInterval} committee_no_confidence
     * @param {UnitInterval} update_constitution
     * @param {UnitInterval} hard_fork_initiation
     * @param {UnitInterval} pp_network_group
     * @param {UnitInterval} pp_economic_group
     * @param {UnitInterval} pp_technical_group
     * @param {UnitInterval} pp_governance_group
     * @param {UnitInterval} treasury_withdrawal
     * @returns {DRepVotingThresholds}
     */
    static new(motion_no_confidence, committee_normal, committee_no_confidence, update_constitution, hard_fork_initiation, pp_network_group, pp_economic_group, pp_technical_group, pp_governance_group, treasury_withdrawal) {
        _assertClass(motion_no_confidence, UnitInterval);
        _assertClass(committee_normal, UnitInterval);
        _assertClass(committee_no_confidence, UnitInterval);
        _assertClass(update_constitution, UnitInterval);
        _assertClass(hard_fork_initiation, UnitInterval);
        _assertClass(pp_network_group, UnitInterval);
        _assertClass(pp_economic_group, UnitInterval);
        _assertClass(pp_technical_group, UnitInterval);
        _assertClass(pp_governance_group, UnitInterval);
        _assertClass(treasury_withdrawal, UnitInterval);
        const ret = wasm.drepvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, update_constitution.__wbg_ptr, hard_fork_initiation.__wbg_ptr, pp_network_group.__wbg_ptr, pp_economic_group.__wbg_ptr, pp_technical_group.__wbg_ptr, pp_governance_group.__wbg_ptr, treasury_withdrawal.__wbg_ptr);
        return DRepVotingThresholds.__wrap(ret);
    }
}

const DatumHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_datumhash_free(ptr >>> 0, 1));

export class DatumHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DatumHash.prototype);
        obj.__wbg_ptr = ptr;
        DatumHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DatumHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datumhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.datumhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {DatumHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.datumhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {DatumHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datumhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {DatumHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumHash.__wrap(ret[0]);
    }
}

const DatumOptionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_datumoption_free(ptr >>> 0, 1));

export class DatumOption {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(DatumOption.prototype);
        obj.__wbg_ptr = ptr;
        DatumOptionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DatumOptionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_datumoption_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.datumoption_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.datumoption_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {DatumOption}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumoption_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumOption.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datumoption_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.datumoption_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {DatumOption}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumoption_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumOption.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.datumoption_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.datumoption_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {DatumOption}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.datumoption_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return DatumOption.__wrap(ret[0]);
    }
    /**
     * @param {DatumHash} datum_hash
     * @returns {DatumOption}
     */
    static new_hash(datum_hash) {
        _assertClass(datum_hash, DatumHash);
        const ret = wasm.datumoption_new_hash(datum_hash.__wbg_ptr);
        return DatumOption.__wrap(ret);
    }
    /**
     * @param {PlutusData} datum
     * @returns {DatumOption}
     */
    static new_datum(datum) {
        _assertClass(datum, PlutusData);
        const ret = wasm.datumoption_new_datum(datum.__wbg_ptr);
        return DatumOption.__wrap(ret);
    }
    /**
     * @returns {DatumOptionKind}
     */
    kind() {
        const ret = wasm.datumoption_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {DatumHash | undefined}
     */
    as_hash() {
        const ret = wasm.datumoption_as_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
     * @returns {PlutusData | undefined}
     */
    as_datum() {
        const ret = wasm.datumoption_as_datum(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const Ed25519KeyHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ed25519keyhash_free(ptr >>> 0, 1));

export class Ed25519KeyHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Ed25519KeyHash.prototype);
        obj.__wbg_ptr = ptr;
        Ed25519KeyHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Ed25519KeyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519keyhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.ed25519keyhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {Ed25519KeyHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519keyhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519KeyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.ed25519keyhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {Ed25519KeyHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519keyhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519KeyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ed25519keyhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {Ed25519KeyHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519keyhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519KeyHash.__wrap(ret[0]);
    }
}

const Ed25519KeyHashListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ed25519keyhashlist_free(ptr >>> 0, 1));

export class Ed25519KeyHashList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Ed25519KeyHashList.prototype);
        obj.__wbg_ptr = ptr;
        Ed25519KeyHashListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Ed25519KeyHashListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519keyhashlist_free(ptr, 0);
    }
    /**
     * @returns {Ed25519KeyHashList}
     */
    static new() {
        const ret = wasm.ed25519keyhashlist_new();
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.ed25519keyhashlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Ed25519KeyHash}
     */
    get(index) {
        const ret = wasm.ed25519keyhashlist_get(this.__wbg_ptr, index);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} elem
     */
    add(elem) {
        _assertClass(elem, Ed25519KeyHash);
        wasm.ed25519keyhashlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const Ed25519SignatureFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ed25519signature_free(ptr >>> 0, 1));

export class Ed25519Signature {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Ed25519Signature.prototype);
        obj.__wbg_ptr = ptr;
        Ed25519SignatureFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Ed25519SignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519signature_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_bech32() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ed25519signature_to_bech32(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {Ed25519Signature}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519signature_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519Signature.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.ed25519signature_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {Ed25519Signature}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519signature_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519Signature.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ed25519signature_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {Ed25519Signature}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ed25519signature_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ed25519Signature.__wrap(ret[0]);
    }
}

const EnterpriseAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_enterpriseaddress_free(ptr >>> 0, 1));

export class EnterpriseAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EnterpriseAddress.prototype);
        obj.__wbg_ptr = ptr;
        EnterpriseAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EnterpriseAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_enterpriseaddress_free(ptr, 0);
    }
    /**
     * @param {number} network
     * @param {Credential} payment
     * @returns {EnterpriseAddress}
     */
    static new(network, payment) {
        _assertClass(payment, Credential);
        const ret = wasm.enterpriseaddress_new(network, payment.__wbg_ptr);
        return EnterpriseAddress.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    to_address() {
        const ret = wasm.enterpriseaddress_to_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @returns {EnterpriseAddress | undefined}
     */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.enterpriseaddress_from_address(address.__wbg_ptr);
        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.enterpriseaddress_network_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Credential}
     */
    payment() {
        const ret = wasm.enterpriseaddress_payment(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
}

const ExUnitPricesFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_exunitprices_free(ptr >>> 0, 1));

export class ExUnitPrices {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ExUnitPrices.prototype);
        obj.__wbg_ptr = ptr;
        ExUnitPricesFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ExUnitPricesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_exunitprices_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.exunitprices_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.exunitprices_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ExUnitPrices}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunitprices_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnitPrices.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.exunitprices_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.exunitprices_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ExUnitPrices}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunitprices_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnitPrices.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.exunitprices_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.exunitprices_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ExUnitPrices}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunitprices_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnitPrices.__wrap(ret[0]);
    }
    /**
     * @returns {Rational}
     */
    mem_price() {
        const ret = wasm.exunitprices_mem_price(this.__wbg_ptr);
        return Rational.__wrap(ret);
    }
    /**
     * @returns {Rational}
     */
    step_price() {
        const ret = wasm.exunitprices_step_price(this.__wbg_ptr);
        return Rational.__wrap(ret);
    }
    /**
     * @param {Rational} mem_price
     * @param {Rational} step_price
     * @returns {ExUnitPrices}
     */
    static new(mem_price, step_price) {
        _assertClass(mem_price, Rational);
        _assertClass(step_price, Rational);
        const ret = wasm.exunitprices_new(mem_price.__wbg_ptr, step_price.__wbg_ptr);
        return ExUnitPrices.__wrap(ret);
    }
}

const ExUnitsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_exunits_free(ptr >>> 0, 1));

export class ExUnits {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ExUnits.prototype);
        obj.__wbg_ptr = ptr;
        ExUnitsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ExUnitsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_exunits_free(ptr, 0);
    }
    /**
     * @param {ExUnits} other
     * @returns {ExUnits}
     */
    checked_add(other) {
        _assertClass(other, ExUnits);
        const ret = wasm.exunits_checked_add(this.__wbg_ptr, other.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnits.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.exunits_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.exunits_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ExUnits}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunits_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnits.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.exunits_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.exunits_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ExUnits}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunits_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnits.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.exunits_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.exunits_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ExUnits}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.exunits_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ExUnits.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    mem() {
        const ret = wasm.exunits_mem(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    steps() {
        const ret = wasm.exunits_steps(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} mem
     * @param {bigint} steps
     * @returns {ExUnits}
     */
    static new(mem, steps) {
        const ret = wasm.exunits_new(mem, steps);
        return ExUnits.__wrap(ret);
    }
}

const FilesDetailsListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filesdetailslist_free(ptr >>> 0, 1));

export class FilesDetailsList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FilesDetailsList.prototype);
        obj.__wbg_ptr = ptr;
        FilesDetailsListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FilesDetailsListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filesdetailslist_free(ptr, 0);
    }
    /**
     * @returns {FilesDetailsList}
     */
    static new() {
        const ret = wasm.filesdetailslist_new();
        return FilesDetailsList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.filesdetailslist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {CIP25FilesDetails}
     */
    get(index) {
        const ret = wasm.filesdetailslist_get(this.__wbg_ptr, index);
        return CIP25FilesDetails.__wrap(ret);
    }
    /**
     * @param {CIP25FilesDetails} elem
     */
    add(elem) {
        _assertClass(elem, CIP25FilesDetails);
        wasm.filesdetailslist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const GenesisDelegateHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_genesisdelegatehash_free(ptr >>> 0, 1));

export class GenesisDelegateHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GenesisDelegateHash.prototype);
        obj.__wbg_ptr = ptr;
        GenesisDelegateHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GenesisDelegateHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_genesisdelegatehash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.genesisdelegatehash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {GenesisDelegateHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesisdelegatehash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisDelegateHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.genesisdelegatehash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {GenesisDelegateHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesisdelegatehash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisDelegateHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.genesisdelegatehash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {GenesisDelegateHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesisdelegatehash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisDelegateHash.__wrap(ret[0]);
    }
}

const GenesisHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_genesishash_free(ptr >>> 0, 1));

export class GenesisHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GenesisHash.prototype);
        obj.__wbg_ptr = ptr;
        GenesisHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GenesisHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_genesishash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.genesishash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {GenesisHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesishash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.genesishash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {GenesisHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesishash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.genesishash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {GenesisHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.genesishash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GenesisHash.__wrap(ret[0]);
    }
}

const GovActionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_govaction_free(ptr >>> 0, 1));

export class GovAction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GovAction.prototype);
        obj.__wbg_ptr = ptr;
        GovActionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GovActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govaction_free(ptr, 0);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    script_hash() {
        const ret = wasm.govaction_script_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.govaction_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.govaction_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {GovAction}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govaction_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovAction.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.govaction_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.govaction_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {GovAction}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govaction_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovAction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.govaction_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.govaction_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {GovAction}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govaction_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovAction.__wrap(ret[0]);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {ProtocolParamUpdate} update
     * @param {ScriptHash | null} [policy_hash]
     * @returns {GovAction}
     */
    static new_parameter_change_action(action_id, update, policy_hash) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(update, ProtocolParamUpdate);
        let ptr1 = 0;
        if (!isLikeNone(policy_hash)) {
            _assertClass(policy_hash, ScriptHash);
            ptr1 = policy_hash.__destroy_into_raw();
        }
        const ret = wasm.govaction_new_parameter_change_action(ptr0, update.__wbg_ptr, ptr1);
        return GovAction.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {ProtocolVersion} version
     * @returns {GovAction}
     */
    static new_hard_fork_initiation_action(action_id, version) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(version, ProtocolVersion);
        const ret = wasm.govaction_new_hard_fork_initiation_action(ptr0, version.__wbg_ptr);
        return GovAction.__wrap(ret);
    }
    /**
     * @param {MapRewardAccountToCoin} withdrawal
     * @param {ScriptHash | null} [policy_hash]
     * @returns {GovAction}
     */
    static new_treasury_withdrawals_action(withdrawal, policy_hash) {
        _assertClass(withdrawal, MapRewardAccountToCoin);
        let ptr0 = 0;
        if (!isLikeNone(policy_hash)) {
            _assertClass(policy_hash, ScriptHash);
            ptr0 = policy_hash.__destroy_into_raw();
        }
        const ret = wasm.govaction_new_treasury_withdrawals_action(withdrawal.__wbg_ptr, ptr0);
        return GovAction.__wrap(ret);
    }
    /**
     * @param {GovActionId | null} [action_id]
     * @returns {GovAction}
     */
    static new_no_confidence(action_id) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        const ret = wasm.govaction_new_no_confidence(ptr0);
        return GovAction.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {CommitteeColdCredentialList} cold_credentials
     * @param {MapCommitteeColdCredentialToEpoch} credentials
     * @param {UnitInterval} unit_interval
     * @returns {GovAction}
     */
    static new_update_committee(action_id, cold_credentials, credentials, unit_interval) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(cold_credentials, CommitteeColdCredentialList);
        _assertClass(credentials, MapCommitteeColdCredentialToEpoch);
        _assertClass(unit_interval, UnitInterval);
        const ret = wasm.govaction_new_update_committee(ptr0, cold_credentials.__wbg_ptr, credentials.__wbg_ptr, unit_interval.__wbg_ptr);
        return GovAction.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {Constitution} constitution
     * @returns {GovAction}
     */
    static new_new_constitution(action_id, constitution) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(constitution, Constitution);
        const ret = wasm.govaction_new_new_constitution(ptr0, constitution.__wbg_ptr);
        return GovAction.__wrap(ret);
    }
    /**
     * @returns {GovAction}
     */
    static new_info_action() {
        const ret = wasm.govaction_new_info_action();
        return GovAction.__wrap(ret);
    }
    /**
     * @returns {GovActionKind}
     */
    kind() {
        const ret = wasm.govaction_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ParameterChangeAction | undefined}
     */
    as_parameter_change_action() {
        const ret = wasm.govaction_as_parameter_change_action(this.__wbg_ptr);
        return ret === 0 ? undefined : ParameterChangeAction.__wrap(ret);
    }
    /**
     * @returns {HardForkInitiationAction | undefined}
     */
    as_hard_fork_initiation_action() {
        const ret = wasm.govaction_as_hard_fork_initiation_action(this.__wbg_ptr);
        return ret === 0 ? undefined : HardForkInitiationAction.__wrap(ret);
    }
    /**
     * @returns {TreasuryWithdrawalsAction | undefined}
     */
    as_treasury_withdrawals_action() {
        const ret = wasm.govaction_as_treasury_withdrawals_action(this.__wbg_ptr);
        return ret === 0 ? undefined : TreasuryWithdrawalsAction.__wrap(ret);
    }
    /**
     * @returns {NoConfidence | undefined}
     */
    as_no_confidence() {
        const ret = wasm.govaction_as_no_confidence(this.__wbg_ptr);
        return ret === 0 ? undefined : NoConfidence.__wrap(ret);
    }
    /**
     * @returns {UpdateCommittee | undefined}
     */
    as_update_committee() {
        const ret = wasm.govaction_as_update_committee(this.__wbg_ptr);
        return ret === 0 ? undefined : UpdateCommittee.__wrap(ret);
    }
    /**
     * @returns {NewConstitution | undefined}
     */
    as_new_constitution() {
        const ret = wasm.govaction_as_new_constitution(this.__wbg_ptr);
        return ret === 0 ? undefined : NewConstitution.__wrap(ret);
    }
}

const GovActionIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_govactionid_free(ptr >>> 0, 1));

export class GovActionId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GovActionId.prototype);
        obj.__wbg_ptr = ptr;
        GovActionIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GovActionIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govactionid_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.govactionid_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.govactionid_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {GovActionId}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govactionid_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovActionId.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.govactionid_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.govactionid_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {GovActionId}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govactionid_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovActionId.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.govactionid_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.govactionid_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {GovActionId}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.govactionid_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return GovActionId.__wrap(ret[0]);
    }
    /**
     * @returns {TransactionHash}
     */
    transaction_id() {
        const ret = wasm.govactionid_transaction_id(this.__wbg_ptr);
        return TransactionHash.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    gov_action_index() {
        const ret = wasm.govactionid_gov_action_index(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {TransactionHash} transaction_id
     * @param {bigint} gov_action_index
     * @returns {GovActionId}
     */
    static new(transaction_id, gov_action_index) {
        _assertClass(transaction_id, TransactionHash);
        const ret = wasm.govactionid_new(transaction_id.__wbg_ptr, gov_action_index);
        return GovActionId.__wrap(ret);
    }
}

const GovActionIdListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_govactionidlist_free(ptr >>> 0, 1));

export class GovActionIdList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GovActionIdList.prototype);
        obj.__wbg_ptr = ptr;
        GovActionIdListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GovActionIdListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_govactionidlist_free(ptr, 0);
    }
    /**
     * @returns {GovActionIdList}
     */
    static new() {
        const ret = wasm.govactionidlist_new();
        return GovActionIdList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.govactionidlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {GovActionId}
     */
    get(index) {
        const ret = wasm.govactionidlist_get(this.__wbg_ptr, index);
        return GovActionId.__wrap(ret);
    }
    /**
     * @param {GovActionId} elem
     */
    add(elem) {
        _assertClass(elem, GovActionId);
        wasm.govactionidlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const HDAddressPayloadFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_hdaddresspayload_free(ptr >>> 0, 1));

export class HDAddressPayload {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(HDAddressPayload.prototype);
        obj.__wbg_ptr = ptr;
        HDAddressPayloadFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HDAddressPayloadFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_hdaddresspayload_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.hdaddresspayload_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {HDAddressPayload}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hdaddresspayload_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HDAddressPayload.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.hdaddresspayload_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {HDAddressPayload}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hdaddresspayload_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HDAddressPayload.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get() {
        const ret = wasm.hdaddresspayload_get(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const HardForkInitiationActionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_hardforkinitiationaction_free(ptr >>> 0, 1));

export class HardForkInitiationAction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(HardForkInitiationAction.prototype);
        obj.__wbg_ptr = ptr;
        HardForkInitiationActionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HardForkInitiationActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_hardforkinitiationaction_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.hardforkinitiationaction_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.hardforkinitiationaction_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {HardForkInitiationAction}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hardforkinitiationaction_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HardForkInitiationAction.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.hardforkinitiationaction_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.hardforkinitiationaction_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {HardForkInitiationAction}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hardforkinitiationaction_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HardForkInitiationAction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.hardforkinitiationaction_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.hardforkinitiationaction_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {HardForkInitiationAction}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hardforkinitiationaction_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HardForkInitiationAction.__wrap(ret[0]);
    }
    /**
     * @returns {GovActionId | undefined}
     */
    action_id() {
        const ret = wasm.hardforkinitiationaction_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
     * @returns {ProtocolVersion}
     */
    version() {
        const ret = wasm.hardforkinitiationaction_version(this.__wbg_ptr);
        return ProtocolVersion.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {ProtocolVersion} version
     * @returns {HardForkInitiationAction}
     */
    static new(action_id, version) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(version, ProtocolVersion);
        const ret = wasm.hardforkinitiationaction_new(ptr0, version.__wbg_ptr);
        return HardForkInitiationAction.__wrap(ret);
    }
}

const HeaderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_header_free(ptr >>> 0, 1));

export class Header {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Header.prototype);
        obj.__wbg_ptr = ptr;
        HeaderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HeaderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_header_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.header_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.header_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Header}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.header_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Header.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.header_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.header_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Header}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.header_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Header.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.header_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.header_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Header}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.header_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Header.__wrap(ret[0]);
    }
    /**
     * @returns {HeaderBody}
     */
    header_body() {
        const ret = wasm.header_header_body(this.__wbg_ptr);
        return HeaderBody.__wrap(ret);
    }
    /**
     * @returns {KESSignature}
     */
    body_signature() {
        const ret = wasm.header_body_signature(this.__wbg_ptr);
        return KESSignature.__wrap(ret);
    }
    /**
     * @param {HeaderBody} header_body
     * @param {KESSignature} body_signature
     * @returns {Header}
     */
    static new(header_body, body_signature) {
        _assertClass(header_body, HeaderBody);
        _assertClass(body_signature, KESSignature);
        const ret = wasm.header_new(header_body.__wbg_ptr, body_signature.__wbg_ptr);
        return Header.__wrap(ret);
    }
}

const HeaderBodyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_headerbody_free(ptr >>> 0, 1));

export class HeaderBody {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(HeaderBody.prototype);
        obj.__wbg_ptr = ptr;
        HeaderBodyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HeaderBodyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_headerbody_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.headerbody_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.headerbody_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {HeaderBody}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.headerbody_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HeaderBody.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.headerbody_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.headerbody_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {HeaderBody}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.headerbody_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HeaderBody.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.headerbody_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.headerbody_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {HeaderBody}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.headerbody_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return HeaderBody.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    block_number() {
        const ret = wasm.headerbody_block_number(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    slot() {
        const ret = wasm.headerbody_slot(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {BlockHeaderHash | undefined}
     */
    prev_hash() {
        const ret = wasm.headerbody_prev_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : BlockHeaderHash.__wrap(ret);
    }
    /**
     * @returns {PublicKey}
     */
    issuer_vkey() {
        const ret = wasm.headerbody_issuer_vkey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {VRFVkey}
     */
    vrf_vkey() {
        const ret = wasm.headerbody_vrf_vkey(this.__wbg_ptr);
        return VRFVkey.__wrap(ret);
    }
    /**
     * @returns {VRFCert}
     */
    vrf_result() {
        const ret = wasm.headerbody_vrf_result(this.__wbg_ptr);
        return VRFCert.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    block_body_size() {
        const ret = wasm.headerbody_block_body_size(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {BlockBodyHash}
     */
    block_body_hash() {
        const ret = wasm.headerbody_block_body_hash(this.__wbg_ptr);
        return BlockBodyHash.__wrap(ret);
    }
    /**
     * @returns {OperationalCert}
     */
    operational_cert() {
        const ret = wasm.headerbody_operational_cert(this.__wbg_ptr);
        return OperationalCert.__wrap(ret);
    }
    /**
     * @returns {ProtocolVersion}
     */
    protocol_version() {
        const ret = wasm.headerbody_protocol_version(this.__wbg_ptr);
        return ProtocolVersion.__wrap(ret);
    }
    /**
     * @param {bigint} block_number
     * @param {bigint} slot
     * @param {BlockHeaderHash | null | undefined} prev_hash
     * @param {PublicKey} issuer_vkey
     * @param {VRFVkey} vrf_vkey
     * @param {VRFCert} vrf_result
     * @param {bigint} block_body_size
     * @param {BlockBodyHash} block_body_hash
     * @param {OperationalCert} operational_cert
     * @param {ProtocolVersion} protocol_version
     * @returns {HeaderBody}
     */
    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, vrf_result, block_body_size, block_body_hash, operational_cert, protocol_version) {
        let ptr0 = 0;
        if (!isLikeNone(prev_hash)) {
            _assertClass(prev_hash, BlockHeaderHash);
            ptr0 = prev_hash.__destroy_into_raw();
        }
        _assertClass(issuer_vkey, PublicKey);
        _assertClass(vrf_vkey, VRFVkey);
        _assertClass(vrf_result, VRFCert);
        _assertClass(block_body_hash, BlockBodyHash);
        _assertClass(operational_cert, OperationalCert);
        _assertClass(protocol_version, ProtocolVersion);
        const ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.__wbg_ptr, vrf_vkey.__wbg_ptr, vrf_result.__wbg_ptr, block_body_size, block_body_hash.__wbg_ptr, operational_cert.__wbg_ptr, protocol_version.__wbg_ptr);
        return HeaderBody.__wrap(ret);
    }
}

const InputAggregateWitnessDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_inputaggregatewitnessdata_free(ptr >>> 0, 1));

export class InputAggregateWitnessData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InputAggregateWitnessDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_inputaggregatewitnessdata_free(ptr, 0);
    }
    /**
     * @returns {PlutusData | undefined}
     */
    plutus_data() {
        const ret = wasm.inputaggregatewitnessdata_plutus_data(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const InputBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_inputbuilderresult_free(ptr >>> 0, 1));

export class InputBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(InputBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        InputBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InputBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_inputbuilderresult_free(ptr, 0);
    }
}

const IntFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_int_free(ptr >>> 0, 1));

export class Int {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Int.prototype);
        obj.__wbg_ptr = ptr;
        IntFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_int_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.int_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} cbor_bytes
     * @returns {Int}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.int_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Int.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.int_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_json_value() {
        const ret = wasm.int_to_json_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Int}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.int_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Int.__wrap(ret[0]);
    }
    /**
     * @param {bigint} x
     * @returns {Int}
     */
    static new(x) {
        const ret = wasm.int_new(x);
        return Int.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    to_str() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.int_to_str(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} string
     * @returns {Int}
     */
    static from_str(string) {
        const ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.int_from_str(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Int.__wrap(ret[0]);
    }
}

const IntListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_intlist_free(ptr >>> 0, 1));

export class IntList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(IntList.prototype);
        obj.__wbg_ptr = ptr;
        IntListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        IntListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_intlist_free(ptr, 0);
    }
    /**
     * @returns {IntList}
     */
    static new() {
        const ret = wasm.intlist_new();
        return IntList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.intlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Int}
     */
    get(index) {
        const ret = wasm.intlist_get(this.__wbg_ptr, index);
        return Int.__wrap(ret);
    }
    /**
     * @param {Int} elem
     */
    add(elem) {
        _assertClass(elem, Int);
        wasm.intlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const Ipv4Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ipv4_free(ptr >>> 0, 1));

export class Ipv4 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Ipv4.prototype);
        obj.__wbg_ptr = ptr;
        Ipv4Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Ipv4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ipv4_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.ipv4_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.ipv4_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Ipv4}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv4_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv4.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ipv4_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ipv4_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Ipv4}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv4_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv4.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.ipv4_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.ipv4_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Ipv4}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv4_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv4.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get() {
        const ret = wasm.ipv4_get(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const Ipv6Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ipv6_free(ptr >>> 0, 1));

export class Ipv6 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Ipv6.prototype);
        obj.__wbg_ptr = ptr;
        Ipv6Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Ipv6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ipv6_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.ipv6_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.ipv6_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Ipv6}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv6_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv6.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ipv6_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.ipv6_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Ipv6}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv6_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv6.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.ipv6_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.ipv6_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Ipv6}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.ipv6_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Ipv6.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get() {
        const ret = wasm.ipv6_get(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const KESSignatureFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_kessignature_free(ptr >>> 0, 1));

export class KESSignature {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KESSignature.prototype);
        obj.__wbg_ptr = ptr;
        KESSignatureFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KESSignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kessignature_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.kessignature_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.kessignature_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {KESSignature}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kessignature_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESSignature.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.kessignature_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.kessignature_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {KESSignature}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kessignature_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESSignature.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.kessignature_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.kessignature_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {KESSignature}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kessignature_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESSignature.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    get() {
        const ret = wasm.kessignature_get(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const KESVkeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_kesvkey_free(ptr >>> 0, 1));

export class KESVkey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KESVkey.prototype);
        obj.__wbg_ptr = ptr;
        KESVkeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KESVkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kesvkey_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.kesvkey_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {KESVkey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kesvkey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESVkey.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.kesvkey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {KESVkey}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kesvkey_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESVkey.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.kesvkey_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {KESVkey}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.kesvkey_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return KESVkey.__wrap(ret[0]);
    }
}

const LanguageListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_languagelist_free(ptr >>> 0, 1));

export class LanguageList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LanguageList.prototype);
        obj.__wbg_ptr = ptr;
        LanguageListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LanguageListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_languagelist_free(ptr, 0);
    }
    /**
     * @returns {LanguageList}
     */
    static new() {
        const ret = wasm.languagelist_new();
        return LanguageList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.languagelist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Language}
     */
    get(index) {
        const ret = wasm.languagelist_get(this.__wbg_ptr, index);
        return ret;
    }
    /**
     * @param {Language} elem
     */
    add(elem) {
        wasm.languagelist_add(this.__wbg_ptr, elem);
    }
}

const LegacyDaedalusPrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_legacydaedalusprivatekey_free(ptr >>> 0, 1));

export class LegacyDaedalusPrivateKey {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LegacyDaedalusPrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_legacydaedalusprivatekey_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array}
     */
    chaincode() {
        const ret = wasm.legacydaedalusprivatekey_chaincode(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
}

const LegacyRedeemerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_legacyredeemer_free(ptr >>> 0, 1));

export class LegacyRedeemer {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LegacyRedeemer.prototype);
        obj.__wbg_ptr = ptr;
        LegacyRedeemerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LegacyRedeemerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_legacyredeemer_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.legacyredeemer_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.legacyredeemer_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {LegacyRedeemer}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.legacyredeemer_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return LegacyRedeemer.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.legacyredeemer_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.legacyredeemer_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {LegacyRedeemer}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.legacyredeemer_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return LegacyRedeemer.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.legacyredeemer_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.legacyredeemer_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {LegacyRedeemer}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.legacyredeemer_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return LegacyRedeemer.__wrap(ret[0]);
    }
    /**
     * @returns {RedeemerTag}
     */
    tag() {
        const ret = wasm.legacyredeemer_tag(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    index() {
        const ret = wasm.legacyredeemer_index(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {PlutusData}
     */
    data() {
        const ret = wasm.legacyredeemer_data(this.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @returns {ExUnits}
     */
    ex_units() {
        const ret = wasm.legacyredeemer_ex_units(this.__wbg_ptr);
        return ExUnits.__wrap(ret);
    }
    /**
     * @param {RedeemerTag} tag
     * @param {bigint} index
     * @param {PlutusData} data
     * @param {ExUnits} ex_units
     * @returns {LegacyRedeemer}
     */
    static new(tag, index, data, ex_units) {
        _assertClass(data, PlutusData);
        _assertClass(ex_units, ExUnits);
        const ret = wasm.legacyredeemer_new(tag, index, data.__wbg_ptr, ex_units.__wbg_ptr);
        return LegacyRedeemer.__wrap(ret);
    }
}

const LegacyRedeemerListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_legacyredeemerlist_free(ptr >>> 0, 1));

export class LegacyRedeemerList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LegacyRedeemerList.prototype);
        obj.__wbg_ptr = ptr;
        LegacyRedeemerListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LegacyRedeemerListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_legacyredeemerlist_free(ptr, 0);
    }
    /**
     * @returns {LegacyRedeemerList}
     */
    static new() {
        const ret = wasm.legacyredeemerlist_new();
        return LegacyRedeemerList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.legacyredeemerlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {LegacyRedeemer}
     */
    get(index) {
        const ret = wasm.legacyredeemerlist_get(this.__wbg_ptr, index);
        return LegacyRedeemer.__wrap(ret);
    }
    /**
     * @param {LegacyRedeemer} elem
     */
    add(elem) {
        _assertClass(elem, LegacyRedeemer);
        wasm.legacyredeemerlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const LinearFeeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_linearfee_free(ptr >>> 0, 1));
/**
 * Careful: although the linear fee is the same for Byron & Shelley
 * The value of the parameters and how fees are computed is not the same
 */
export class LinearFee {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LinearFee.prototype);
        obj.__wbg_ptr = ptr;
        LinearFeeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LinearFeeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_linearfee_free(ptr, 0);
    }
    /**
     *
     *     * * `coefficient` - minfee_a from protocol params
     *     * * `constant` - minfee_b from protocol params
     *     * * `ref_script_cost_per_bytes` - min_fee_ref_script_cost_per_byte from protocol params. New in Conway
     *
     * @param {bigint} coefficient
     * @param {bigint} constant
     * @param {bigint} ref_script_cost_per_byte
     * @returns {LinearFee}
     */
    static new(coefficient, constant, ref_script_cost_per_byte) {
        const ret = wasm.linearfee_new(coefficient, constant, ref_script_cost_per_byte);
        return LinearFee.__wrap(ret);
    }
    /**
     * minfee_a
     * @returns {bigint}
     */
    coefficient() {
        const ret = wasm.linearfee_coefficient(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * minfee_b
     * @returns {bigint}
     */
    constant() {
        const ret = wasm.linearfee_constant(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    ref_script_cost_per_byte() {
        const ret = wasm.linearfee_ref_script_cost_per_byte(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
}

const MapAssetNameToCoinFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametocoin_free(ptr >>> 0, 1));

export class MapAssetNameToCoin {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapAssetNameToCoin.prototype);
        obj.__wbg_ptr = ptr;
        MapAssetNameToCoinFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapAssetNameToCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametocoin_free(ptr, 0);
    }
    /**
     * @param {AssetName} key
     * @returns {bigint | undefined}
     */
    get(key) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametocoin_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {AssetName} key
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    insert(key, value) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametocoin_insert(this.__wbg_ptr, key.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {MapAssetNameToCoin}
     */
    static new() {
        const ret = wasm.mapassetnametocoin_new();
        return MapAssetNameToCoin.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapassetnametocoin_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm.mapassetnametocoin_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {AssetNameList}
     */
    keys() {
        const ret = wasm.mapassetnametocoin_keys(this.__wbg_ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapAssetNameToNonZeroInt64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametononzeroint64_free(ptr >>> 0, 1));

export class MapAssetNameToNonZeroInt64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapAssetNameToNonZeroInt64.prototype);
        obj.__wbg_ptr = ptr;
        MapAssetNameToNonZeroInt64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapAssetNameToNonZeroInt64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametononzeroint64_free(ptr, 0);
    }
    /**
     * @returns {MapAssetNameToNonZeroInt64}
     */
    static new() {
        const ret = wasm.mapassetnametononzeroint64_new();
        return MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapassetnametononzeroint64_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {AssetName} key
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    insert(key, value) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametononzeroint64_insert(this.__wbg_ptr, key.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : ret[1];
    }
    /**
     * @param {AssetName} key
     * @returns {bigint | undefined}
     */
    get(key) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametononzeroint64_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret[0] === 0 ? undefined : ret[1];
    }
    /**
     * @returns {AssetNameList}
     */
    keys() {
        const ret = wasm.mapassetnametononzeroint64_keys(this.__wbg_ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapAssetNameToU64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapassetnametou64_free(ptr >>> 0, 1));

export class MapAssetNameToU64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapAssetNameToU64.prototype);
        obj.__wbg_ptr = ptr;
        MapAssetNameToU64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapAssetNameToU64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapassetnametou64_free(ptr, 0);
    }
    /**
     * @returns {MapAssetNameToU64}
     */
    static new() {
        const ret = wasm.mapassetnametou64_new();
        return MapAssetNameToU64.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapassetnametou64_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {AssetName} key
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    insert(key, value) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametou64_insert(this.__wbg_ptr, key.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {AssetName} key
     * @returns {bigint | undefined}
     */
    get(key) {
        _assertClass(key, AssetName);
        const ret = wasm.mapassetnametou64_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {AssetNameList}
     */
    keys() {
        const ret = wasm.mapassetnametou64_keys(this.__wbg_ptr);
        return AssetNameList.__wrap(ret);
    }
}

const MapCommitteeColdCredentialToEpochFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapcommitteecoldcredentialtoepoch_free(ptr >>> 0, 1));

export class MapCommitteeColdCredentialToEpoch {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapCommitteeColdCredentialToEpoch.prototype);
        obj.__wbg_ptr = ptr;
        MapCommitteeColdCredentialToEpochFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapCommitteeColdCredentialToEpochFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapcommitteecoldcredentialtoepoch_free(ptr, 0);
    }
    /**
     * @returns {MapCommitteeColdCredentialToEpoch}
     */
    static new() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_new();
        return MapCommitteeColdCredentialToEpoch.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {Credential} key
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    insert(key, value) {
        _assertClass(key, Credential);
        const ret = wasm.mapcommitteecoldcredentialtoepoch_insert(this.__wbg_ptr, key.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {Credential} key
     * @returns {bigint | undefined}
     */
    get(key) {
        _assertClass(key, Credential);
        const ret = wasm.mapcommitteecoldcredentialtoepoch_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {CommitteeColdCredentialList}
     */
    keys() {
        const ret = wasm.mapcommitteecoldcredentialtoepoch_keys(this.__wbg_ptr);
        return CommitteeColdCredentialList.__wrap(ret);
    }
}

const MapGovActionIdToVotingProcedureFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapgovactionidtovotingprocedure_free(ptr >>> 0, 1));

export class MapGovActionIdToVotingProcedure {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapGovActionIdToVotingProcedure.prototype);
        obj.__wbg_ptr = ptr;
        MapGovActionIdToVotingProcedureFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapGovActionIdToVotingProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapgovactionidtovotingprocedure_free(ptr, 0);
    }
    /**
     * @returns {MapGovActionIdToVotingProcedure}
     */
    static new() {
        const ret = wasm.mapgovactionidtovotingprocedure_new();
        return MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapgovactionidtovotingprocedure_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {GovActionId} key
     * @param {VotingProcedure} value
     * @returns {VotingProcedure | undefined}
     */
    insert(key, value) {
        _assertClass(key, GovActionId);
        _assertClass(value, VotingProcedure);
        const ret = wasm.mapgovactionidtovotingprocedure_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : VotingProcedure.__wrap(ret);
    }
    /**
     * @param {GovActionId} key
     * @returns {VotingProcedure | undefined}
     */
    get(key) {
        _assertClass(key, GovActionId);
        const ret = wasm.mapgovactionidtovotingprocedure_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : VotingProcedure.__wrap(ret);
    }
    /**
     * @returns {GovActionIdList}
     */
    keys() {
        const ret = wasm.mapgovactionidtovotingprocedure_keys(this.__wbg_ptr);
        return GovActionIdList.__wrap(ret);
    }
}

const MapPlutusDataToPlutusDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapplutusdatatoplutusdata_free(ptr >>> 0, 1));

export class MapPlutusDataToPlutusData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapPlutusDataToPlutusData.prototype);
        obj.__wbg_ptr = ptr;
        MapPlutusDataToPlutusDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapPlutusDataToPlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapplutusdatatoplutusdata_free(ptr, 0);
    }
    /**
     * @returns {MapPlutusDataToPlutusData}
     */
    static new() {
        const ret = wasm.mapplutusdatatoplutusdata_new();
        return MapPlutusDataToPlutusData.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapplutusdatatoplutusdata_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {PlutusData} key
     * @param {PlutusData} value
     * @returns {PlutusData | undefined}
     */
    insert(key, value) {
        _assertClass(key, PlutusData);
        _assertClass(value, PlutusData);
        const ret = wasm.mapplutusdatatoplutusdata_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
     * @param {PlutusData} key
     * @returns {PlutusData | undefined}
     */
    get(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.mapplutusdatatoplutusdata_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
     * @returns {PlutusDataList}
     */
    keys() {
        const ret = wasm.mapplutusdatatoplutusdata_keys(this.__wbg_ptr);
        return PlutusDataList.__wrap(ret);
    }
}

const MapRedeemerKeyToRedeemerValFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapredeemerkeytoredeemerval_free(ptr >>> 0, 1));

export class MapRedeemerKeyToRedeemerVal {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapRedeemerKeyToRedeemerVal.prototype);
        obj.__wbg_ptr = ptr;
        MapRedeemerKeyToRedeemerValFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapRedeemerKeyToRedeemerValFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapredeemerkeytoredeemerval_free(ptr, 0);
    }
    /**
     * @returns {MapRedeemerKeyToRedeemerVal}
     */
    static new() {
        const ret = wasm.mapredeemerkeytoredeemerval_new();
        return MapRedeemerKeyToRedeemerVal.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapredeemerkeytoredeemerval_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {RedeemerKey} key
     * @param {RedeemerVal} value
     * @returns {RedeemerVal | undefined}
     */
    insert(key, value) {
        _assertClass(key, RedeemerKey);
        _assertClass(value, RedeemerVal);
        const ret = wasm.mapredeemerkeytoredeemerval_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : RedeemerVal.__wrap(ret);
    }
    /**
     * @param {RedeemerKey} key
     * @returns {RedeemerVal | undefined}
     */
    get(key) {
        _assertClass(key, RedeemerKey);
        const ret = wasm.mapredeemerkeytoredeemerval_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : RedeemerVal.__wrap(ret);
    }
    /**
     * @returns {RedeemerKeyList}
     */
    keys() {
        const ret = wasm.mapredeemerkeytoredeemerval_keys(this.__wbg_ptr);
        return RedeemerKeyList.__wrap(ret);
    }
}

const MapRewardAccountToCoinFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_maprewardaccounttocoin_free(ptr >>> 0, 1));

export class MapRewardAccountToCoin {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapRewardAccountToCoin.prototype);
        obj.__wbg_ptr = ptr;
        MapRewardAccountToCoinFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapRewardAccountToCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maprewardaccounttocoin_free(ptr, 0);
    }
    /**
     * @returns {MapRewardAccountToCoin}
     */
    static new() {
        const ret = wasm.maprewardaccounttocoin_new();
        return MapRewardAccountToCoin.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.maprewardaccounttocoin_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {RewardAddress} key
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    insert(key, value) {
        _assertClass(key, RewardAddress);
        const ret = wasm.maprewardaccounttocoin_insert(this.__wbg_ptr, key.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {RewardAddress} key
     * @returns {bigint | undefined}
     */
    get(key) {
        _assertClass(key, RewardAddress);
        const ret = wasm.maprewardaccounttocoin_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {RewardAccountList}
     */
    keys() {
        const ret = wasm.maprewardaccounttocoin_keys(this.__wbg_ptr);
        return RewardAccountList.__wrap(ret);
    }
}

const MapStakeCredentialToDeltaCoinFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapstakecredentialtodeltacoin_free(ptr >>> 0, 1));

export class MapStakeCredentialToDeltaCoin {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapStakeCredentialToDeltaCoin.prototype);
        obj.__wbg_ptr = ptr;
        MapStakeCredentialToDeltaCoinFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapStakeCredentialToDeltaCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapstakecredentialtodeltacoin_free(ptr, 0);
    }
    /**
     * @returns {MapStakeCredentialToDeltaCoin}
     */
    static new() {
        const ret = wasm.mapstakecredentialtodeltacoin_new();
        return MapStakeCredentialToDeltaCoin.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapstakecredentialtodeltacoin_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {Credential} key
     * @param {Int} value
     * @returns {Int | undefined}
     */
    insert(key, value) {
        _assertClass(key, Credential);
        _assertClass(value, Int);
        const ret = wasm.mapstakecredentialtodeltacoin_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
     * @param {Credential} key
     * @returns {Int | undefined}
     */
    get(key) {
        _assertClass(key, Credential);
        const ret = wasm.mapstakecredentialtodeltacoin_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
     * @returns {StakeCredentialList}
     */
    keys() {
        const ret = wasm.mapstakecredentialtodeltacoin_keys(this.__wbg_ptr);
        return StakeCredentialList.__wrap(ret);
    }
}

const MapTransactionIndexToAuxiliaryDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_maptransactionindextoauxiliarydata_free(ptr >>> 0, 1));

export class MapTransactionIndexToAuxiliaryData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapTransactionIndexToAuxiliaryData.prototype);
        obj.__wbg_ptr = ptr;
        MapTransactionIndexToAuxiliaryDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapTransactionIndexToAuxiliaryDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maptransactionindextoauxiliarydata_free(ptr, 0);
    }
    /**
     * @returns {MapTransactionIndexToAuxiliaryData}
     */
    static new() {
        const ret = wasm.maptransactionindextoauxiliarydata_new();
        return MapTransactionIndexToAuxiliaryData.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.maptransactionindextoauxiliarydata_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} key
     * @param {AuxiliaryData} value
     * @returns {AuxiliaryData | undefined}
     */
    insert(key, value) {
        _assertClass(value, AuxiliaryData);
        const ret = wasm.maptransactionindextoauxiliarydata_insert(this.__wbg_ptr, key, value.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
     * @param {number} key
     * @returns {AuxiliaryData | undefined}
     */
    get(key) {
        const ret = wasm.maptransactionindextoauxiliarydata_get(this.__wbg_ptr, key);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
     * @returns {Uint16Array}
     */
    keys() {
        const ret = wasm.maptransactionindextoauxiliarydata_keys(this.__wbg_ptr);
        var v1 = getArrayU16FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);
        return v1;
    }
}

const MapTransactionMetadatumToTransactionMetadatumFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_maptransactionmetadatumtotransactionmetadatum_free(ptr >>> 0, 1));

export class MapTransactionMetadatumToTransactionMetadatum {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapTransactionMetadatumToTransactionMetadatum.prototype);
        obj.__wbg_ptr = ptr;
        MapTransactionMetadatumToTransactionMetadatumFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapTransactionMetadatumToTransactionMetadatumFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maptransactionmetadatumtotransactionmetadatum_free(ptr, 0);
    }
    /**
     * @returns {MapTransactionMetadatumToTransactionMetadatum}
     */
    static new() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_new();
        return MapTransactionMetadatumToTransactionMetadatum.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {TransactionMetadatum} key
     * @param {TransactionMetadatum} value
     * @returns {TransactionMetadatum | undefined}
     */
    insert(key, value) {
        _assertClass(key, TransactionMetadatum);
        _assertClass(value, TransactionMetadatum);
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {TransactionMetadatum} key
     * @returns {TransactionMetadatum | undefined}
     */
    get(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
     * @returns {TransactionMetadatumList}
     */
    keys() {
        const ret = wasm.maptransactionmetadatumtotransactionmetadatum_keys(this.__wbg_ptr);
        return TransactionMetadatumList.__wrap(ret);
    }
}

const MapU64ToArrI64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mapu64toarri64_free(ptr >>> 0, 1));

export class MapU64ToArrI64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MapU64ToArrI64.prototype);
        obj.__wbg_ptr = ptr;
        MapU64ToArrI64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MapU64ToArrI64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mapu64toarri64_free(ptr, 0);
    }
    /**
     * @param {bigint} key
     * @returns {BigInt64Array | undefined}
     */
    get(key) {
        const ret = wasm.mapu64toarri64_get(this.__wbg_ptr, key);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayI64FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 8, 8);
        }
        return v1;
    }
    /**
     * @param {bigint} key
     * @param {BigInt64Array} value
     * @returns {BigInt64Array | undefined}
     */
    insert(key, value) {
        const ptr0 = passArray64ToWasm0(value, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.mapu64toarri64_insert(this.__wbg_ptr, key, ptr0, len0);
        let v2;
        if (ret[0] !== 0) {
            v2 = getArrayI64FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 8, 8);
        }
        return v2;
    }
    /**
     * @returns {MapU64ToArrI64}
     */
    static new() {
        const ret = wasm.mapu64toarri64_new();
        return MapU64ToArrI64.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.mapu64toarri64_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm.mapu64toarri64_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {BigUint64Array}
     */
    keys() {
        const ret = wasm.mapu64toarri64_keys(this.__wbg_ptr);
        var v1 = getArrayU64FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 8, 8);
        return v1;
    }
}

const MetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0, 1));

export class Metadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Metadata.prototype);
        obj.__wbg_ptr = ptr;
        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadata_free(ptr, 0);
    }
    /**
     * @returns {Metadata}
     */
    static new() {
        const ret = wasm.metadata_new();
        return Metadata.__wrap(ret);
    }
    /**
     * How many metadatum labels there are.
     * @returns {number}
     */
    len() {
        const ret = wasm.metadata_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Replaces all metadatums of a given label, if any exist.
     * @param {bigint} key
     * @param {TransactionMetadatum} value
     */
    set(key, value) {
        _assertClass(value, TransactionMetadatum);
        wasm.metadata_set(this.__wbg_ptr, key, value.__wbg_ptr);
    }
    /**
     * Gets the Metadatum corresponding to a given label, if it exists.
     * Note: In the case of duplicate labels this only returns the first metadatum.
     * This is an extremely rare occurence on-chain but can happen.
     * @param {bigint} label
     * @returns {TransactionMetadatum | undefined}
     */
    get(label) {
        const ret = wasm.metadata_get(this.__wbg_ptr, label);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
     * In the extremely unlikely situation there are duplicate labels, this gets all of a single label
     * @param {bigint} label
     * @returns {TransactionMetadatumList | undefined}
     */
    get_all(label) {
        const ret = wasm.metadata_get_all(this.__wbg_ptr, label);
        return ret === 0 ? undefined : TransactionMetadatumList.__wrap(ret);
    }
    /**
     * @returns {TransactionMetadatumLabels}
     */
    labels() {
        const ret = wasm.metadata_labels(this.__wbg_ptr);
        return TransactionMetadatumLabels.__wrap(ret);
    }
}

const MetadatumListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_metadatumlist_free(ptr >>> 0, 1));

export class MetadatumList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MetadatumList.prototype);
        obj.__wbg_ptr = ptr;
        MetadatumListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MetadatumListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadatumlist_free(ptr, 0);
    }
    /**
     * @returns {MetadatumList}
     */
    static new() {
        const ret = wasm.metadatumlist_new();
        return MetadatumList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.metadatumlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionMetadatum}
     */
    get(index) {
        const ret = wasm.metadatumlist_get(this.__wbg_ptr, index);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {TransactionMetadatum} elem
     */
    add(elem) {
        _assertClass(elem, TransactionMetadatum);
        wasm.metadatumlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const MetadatumMapFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_metadatummap_free(ptr >>> 0, 1));

export class MetadatumMap {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MetadatumMap.prototype);
        obj.__wbg_ptr = ptr;
        MetadatumMapFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MetadatumMapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadatummap_free(ptr, 0);
    }
    /**
     * @returns {MetadatumMap}
     */
    static new() {
        const ret = wasm.metadatummap_new();
        return MetadatumMap.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.metadatummap_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * Replaces all metadatums of a given key, if any exist.
     * @param {TransactionMetadatum} key
     * @param {TransactionMetadatum} value
     */
    set(key, value) {
        _assertClass(key, TransactionMetadatum);
        _assertClass(value, TransactionMetadatum);
        wasm.metadatummap_set(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    }
    /**
     * Gets the Metadatum corresponding to a given key, if it exists.
     * Note: In the case of duplicate keys this only returns the first metadatum.
     * This is an extremely rare occurence (2 total on mainnet) on-chain but can happen.
     * @param {TransactionMetadatum} key
     * @returns {TransactionMetadatum | undefined}
     */
    get(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.metadatummap_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
    }
    /**
     * In the extremely unlikely situation there are duplicate keys, this gets all of a single key
     * @param {TransactionMetadatum} key
     * @returns {TransactionMetadatumList | undefined}
     */
    get_all(key) {
        _assertClass(key, TransactionMetadatum);
        const ret = wasm.metadatummap_get_all(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : TransactionMetadatumList.__wrap(ret);
    }
    /**
     * @returns {MetadatumList}
     */
    keys() {
        const ret = wasm.metadatummap_keys(this.__wbg_ptr);
        return MetadatumList.__wrap(ret);
    }
}

const MintFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mint_free(ptr >>> 0, 1));

export class Mint {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Mint.prototype);
        obj.__wbg_ptr = ptr;
        MintFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MintFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mint_free(ptr, 0);
    }
    /**
     * @returns {Mint}
     */
    static new() {
        const ret = wasm.mint_new();
        return Mint.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    policy_count() {
        const ret = wasm.mint_policy_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {ScriptHash} policy_id
     * @param {MapAssetNameToNonZeroInt64} assets
     * @returns {MapAssetNameToNonZeroInt64 | undefined}
     */
    insert_assets(policy_id, assets) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(assets, MapAssetNameToNonZeroInt64);
        const ret = wasm.mint_insert_assets(this.__wbg_ptr, policy_id.__wbg_ptr, assets.__wbg_ptr);
        return ret === 0 ? undefined : MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
     * @param {ScriptHash} key
     * @returns {MapAssetNameToNonZeroInt64 | undefined}
     */
    get_assets(key) {
        _assertClass(key, ScriptHash);
        const ret = wasm.mint_get_assets(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : MapAssetNameToNonZeroInt64.__wrap(ret);
    }
    /**
     * Get the value of policy_id:asset_name if it exists.
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset
     * @returns {bigint | undefined}
     */
    get(policy_id, asset) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset, AssetName);
        const ret = wasm.mint_get(this.__wbg_ptr, policy_id.__wbg_ptr, asset.__wbg_ptr);
        return ret[0] === 0 ? undefined : ret[1];
    }
    /**
     * Set the value of policy_id:asset_name to value.
     * Returns the previous value, or None if it didn't exist
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    set(policy_id, asset, value) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset, AssetName);
        const ret = wasm.mint_set(this.__wbg_ptr, policy_id.__wbg_ptr, asset.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : ret[1];
    }
    /**
     * @returns {PolicyIdList}
     */
    keys() {
        const ret = wasm.mint_keys(this.__wbg_ptr);
        return PolicyIdList.__wrap(ret);
    }
    /**
     * Adds two mints together, checking value bounds.
     * Does not modify self, and instead returns the result.
     * @param {Mint} rhs
     * @returns {Mint}
     */
    checked_add(rhs) {
        _assertClass(rhs, Mint);
        const ret = wasm.mint_checked_add(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Mint.__wrap(ret[0]);
    }
    /**
     * Subtracts rhs from this mint.
     * This does not modify self, and instead returns the result.
     * @param {Mint} rhs
     * @returns {Mint}
     */
    checked_sub(rhs) {
        _assertClass(rhs, Mint);
        const ret = wasm.mint_checked_sub(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Mint.__wrap(ret[0]);
    }
    /**
     * Returns the multiasset where only positive (minting) entries are present
     * @returns {MultiAsset}
     */
    as_positive_multiasset() {
        const ret = wasm.mint_as_positive_multiasset(this.__wbg_ptr);
        return MultiAsset.__wrap(ret);
    }
    /**
     * Returns the multiasset where only negative (burning) entries are present
     * @returns {MultiAsset}
     */
    as_negative_multiasset() {
        const ret = wasm.mint_as_negative_multiasset(this.__wbg_ptr);
        return MultiAsset.__wrap(ret);
    }
}

const MintBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mintbuilderresult_free(ptr >>> 0, 1));

export class MintBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MintBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        MintBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MintBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mintbuilderresult_free(ptr, 0);
    }
}

const MultiAssetFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multiasset_free(ptr >>> 0, 1));

export class MultiAsset {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MultiAsset.prototype);
        obj.__wbg_ptr = ptr;
        MultiAssetFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiAssetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multiasset_free(ptr, 0);
    }
    /**
     * @returns {MultiAsset}
     */
    static new() {
        const ret = wasm.multiasset_new();
        return MultiAsset.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    policy_count() {
        const ret = wasm.multiasset_policy_count(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {ScriptHash} policy_id
     * @param {MapAssetNameToCoin} assets
     * @returns {MapAssetNameToCoin | undefined}
     */
    insert_assets(policy_id, assets) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(assets, MapAssetNameToCoin);
        const ret = wasm.multiasset_insert_assets(this.__wbg_ptr, policy_id.__wbg_ptr, assets.__wbg_ptr);
        return ret === 0 ? undefined : MapAssetNameToCoin.__wrap(ret);
    }
    /**
     * @param {ScriptHash} key
     * @returns {MapAssetNameToCoin | undefined}
     */
    get_assets(key) {
        _assertClass(key, ScriptHash);
        const ret = wasm.multiasset_get_assets(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : MapAssetNameToCoin.__wrap(ret);
    }
    /**
     * Get the value of policy_id:asset_name if it exists.
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset
     * @returns {bigint | undefined}
     */
    get(policy_id, asset) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset, AssetName);
        const ret = wasm.multiasset_get(this.__wbg_ptr, policy_id.__wbg_ptr, asset.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * Set the value of policy_id:asset_name to value.
     * Returns the previous value, or None if it didn't exist
     * @param {ScriptHash} policy_id
     * @param {AssetName} asset
     * @param {bigint} value
     * @returns {bigint | undefined}
     */
    set(policy_id, asset, value) {
        _assertClass(policy_id, ScriptHash);
        _assertClass(asset, AssetName);
        const ret = wasm.multiasset_set(this.__wbg_ptr, policy_id.__wbg_ptr, asset.__wbg_ptr, value);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @returns {PolicyIdList}
     */
    keys() {
        const ret = wasm.multiasset_keys(this.__wbg_ptr);
        return PolicyIdList.__wrap(ret);
    }
    /**
     * Adds to multiassets together, checking value bounds.
     * Does not modify self, and instead returns the result.
     * @param {MultiAsset} rhs
     * @returns {MultiAsset}
     */
    checked_add(rhs) {
        _assertClass(rhs, MultiAsset);
        const ret = wasm.multiasset_checked_add(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MultiAsset.__wrap(ret[0]);
    }
    /**
     * Subtracts rhs from this multiasset.
     * This does not modify self, and instead returns the result.
     * If this would cause there to be fewer than 0 of a given asset
     * an error will be returned.
     * Use clamped_sub if you need to only try to remove assets when they exist
     * and ignore them when they don't.
     * @param {MultiAsset} rhs
     * @returns {MultiAsset}
     */
    checked_sub(rhs) {
        _assertClass(rhs, MultiAsset);
        const ret = wasm.multiasset_checked_sub(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MultiAsset.__wrap(ret[0]);
    }
    /**
     * Sybtracts rhs from this multiasset.
     * If this would cause there to be 0 or fewer of a given asset
     * it will simply be removed entirely from the result.
     * @param {MultiAsset} rhs
     * @returns {MultiAsset}
     */
    clamped_sub(rhs) {
        _assertClass(rhs, MultiAsset);
        const ret = wasm.multiasset_clamped_sub(this.__wbg_ptr, rhs.__wbg_ptr);
        return MultiAsset.__wrap(ret);
    }
}

const MultiHostNameFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multihostname_free(ptr >>> 0, 1));

export class MultiHostName {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MultiHostName.prototype);
        obj.__wbg_ptr = ptr;
        MultiHostNameFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiHostNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multihostname_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.multihostname_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.multihostname_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {MultiHostName}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.multihostname_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MultiHostName.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.multihostname_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.multihostname_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {MultiHostName}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.multihostname_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MultiHostName.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.multihostname_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.multihostname_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {MultiHostName}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.multihostname_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return MultiHostName.__wrap(ret[0]);
    }
    /**
     * @returns {DNSName}
     */
    dns_name() {
        const ret = wasm.multihostname_dns_name(this.__wbg_ptr);
        return DNSName.__wrap(ret);
    }
    /**
     * * `dns_name` - A SRV DNS record
     * @param {DNSName} dns_name
     * @returns {MultiHostName}
     */
    static new(dns_name) {
        _assertClass(dns_name, DNSName);
        const ret = wasm.multihostname_new(dns_name.__wbg_ptr);
        return MultiHostName.__wrap(ret);
    }
}

const NativeScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nativescript_free(ptr >>> 0, 1));

export class NativeScript {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NativeScript.prototype);
        obj.__wbg_ptr = ptr;
        NativeScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NativeScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescript_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.nativescript_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.nativescript_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {NativeScript}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nativescript_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NativeScript.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.nativescript_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.nativescript_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {NativeScript}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nativescript_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NativeScript.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.nativescript_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.nativescript_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {NativeScript}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nativescript_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NativeScript.__wrap(ret[0]);
    }
    /**
     * @param {Ed25519KeyHash} ed25519_key_hash
     * @returns {NativeScript}
     */
    static new_script_pubkey(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.nativescript_new_script_pubkey(ed25519_key_hash.__wbg_ptr);
        return NativeScript.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     * @returns {NativeScript}
     */
    static new_script_all(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_all(native_scripts.__wbg_ptr);
        return NativeScript.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     * @returns {NativeScript}
     */
    static new_script_any(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_any(native_scripts.__wbg_ptr);
        return NativeScript.__wrap(ret);
    }
    /**
     * @param {bigint} n
     * @param {NativeScriptList} native_scripts
     * @returns {NativeScript}
     */
    static new_script_n_of_k(n, native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.nativescript_new_script_n_of_k(n, native_scripts.__wbg_ptr);
        return NativeScript.__wrap(ret);
    }
    /**
     * Timelock validity intervals are half-open intervals [a, b). This field specifies the left (included) endpoint a.
     * @param {bigint} before
     * @returns {NativeScript}
     */
    static new_script_invalid_before(before) {
        const ret = wasm.nativescript_new_script_invalid_before(before);
        return NativeScript.__wrap(ret);
    }
    /**
     * Timelock validity intervals are half-open intervals [a, b). This field specifies the right (excluded) endpoint b.
     * @param {bigint} after
     * @returns {NativeScript}
     */
    static new_script_invalid_hereafter(after) {
        const ret = wasm.nativescript_new_script_invalid_hereafter(after);
        return NativeScript.__wrap(ret);
    }
    /**
     * @returns {NativeScriptKind}
     */
    kind() {
        const ret = wasm.nativescript_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ScriptPubkey | undefined}
     */
    as_script_pubkey() {
        const ret = wasm.nativescript_as_script_pubkey(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);
    }
    /**
     * @returns {ScriptAll | undefined}
     */
    as_script_all() {
        const ret = wasm.nativescript_as_script_all(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptAll.__wrap(ret);
    }
    /**
     * @returns {ScriptAny | undefined}
     */
    as_script_any() {
        const ret = wasm.nativescript_as_script_any(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptAny.__wrap(ret);
    }
    /**
     * @returns {ScriptNOfK | undefined}
     */
    as_script_n_of_k() {
        const ret = wasm.nativescript_as_script_n_of_k(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);
    }
    /**
     * @returns {ScriptInvalidBefore | undefined}
     */
    as_script_invalid_before() {
        const ret = wasm.nativescript_as_script_invalid_before(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptInvalidBefore.__wrap(ret);
    }
    /**
     * @returns {ScriptInvalidHereafter | undefined}
     */
    as_script_invalid_hereafter() {
        const ret = wasm.nativescript_as_script_invalid_hereafter(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptInvalidHereafter.__wrap(ret);
    }
    /**
     * Returns an array of unique Ed25519KeyHashes
     * contained within this script recursively on any depth level.
     * The order of the keys in the result is not determined in any way.
     * @returns {Ed25519KeyHashList}
     */
    get_required_signers() {
        const ret = wasm.nativescript_get_required_signers(this.__wbg_ptr);
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.nativescript_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     * @param {bigint | null | undefined} lower_bound
     * @param {bigint | null | undefined} upper_bound
     * @param {Ed25519KeyHashList} key_hashes
     * @returns {boolean}
     */
    verify(lower_bound, upper_bound, key_hashes) {
        _assertClass(key_hashes, Ed25519KeyHashList);
        const ret = wasm.nativescript_verify(this.__wbg_ptr, !isLikeNone(lower_bound), isLikeNone(lower_bound) ? BigInt(0) : lower_bound, !isLikeNone(upper_bound), isLikeNone(upper_bound) ? BigInt(0) : upper_bound, key_hashes.__wbg_ptr);
        return ret !== 0;
    }
}

const NativeScriptListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nativescriptlist_free(ptr >>> 0, 1));

export class NativeScriptList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NativeScriptList.prototype);
        obj.__wbg_ptr = ptr;
        NativeScriptListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NativeScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescriptlist_free(ptr, 0);
    }
    /**
     * @returns {NativeScriptList}
     */
    static new() {
        const ret = wasm.nativescriptlist_new();
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.nativescriptlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {NativeScript}
     */
    get(index) {
        const ret = wasm.nativescriptlist_get(this.__wbg_ptr, index);
        return NativeScript.__wrap(ret);
    }
    /**
     * @param {NativeScript} elem
     */
    add(elem) {
        _assertClass(elem, NativeScript);
        wasm.nativescriptlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const NativeScriptWitnessInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nativescriptwitnessinfo_free(ptr >>> 0, 1));

export class NativeScriptWitnessInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NativeScriptWitnessInfo.prototype);
        obj.__wbg_ptr = ptr;
        NativeScriptWitnessInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NativeScriptWitnessInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nativescriptwitnessinfo_free(ptr, 0);
    }
    /**
     * Unsure which keys will sign, but you know the exact number to save on tx fee
     * @param {number} num
     * @returns {NativeScriptWitnessInfo}
     */
    static num_signatures(num) {
        const ret = wasm.nativescriptwitnessinfo_num_signatures(num);
        return NativeScriptWitnessInfo.__wrap(ret);
    }
    /**
     * This native script will be witnessed by exactly these keys
     * @param {Ed25519KeyHashList} vkeys
     * @returns {NativeScriptWitnessInfo}
     */
    static vkeys(vkeys) {
        _assertClass(vkeys, Ed25519KeyHashList);
        const ret = wasm.nativescriptwitnessinfo_vkeys(vkeys.__wbg_ptr);
        return NativeScriptWitnessInfo.__wrap(ret);
    }
    /**
     * You don't know how many keys will sign, so the maximum possible case will be assumed
     * @returns {NativeScriptWitnessInfo}
     */
    static assume_signature_count() {
        const ret = wasm.nativescriptwitnessinfo_assume_signature_count();
        return NativeScriptWitnessInfo.__wrap(ret);
    }
}

const NetworkIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_networkid_free(ptr >>> 0, 1));

export class NetworkId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NetworkId.prototype);
        obj.__wbg_ptr = ptr;
        NetworkIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetworkIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_networkid_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.networkid_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.networkid_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {NetworkId}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.networkid_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NetworkId.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.networkid_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.networkid_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {NetworkId}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.networkid_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NetworkId.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.networkid_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.networkid_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {NetworkId}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.networkid_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NetworkId.__wrap(ret[0]);
    }
    /**
     * @param {bigint} network
     * @returns {NetworkId}
     */
    static new(network) {
        const ret = wasm.networkid_new(network);
        return NetworkId.__wrap(ret);
    }
    /**
     * @returns {NetworkId}
     */
    static mainnet() {
        const ret = wasm.networkid_mainnet();
        return NetworkId.__wrap(ret);
    }
    /**
     * @returns {NetworkId}
     */
    static testnet() {
        const ret = wasm.networkid_testnet();
        return NetworkId.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    network() {
        const ret = wasm.networkid_network(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
}

const NetworkInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_networkinfo_free(ptr >>> 0, 1));

export class NetworkInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NetworkInfo.prototype);
        obj.__wbg_ptr = ptr;
        NetworkInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetworkInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_networkinfo_free(ptr, 0);
    }
    /**
     * @param {number} network_id
     * @param {ProtocolMagic} protocol_magic
     * @returns {NetworkInfo}
     */
    static new(network_id, protocol_magic) {
        _assertClass(protocol_magic, ProtocolMagic);
        const ret = wasm.networkinfo_new(network_id, protocol_magic.__wbg_ptr);
        return NetworkInfo.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.networkinfo_network_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ProtocolMagic}
     */
    protocol_magic() {
        const ret = wasm.networkinfo_protocol_magic(this.__wbg_ptr);
        return ProtocolMagic.__wrap(ret);
    }
    /**
     * This is the old testnet - most likely you want to use preview()/preprod()
     * @returns {NetworkInfo}
     */
    static testnet() {
        const ret = wasm.networkinfo_testnet();
        return NetworkInfo.__wrap(ret);
    }
    /**
     * @returns {NetworkInfo}
     */
    static mainnet() {
        const ret = wasm.networkinfo_mainnet();
        return NetworkInfo.__wrap(ret);
    }
    /**
     * @returns {NetworkInfo}
     */
    static preview() {
        const ret = wasm.networkinfo_preview();
        return NetworkInfo.__wrap(ret);
    }
    /**
     * @returns {NetworkInfo}
     */
    static preprod() {
        const ret = wasm.networkinfo_preprod();
        return NetworkInfo.__wrap(ret);
    }
    /**
     * @returns {NetworkInfo}
     */
    static sancho_testnet() {
        const ret = wasm.networkinfo_sancho_testnet();
        return NetworkInfo.__wrap(ret);
    }
}

const NewConstitutionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_newconstitution_free(ptr >>> 0, 1));

export class NewConstitution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NewConstitution.prototype);
        obj.__wbg_ptr = ptr;
        NewConstitutionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NewConstitutionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_newconstitution_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.newconstitution_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.newconstitution_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {NewConstitution}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.newconstitution_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NewConstitution.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.newconstitution_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.newconstitution_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {NewConstitution}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.newconstitution_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NewConstitution.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.newconstitution_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.newconstitution_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {NewConstitution}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.newconstitution_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NewConstitution.__wrap(ret[0]);
    }
    /**
     * @returns {GovActionId | undefined}
     */
    action_id() {
        const ret = wasm.newconstitution_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
     * @returns {Constitution}
     */
    constitution() {
        const ret = wasm.newconstitution_constitution(this.__wbg_ptr);
        return Constitution.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {Constitution} constitution
     * @returns {NewConstitution}
     */
    static new(action_id, constitution) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(constitution, Constitution);
        const ret = wasm.newconstitution_new(ptr0, constitution.__wbg_ptr);
        return NewConstitution.__wrap(ret);
    }
}

const NoConfidenceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_noconfidence_free(ptr >>> 0, 1));

export class NoConfidence {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NoConfidence.prototype);
        obj.__wbg_ptr = ptr;
        NoConfidenceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NoConfidenceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_noconfidence_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.noconfidence_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.noconfidence_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {NoConfidence}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noconfidence_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NoConfidence.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.noconfidence_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.noconfidence_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {NoConfidence}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noconfidence_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NoConfidence.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.noconfidence_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.noconfidence_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {NoConfidence}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noconfidence_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NoConfidence.__wrap(ret[0]);
    }
    /**
     * @returns {GovActionId | undefined}
     */
    action_id() {
        const ret = wasm.noconfidence_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
     * @param {GovActionId | null} [action_id]
     * @returns {NoConfidence}
     */
    static new(action_id) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        const ret = wasm.noconfidence_new(ptr0);
        return NoConfidence.__wrap(ret);
    }
}

const NonceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nonce_free(ptr >>> 0, 1));

export class Nonce {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nonce.prototype);
        obj.__wbg_ptr = ptr;
        NonceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NonceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nonce_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.nonce_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.nonce_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Nonce}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nonce_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Nonce.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.nonce_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.nonce_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Nonce}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nonce_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Nonce.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.nonce_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.nonce_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Nonce}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nonce_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Nonce.__wrap(ret[0]);
    }
    /**
     * @returns {Nonce}
     */
    static new_identity() {
        const ret = wasm.nonce_new_identity();
        return Nonce.__wrap(ret);
    }
    /**
     * @param {NonceHash} hash
     * @returns {Nonce}
     */
    static new_hash(hash) {
        _assertClass(hash, NonceHash);
        const ret = wasm.nonce_new_hash(hash.__wbg_ptr);
        return Nonce.__wrap(ret);
    }
    /**
     * @returns {NonceKind}
     */
    kind() {
        const ret = wasm.nonce_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {NonceHash | undefined}
     */
    as_hash() {
        const ret = wasm.nonce_as_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : NonceHash.__wrap(ret);
    }
}

const NonceHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_noncehash_free(ptr >>> 0, 1));

export class NonceHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NonceHash.prototype);
        obj.__wbg_ptr = ptr;
        NonceHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NonceHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_noncehash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.noncehash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {NonceHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noncehash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NonceHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.noncehash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {NonceHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noncehash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NonceHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.noncehash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {NonceHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.noncehash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return NonceHash.__wrap(ret[0]);
    }
}

const OperationalCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_operationalcert_free(ptr >>> 0, 1));

export class OperationalCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OperationalCert.prototype);
        obj.__wbg_ptr = ptr;
        OperationalCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OperationalCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_operationalcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.operationalcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.operationalcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {OperationalCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.operationalcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return OperationalCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.operationalcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.operationalcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {OperationalCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.operationalcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return OperationalCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.operationalcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.operationalcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {OperationalCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.operationalcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return OperationalCert.__wrap(ret[0]);
    }
    /**
     * @returns {KESVkey}
     */
    hot_vkey() {
        const ret = wasm.operationalcert_hot_vkey(this.__wbg_ptr);
        return KESVkey.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    sequence_number() {
        const ret = wasm.operationalcert_sequence_number(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    kes_period() {
        const ret = wasm.operationalcert_kes_period(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {Ed25519Signature}
     */
    sigma() {
        const ret = wasm.operationalcert_sigma(this.__wbg_ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
     * @param {KESVkey} hot_vkey
     * @param {bigint} sequence_number
     * @param {bigint} kes_period
     * @param {Ed25519Signature} sigma
     * @returns {OperationalCert}
     */
    static new(hot_vkey, sequence_number, kes_period, sigma) {
        _assertClass(hot_vkey, KESVkey);
        _assertClass(sigma, Ed25519Signature);
        const ret = wasm.operationalcert_new(hot_vkey.__wbg_ptr, sequence_number, kes_period, sigma.__wbg_ptr);
        return OperationalCert.__wrap(ret);
    }
}

const ParameterChangeActionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_parameterchangeaction_free(ptr >>> 0, 1));

export class ParameterChangeAction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ParameterChangeAction.prototype);
        obj.__wbg_ptr = ptr;
        ParameterChangeActionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ParameterChangeActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_parameterchangeaction_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.parameterchangeaction_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.parameterchangeaction_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ParameterChangeAction}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.parameterchangeaction_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ParameterChangeAction.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.parameterchangeaction_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.parameterchangeaction_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ParameterChangeAction}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.parameterchangeaction_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ParameterChangeAction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.parameterchangeaction_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.parameterchangeaction_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ParameterChangeAction}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.parameterchangeaction_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ParameterChangeAction.__wrap(ret[0]);
    }
    /**
     * @returns {GovActionId | undefined}
     */
    action_id() {
        const ret = wasm.parameterchangeaction_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
     * @returns {ProtocolParamUpdate}
     */
    update() {
        const ret = wasm.parameterchangeaction_update(this.__wbg_ptr);
        return ProtocolParamUpdate.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    policy_hash() {
        const ret = wasm.parameterchangeaction_policy_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {ProtocolParamUpdate} update
     * @param {ScriptHash | null} [policy_hash]
     * @returns {ParameterChangeAction}
     */
    static new(action_id, update, policy_hash) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(update, ProtocolParamUpdate);
        let ptr1 = 0;
        if (!isLikeNone(policy_hash)) {
            _assertClass(policy_hash, ScriptHash);
            ptr1 = policy_hash.__destroy_into_raw();
        }
        const ret = wasm.parameterchangeaction_new(ptr0, update.__wbg_ptr, ptr1);
        return ParameterChangeAction.__wrap(ret);
    }
}

const PartialPlutusWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_partialplutuswitness_free(ptr >>> 0, 1));
/**
 * A partial Plutus witness
 * It contains all the information needed to witness the Plutus script execution
 * except for the redeemer tag and index
 * Note: no datum is attached because only input script types have datums
 */
export class PartialPlutusWitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PartialPlutusWitness.prototype);
        obj.__wbg_ptr = ptr;
        PartialPlutusWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PartialPlutusWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_partialplutuswitness_free(ptr, 0);
    }
    /**
     * @param {PlutusScriptWitness} script
     * @param {PlutusData} data
     * @returns {PartialPlutusWitness}
     */
    static new(script, data) {
        _assertClass(script, PlutusScriptWitness);
        _assertClass(data, PlutusData);
        const ret = wasm.partialplutuswitness_new(script.__wbg_ptr, data.__wbg_ptr);
        return PartialPlutusWitness.__wrap(ret);
    }
    /**
     * @returns {PlutusScriptWitness}
     */
    script() {
        const ret = wasm.partialplutuswitness_script(this.__wbg_ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
     * @returns {PlutusData}
     */
    data() {
        const ret = wasm.partialplutuswitness_data(this.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
}

const PlutusDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusdata_free(ptr >>> 0, 1));

export class PlutusData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusData.prototype);
        obj.__wbg_ptr = ptr;
        PlutusDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusdata_free(ptr, 0);
    }
    /**
     *
     *     *  Convert to a Datum that will serialize equivalent to cardano-node's format
     *     *
     *     *  Please VERY STRONGLY consider using PlutusData::from_cbor_bytes() instead wherever possible.
     *     * You should try to never rely on a tool encoding CBOR a certain way as there are many possible,
     *     * and just because it matches with a specific datum, doesn't mean that a different datum won't differ.
     *     * This is critical as that means the datum hash won't match.
     *     * After creation a datum (or other hashable CBOR object) should only be treated as raw CBOR bytes,
     *     * or through a type that respects its specific CBOR format e.g. CML's PlutusData::from_cbor_bytes()
     *     *
     *     *  This function is just here in case there's no possible way at all to create from CBOR bytes and
     *     * thus cold only be constructed manually and then had this function called on it.
     *     *
     *     *  This is also the format that CSL and Lucid use
     *
     * @returns {PlutusData}
     */
    to_cardano_node_format() {
        const ret = wasm.plutusdata_to_cardano_node_format(this.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.plutusdata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.plutusdata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PlutusData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusdata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusdata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusdata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PlutusData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusdata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusData.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.plutusdata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.plutusdata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PlutusData}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusdata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusData.__wrap(ret[0]);
    }
    /**
     * @param {ConstrPlutusData} constr_plutus_data
     * @returns {PlutusData}
     */
    static new_constr_plutus_data(constr_plutus_data) {
        _assertClass(constr_plutus_data, ConstrPlutusData);
        const ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @param {PlutusMap} map
     * @returns {PlutusData}
     */
    static new_map(map) {
        _assertClass(map, PlutusMap);
        const ret = wasm.plutusdata_new_map(map.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @param {PlutusDataList} list
     * @returns {PlutusData}
     */
    static new_list(list) {
        _assertClass(list, PlutusDataList);
        const ret = wasm.plutusdata_new_list(list.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @param {BigInteger} big_int
     * @returns {PlutusData}
     */
    static new_integer(big_int) {
        _assertClass(big_int, BigInteger);
        const ret = wasm.plutusdata_new_integer(big_int.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {PlutusData}
     */
    static new_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusdata_new_bytes(ptr0, len0);
        return PlutusData.__wrap(ret);
    }
    /**
     * @returns {PlutusDataKind}
     */
    kind() {
        const ret = wasm.plutusdata_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {ConstrPlutusData | undefined}
     */
    as_constr_plutus_data() {
        const ret = wasm.plutusdata_as_constr_plutus_data(this.__wbg_ptr);
        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);
    }
    /**
     * @returns {PlutusMap | undefined}
     */
    as_map() {
        const ret = wasm.plutusdata_as_map(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusMap.__wrap(ret);
    }
    /**
     * @returns {PlutusDataList | undefined}
     */
    as_list() {
        const ret = wasm.plutusdata_as_list(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
     * @returns {BigInteger | undefined}
     */
    as_integer() {
        const ret = wasm.plutusdata_as_integer(this.__wbg_ptr);
        return ret === 0 ? undefined : BigInteger.__wrap(ret);
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    as_bytes() {
        const ret = wasm.plutusdata_as_bytes(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
}

const PlutusDataListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusdatalist_free(ptr >>> 0, 1));

export class PlutusDataList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusDataList.prototype);
        obj.__wbg_ptr = ptr;
        PlutusDataListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusDataListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusdatalist_free(ptr, 0);
    }
    /**
     * @returns {PlutusDataList}
     */
    static new() {
        const ret = wasm.plutusdatalist_new();
        return PlutusDataList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.plutusdatalist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {PlutusData}
     */
    get(index) {
        const ret = wasm.plutusdatalist_get(this.__wbg_ptr, index);
        return PlutusData.__wrap(ret);
    }
    /**
     * @param {PlutusData} elem
     */
    add(elem) {
        _assertClass(elem, PlutusData);
        wasm.plutusdatalist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const PlutusMapFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusmap_free(ptr >>> 0, 1));

export class PlutusMap {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusMap.prototype);
        obj.__wbg_ptr = ptr;
        PlutusMapFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusMapFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusmap_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.plutusmap_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.plutusmap_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PlutusMap}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusmap_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusMap.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusmap_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusmap_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PlutusMap}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusmap_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusMap.__wrap(ret[0]);
    }
    /**
     * @returns {PlutusMap}
     */
    static new() {
        const ret = wasm.plutusmap_new();
        return PlutusMap.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.plutusmap_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm.plutusmap_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Replaces all datums of a given key, if any exist.
     * @param {PlutusData} key
     * @param {PlutusData} value
     */
    set(key, value) {
        _assertClass(key, PlutusData);
        _assertClass(value, PlutusData);
        wasm.plutusmap_set(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    }
    /**
     * Gets the plutus datum corresponding to a given key, if it exists.
     * Note: In the case of duplicate keys this only returns the first datum.
     * This is an extremely rare occurence on-chain but can happen.
     * @param {PlutusData} key
     * @returns {PlutusData | undefined}
     */
    get(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.plutusmap_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
    /**
     * In the extremely unlikely situation there are duplicate keys, this gets all of a single key
     * @param {PlutusData} key
     * @returns {PlutusDataList | undefined}
     */
    get_all(key) {
        _assertClass(key, PlutusData);
        const ret = wasm.plutusmap_get_all(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
     * @returns {PlutusDataList}
     */
    keys() {
        const ret = wasm.plutusmap_keys(this.__wbg_ptr);
        return PlutusDataList.__wrap(ret);
    }
}

const PlutusScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusscript_free(ptr >>> 0, 1));
/**
 * Version-agnostic Plutus script
 */
export class PlutusScript {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusScript.prototype);
        obj.__wbg_ptr = ptr;
        PlutusScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusscript_free(ptr, 0);
    }
    /**
     * @param {PlutusV1Script} script
     * @returns {PlutusScript}
     */
    static from_v1(script) {
        _assertClass(script, PlutusV1Script);
        const ret = wasm.plutusscript_from_v1(script.__wbg_ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
     * @param {PlutusV2Script} script
     * @returns {PlutusScript}
     */
    static from_v2(script) {
        _assertClass(script, PlutusV2Script);
        const ret = wasm.plutusscript_from_v2(script.__wbg_ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
     * @param {PlutusV3Script} script
     * @returns {PlutusScript}
     */
    static from_v3(script) {
        _assertClass(script, PlutusV3Script);
        const ret = wasm.plutusscript_from_v3(script.__wbg_ptr);
        return PlutusScript.__wrap(ret);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.plutusscript_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     * @returns {PlutusV1Script | undefined}
     */
    as_v1() {
        const ret = wasm.plutusscript_as_v1(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV1Script.__wrap(ret);
    }
    /**
     * @returns {PlutusV2Script | undefined}
     */
    as_v2() {
        const ret = wasm.plutusscript_as_v2(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV2Script.__wrap(ret);
    }
    /**
     * @returns {PlutusV3Script | undefined}
     */
    as_v3() {
        const ret = wasm.plutusscript_as_v3(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV3Script.__wrap(ret);
    }
    /**
     * @returns {Language}
     */
    version() {
        const ret = wasm.plutusscript_version(this.__wbg_ptr);
        return ret;
    }
}

const PlutusScriptWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusscriptwitness_free(ptr >>> 0, 1));

export class PlutusScriptWitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusScriptWitness.prototype);
        obj.__wbg_ptr = ptr;
        PlutusScriptWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusScriptWitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusscriptwitness_free(ptr, 0);
    }
    /**
     * @param {PlutusScript} script
     * @returns {PlutusScriptWitness}
     */
    static new_script(script) {
        _assertClass(script, PlutusScript);
        const ret = wasm.plutusscriptwitness_new_script(script.__wbg_ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
     * @param {ScriptHash} hash
     * @returns {PlutusScriptWitness}
     */
    static new_ref(hash) {
        _assertClass(hash, ScriptHash);
        const ret = wasm.plutusscriptwitness_new_ref(hash.__wbg_ptr);
        return PlutusScriptWitness.__wrap(ret);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.plutusscriptwitness_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
}

const PlutusV1ScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv1script_free(ptr >>> 0, 1));

export class PlutusV1Script {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV1Script.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV1ScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV1ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv1script_free(ptr, 0);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.plutusv1script_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.plutusv1script_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {PlutusV1Script}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv1script_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV1Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv1script_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {PlutusV1Script}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv1script_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV1Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.plutusv1script_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.plutusv1script_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PlutusV1Script}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv1script_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV1Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv1script_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv1script_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PlutusV1Script}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv1script_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV1Script.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.plutusv1script_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.plutusv1script_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PlutusV1Script}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv1script_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV1Script.__wrap(ret[0]);
    }
}

const PlutusV1ScriptListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv1scriptlist_free(ptr >>> 0, 1));

export class PlutusV1ScriptList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV1ScriptList.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV1ScriptListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV1ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv1scriptlist_free(ptr, 0);
    }
    /**
     * @returns {PlutusV1ScriptList}
     */
    static new() {
        const ret = wasm.plutusv1scriptlist_new();
        return PlutusV1ScriptList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.plutusv1scriptlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {PlutusV1Script}
     */
    get(index) {
        const ret = wasm.plutusv1scriptlist_get(this.__wbg_ptr, index);
        return PlutusV1Script.__wrap(ret);
    }
    /**
     * @param {PlutusV1Script} elem
     */
    add(elem) {
        _assertClass(elem, PlutusV1Script);
        wasm.plutusv1scriptlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const PlutusV2ScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv2script_free(ptr >>> 0, 1));

export class PlutusV2Script {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV2Script.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV2ScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV2ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv2script_free(ptr, 0);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.plutusv2script_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.plutusv2script_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {PlutusV2Script}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv2script_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV2Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv2script_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {PlutusV2Script}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv2script_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV2Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.plutusv2script_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.plutusv2script_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PlutusV2Script}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv2script_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV2Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv2script_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv2script_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PlutusV2Script}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv2script_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV2Script.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.plutusv2script_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.plutusv2script_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PlutusV2Script}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv2script_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV2Script.__wrap(ret[0]);
    }
}

const PlutusV2ScriptListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv2scriptlist_free(ptr >>> 0, 1));

export class PlutusV2ScriptList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV2ScriptList.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV2ScriptListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV2ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv2scriptlist_free(ptr, 0);
    }
    /**
     * @returns {PlutusV2ScriptList}
     */
    static new() {
        const ret = wasm.plutusv2scriptlist_new();
        return PlutusV2ScriptList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.plutusv2scriptlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {PlutusV2Script}
     */
    get(index) {
        const ret = wasm.plutusv2scriptlist_get(this.__wbg_ptr, index);
        return PlutusV2Script.__wrap(ret);
    }
    /**
     * @param {PlutusV2Script} elem
     */
    add(elem) {
        _assertClass(elem, PlutusV2Script);
        wasm.plutusv2scriptlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const PlutusV3ScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv3script_free(ptr >>> 0, 1));

export class PlutusV3Script {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV3Script.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV3ScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV3ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv3script_free(ptr, 0);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.plutusv3script_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.plutusv3script_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {PlutusV3Script}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv3script_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV3Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv3script_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {PlutusV3Script}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv3script_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV3Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.plutusv3script_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.plutusv3script_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PlutusV3Script}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv3script_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV3Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv3script_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.plutusv3script_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PlutusV3Script}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv3script_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV3Script.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.plutusv3script_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.plutusv3script_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PlutusV3Script}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.plutusv3script_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PlutusV3Script.__wrap(ret[0]);
    }
}

const PlutusV3ScriptListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_plutusv3scriptlist_free(ptr >>> 0, 1));

export class PlutusV3ScriptList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PlutusV3ScriptList.prototype);
        obj.__wbg_ptr = ptr;
        PlutusV3ScriptListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PlutusV3ScriptListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_plutusv3scriptlist_free(ptr, 0);
    }
    /**
     * @returns {PlutusV3ScriptList}
     */
    static new() {
        const ret = wasm.plutusv3scriptlist_new();
        return PlutusV3ScriptList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.plutusv3scriptlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {PlutusV3Script}
     */
    get(index) {
        const ret = wasm.plutusv3scriptlist_get(this.__wbg_ptr, index);
        return PlutusV3Script.__wrap(ret);
    }
    /**
     * @param {PlutusV3Script} elem
     */
    add(elem) {
        _assertClass(elem, PlutusV3Script);
        wasm.plutusv3scriptlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const PointerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_pointer_free(ptr >>> 0, 1));

export class Pointer {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Pointer.prototype);
        obj.__wbg_ptr = ptr;
        PointerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PointerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pointer_free(ptr, 0);
    }
}

const PointerAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_pointeraddress_free(ptr >>> 0, 1));

export class PointerAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PointerAddress.prototype);
        obj.__wbg_ptr = ptr;
        PointerAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PointerAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pointeraddress_free(ptr, 0);
    }
    /**
     * @param {number} network
     * @param {Credential} payment
     * @param {Pointer} stake
     * @returns {PointerAddress}
     */
    static new(network, payment, stake) {
        _assertClass(payment, Credential);
        _assertClass(stake, Pointer);
        const ret = wasm.pointeraddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);
        return PointerAddress.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    to_address() {
        const ret = wasm.pointeraddress_to_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @returns {PointerAddress | undefined}
     */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.pointeraddress_from_address(address.__wbg_ptr);
        return ret === 0 ? undefined : PointerAddress.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.pointeraddress_network_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Credential}
     */
    payment() {
        const ret = wasm.pointeraddress_payment(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Pointer}
     */
    stake() {
        const ret = wasm.pointeraddress_stake(this.__wbg_ptr);
        return Pointer.__wrap(ret);
    }
}

const PolicyIdListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_policyidlist_free(ptr >>> 0, 1));

export class PolicyIdList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PolicyIdList.prototype);
        obj.__wbg_ptr = ptr;
        PolicyIdListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PolicyIdListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_policyidlist_free(ptr, 0);
    }
    /**
     * @returns {PolicyIdList}
     */
    static new() {
        const ret = wasm.policyidlist_new();
        return PolicyIdList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.policyidlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {ScriptHash}
     */
    get(index) {
        const ret = wasm.policyidlist_get(this.__wbg_ptr, index);
        return ScriptHash.__wrap(ret);
    }
    /**
     * @param {ScriptHash} elem
     */
    add(elem) {
        _assertClass(elem, ScriptHash);
        wasm.policyidlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const PoolMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolmetadata_free(ptr >>> 0, 1));

export class PoolMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolMetadata.prototype);
        obj.__wbg_ptr = ptr;
        PoolMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolmetadata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.poolmetadata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.poolmetadata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PoolMetadata}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadata.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolmetadata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolmetadata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PoolMetadata}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadata.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.poolmetadata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.poolmetadata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PoolMetadata}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadata.__wrap(ret[0]);
    }
    /**
     * @returns {Url}
     */
    url() {
        const ret = wasm.poolmetadata_url(this.__wbg_ptr);
        return Url.__wrap(ret);
    }
    /**
     * @returns {PoolMetadataHash}
     */
    pool_metadata_hash() {
        const ret = wasm.poolmetadata_pool_metadata_hash(this.__wbg_ptr);
        return PoolMetadataHash.__wrap(ret);
    }
    /**
     * @param {Url} url
     * @param {PoolMetadataHash} pool_metadata_hash
     * @returns {PoolMetadata}
     */
    static new(url, pool_metadata_hash) {
        _assertClass(url, Url);
        _assertClass(pool_metadata_hash, PoolMetadataHash);
        const ret = wasm.poolmetadata_new(url.__wbg_ptr, pool_metadata_hash.__wbg_ptr);
        return PoolMetadata.__wrap(ret);
    }
}

const PoolMetadataHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolmetadatahash_free(ptr >>> 0, 1));

export class PoolMetadataHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolMetadataHash.prototype);
        obj.__wbg_ptr = ptr;
        PoolMetadataHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolMetadataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolmetadatahash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.poolmetadatahash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {PoolMetadataHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadatahash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.poolmetadatahash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {PoolMetadataHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadatahash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolmetadatahash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {PoolMetadataHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolmetadatahash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolMetadataHash.__wrap(ret[0]);
    }
}

const PoolParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolparams_free(ptr >>> 0, 1));

export class PoolParams {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolParams.prototype);
        obj.__wbg_ptr = ptr;
        PoolParamsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolparams_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.poolparams_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.poolparams_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PoolParams}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolparams_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolParams.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolparams_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolparams_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PoolParams}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolparams_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolParams.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.poolparams_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.poolparams_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PoolParams}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolparams_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolParams.__wrap(ret[0]);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    operator() {
        const ret = wasm.poolparams_operator(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {VRFKeyHash}
     */
    vrf_keyhash() {
        const ret = wasm.poolparams_vrf_keyhash(this.__wbg_ptr);
        return VRFKeyHash.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    pledge() {
        const ret = wasm.poolparams_pledge(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    cost() {
        const ret = wasm.poolparams_cost(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {UnitInterval}
     */
    margin() {
        const ret = wasm.poolparams_margin(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {RewardAddress}
     */
    reward_account() {
        const ret = wasm.poolparams_reward_account(this.__wbg_ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHashList}
     */
    pool_owners() {
        const ret = wasm.poolparams_pool_owners(this.__wbg_ptr);
        return Ed25519KeyHashList.__wrap(ret);
    }
    /**
     * @returns {RelayList}
     */
    relays() {
        const ret = wasm.poolparams_relays(this.__wbg_ptr);
        return RelayList.__wrap(ret);
    }
    /**
     * @returns {PoolMetadata | undefined}
     */
    pool_metadata() {
        const ret = wasm.poolparams_pool_metadata(this.__wbg_ptr);
        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} operator
     * @param {VRFKeyHash} vrf_keyhash
     * @param {bigint} pledge
     * @param {bigint} cost
     * @param {UnitInterval} margin
     * @param {RewardAddress} reward_account
     * @param {Ed25519KeyHashList} pool_owners
     * @param {RelayList} relays
     * @param {PoolMetadata | null} [pool_metadata]
     * @returns {PoolParams}
     */
    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {
        _assertClass(operator, Ed25519KeyHash);
        _assertClass(vrf_keyhash, VRFKeyHash);
        _assertClass(margin, UnitInterval);
        _assertClass(reward_account, RewardAddress);
        _assertClass(pool_owners, Ed25519KeyHashList);
        _assertClass(relays, RelayList);
        let ptr0 = 0;
        if (!isLikeNone(pool_metadata)) {
            _assertClass(pool_metadata, PoolMetadata);
            ptr0 = pool_metadata.__destroy_into_raw();
        }
        const ret = wasm.poolparams_new(operator.__wbg_ptr, vrf_keyhash.__wbg_ptr, pledge, cost, margin.__wbg_ptr, reward_account.__wbg_ptr, pool_owners.__wbg_ptr, relays.__wbg_ptr, ptr0);
        return PoolParams.__wrap(ret);
    }
}

const PoolRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolregistration_free(ptr >>> 0, 1));

export class PoolRegistration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolRegistration.prototype);
        obj.__wbg_ptr = ptr;
        PoolRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolregistration_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.poolregistration_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.poolregistration_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PoolRegistration}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolregistration_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRegistration.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolregistration_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolregistration_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PoolRegistration}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolregistration_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.poolregistration_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.poolregistration_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PoolRegistration}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolregistration_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {PoolParams}
     */
    pool_params() {
        const ret = wasm.poolregistration_pool_params(this.__wbg_ptr);
        return PoolParams.__wrap(ret);
    }
    /**
     * @param {PoolParams} pool_params
     * @returns {PoolRegistration}
     */
    static new(pool_params) {
        _assertClass(pool_params, PoolParams);
        const ret = wasm.poolregistration_new(pool_params.__wbg_ptr);
        return PoolRegistration.__wrap(ret);
    }
}

const PoolRetirementFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolretirement_free(ptr >>> 0, 1));

export class PoolRetirement {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolRetirement.prototype);
        obj.__wbg_ptr = ptr;
        PoolRetirementFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolRetirementFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolretirement_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.poolretirement_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.poolretirement_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PoolRetirement}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolretirement_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRetirement.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolretirement_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolretirement_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PoolRetirement}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolretirement_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRetirement.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.poolretirement_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.poolretirement_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PoolRetirement}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolretirement_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolRetirement.__wrap(ret[0]);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    pool() {
        const ret = wasm.poolretirement_pool(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    epoch() {
        const ret = wasm.poolretirement_epoch(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Ed25519KeyHash} pool
     * @param {bigint} epoch
     * @returns {PoolRetirement}
     */
    static new(pool, epoch) {
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.poolretirement_new(pool.__wbg_ptr, epoch);
        return PoolRetirement.__wrap(ret);
    }
}

const PoolVotingThresholdsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_poolvotingthresholds_free(ptr >>> 0, 1));

export class PoolVotingThresholds {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PoolVotingThresholds.prototype);
        obj.__wbg_ptr = ptr;
        PoolVotingThresholdsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoolVotingThresholdsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_poolvotingthresholds_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.poolvotingthresholds_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.poolvotingthresholds_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {PoolVotingThresholds}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolvotingthresholds_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolVotingThresholds.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolvotingthresholds_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.poolvotingthresholds_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {PoolVotingThresholds}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolvotingthresholds_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolVotingThresholds.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.poolvotingthresholds_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.poolvotingthresholds_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {PoolVotingThresholds}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.poolvotingthresholds_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PoolVotingThresholds.__wrap(ret[0]);
    }
    /**
     * @returns {UnitInterval}
     */
    motion_no_confidence() {
        const ret = wasm.poolvotingthresholds_motion_no_confidence(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    committee_normal() {
        const ret = wasm.poolvotingthresholds_committee_normal(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    committee_no_confidence() {
        const ret = wasm.poolvotingthresholds_committee_no_confidence(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    hard_fork_initiation() {
        const ret = wasm.poolvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    security_relevant_parameter_voting_threshold() {
        const ret = wasm.poolvotingthresholds_security_relevant_parameter_voting_threshold(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @param {UnitInterval} motion_no_confidence
     * @param {UnitInterval} committee_normal
     * @param {UnitInterval} committee_no_confidence
     * @param {UnitInterval} hard_fork_initiation
     * @param {UnitInterval} security_relevant_parameter_voting_threshold
     * @returns {PoolVotingThresholds}
     */
    static new(motion_no_confidence, committee_normal, committee_no_confidence, hard_fork_initiation, security_relevant_parameter_voting_threshold) {
        _assertClass(motion_no_confidence, UnitInterval);
        _assertClass(committee_normal, UnitInterval);
        _assertClass(committee_no_confidence, UnitInterval);
        _assertClass(hard_fork_initiation, UnitInterval);
        _assertClass(security_relevant_parameter_voting_threshold, UnitInterval);
        const ret = wasm.poolvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, hard_fork_initiation.__wbg_ptr, security_relevant_parameter_voting_threshold.__wbg_ptr);
        return PoolVotingThresholds.__wrap(ret);
    }
}

const PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_privatekey_free(ptr >>> 0, 1));

export class PrivateKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrivateKey.prototype);
        obj.__wbg_ptr = ptr;
        PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privatekey_free(ptr, 0);
    }
    /**
     * @returns {PublicKey}
     */
    to_public() {
        const ret = wasm.privatekey_to_public(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {PrivateKey}
     */
    static generate_ed25519() {
        const ret = wasm.privatekey_generate_ed25519();
        return PrivateKey.__wrap(ret);
    }
    /**
     * @returns {PrivateKey}
     */
    static generate_ed25519extended() {
        const ret = wasm.privatekey_generate_ed25519extended();
        return PrivateKey.__wrap(ret);
    }
    /**
     * Get private key from its bech32 representation
     * ```javascript
     * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);
     * ```
     * For an extended 25519 key
     * ```javascript
     * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);
     * ```
     * @param {string} bech32_str
     * @returns {PrivateKey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_bech32() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.privatekey_to_bech32(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.privatekey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {PrivateKey}
     */
    static from_extended_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_from_extended_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {PrivateKey}
     */
    static from_normal_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_from_normal_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PrivateKey.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} message
     * @returns {Ed25519Signature}
     */
    sign(message) {
        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);
        return Ed25519Signature.__wrap(ret);
    }
}

const ProposalBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proposalbuilder_free(ptr >>> 0, 1));

export class ProposalBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProposalBuilder.prototype);
        obj.__wbg_ptr = ptr;
        ProposalBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProposalBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalbuilder_free(ptr, 0);
    }
    /**
     * @returns {ProposalBuilder}
     */
    static new() {
        const ret = wasm.proposalbuilder_new();
        return ProposalBuilder.__wrap(ret);
    }
    /**
     * @param {ProposalProcedure} proposal
     * @returns {ProposalBuilder}
     */
    with_proposal(proposal) {
        _assertClass(proposal, ProposalProcedure);
        var ptr0 = proposal.__destroy_into_raw();
        const ret = wasm.proposalbuilder_with_proposal(this.__wbg_ptr, ptr0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalBuilder.__wrap(ret[0]);
    }
    /**
     * @param {ProposalProcedure} proposal
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {ProposalBuilder}
     */
    with_native_script_proposal(proposal, native_script, witness_info) {
        _assertClass(proposal, ProposalProcedure);
        var ptr0 = proposal.__destroy_into_raw();
        _assertClass(native_script, NativeScript);
        var ptr1 = native_script.__destroy_into_raw();
        _assertClass(witness_info, NativeScriptWitnessInfo);
        var ptr2 = witness_info.__destroy_into_raw();
        const ret = wasm.proposalbuilder_with_native_script_proposal(this.__wbg_ptr, ptr0, ptr1, ptr2);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalBuilder.__wrap(ret[0]);
    }
    /**
     * @param {ProposalProcedure} proposal
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @param {PlutusData} datum
     * @returns {ProposalBuilder}
     */
    with_plutus_proposal(proposal, partial_witness, required_signers, datum) {
        _assertClass(proposal, ProposalProcedure);
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        _assertClass(datum, PlutusData);
        const ret = wasm.proposalbuilder_with_plutus_proposal(this.__wbg_ptr, proposal.__wbg_ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr, datum.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalBuilder.__wrap(ret[0]);
    }
    /**
     * @param {ProposalProcedure} proposal
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {ProposalBuilder}
     */
    with_plutus_proposal_inline_datum(proposal, partial_witness, required_signers) {
        _assertClass(proposal, ProposalProcedure);
        var ptr0 = proposal.__destroy_into_raw();
        _assertClass(partial_witness, PartialPlutusWitness);
        var ptr1 = partial_witness.__destroy_into_raw();
        _assertClass(required_signers, Ed25519KeyHashList);
        var ptr2 = required_signers.__destroy_into_raw();
        const ret = wasm.proposalbuilder_with_plutus_proposal_inline_datum(this.__wbg_ptr, ptr0, ptr1, ptr2);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {ProposalBuilderResult}
     */
    build() {
        const ret = wasm.proposalbuilder_build(this.__wbg_ptr);
        return ProposalBuilderResult.__wrap(ret);
    }
}

const ProposalBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proposalbuilderresult_free(ptr >>> 0, 1));

export class ProposalBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProposalBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        ProposalBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProposalBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalbuilderresult_free(ptr, 0);
    }
}

const ProposalProcedureFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proposalprocedure_free(ptr >>> 0, 1));

export class ProposalProcedure {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProposalProcedure.prototype);
        obj.__wbg_ptr = ptr;
        ProposalProcedureFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProposalProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalprocedure_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.proposalprocedure_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.proposalprocedure_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ProposalProcedure}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.proposalprocedure_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalProcedure.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.proposalprocedure_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.proposalprocedure_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ProposalProcedure}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.proposalprocedure_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalProcedure.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.proposalprocedure_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.proposalprocedure_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ProposalProcedure}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.proposalprocedure_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProposalProcedure.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.proposalprocedure_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {RewardAddress}
     */
    reward_account() {
        const ret = wasm.proposalprocedure_reward_account(this.__wbg_ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
     * @returns {GovAction}
     */
    gov_action() {
        const ret = wasm.proposalprocedure_gov_action(this.__wbg_ptr);
        return GovAction.__wrap(ret);
    }
    /**
     * @returns {Anchor}
     */
    anchor() {
        const ret = wasm.proposalprocedure_anchor(this.__wbg_ptr);
        return Anchor.__wrap(ret);
    }
    /**
     * @param {bigint} deposit
     * @param {RewardAddress} reward_account
     * @param {GovAction} gov_action
     * @param {Anchor} anchor
     * @returns {ProposalProcedure}
     */
    static new(deposit, reward_account, gov_action, anchor) {
        _assertClass(reward_account, RewardAddress);
        _assertClass(gov_action, GovAction);
        _assertClass(anchor, Anchor);
        const ret = wasm.proposalprocedure_new(deposit, reward_account.__wbg_ptr, gov_action.__wbg_ptr, anchor.__wbg_ptr);
        return ProposalProcedure.__wrap(ret);
    }
}

const ProposalProcedureListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_proposalprocedurelist_free(ptr >>> 0, 1));

export class ProposalProcedureList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProposalProcedureList.prototype);
        obj.__wbg_ptr = ptr;
        ProposalProcedureListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProposalProcedureListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_proposalprocedurelist_free(ptr, 0);
    }
    /**
     * @returns {ProposalProcedureList}
     */
    static new() {
        const ret = wasm.proposalprocedurelist_new();
        return ProposalProcedureList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.proposalprocedurelist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {ProposalProcedure}
     */
    get(index) {
        const ret = wasm.proposalprocedurelist_get(this.__wbg_ptr, index);
        return ProposalProcedure.__wrap(ret);
    }
    /**
     * @param {ProposalProcedure} elem
     */
    add(elem) {
        _assertClass(elem, ProposalProcedure);
        wasm.proposalprocedurelist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const ProtocolMagicFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protocolmagic_free(ptr >>> 0, 1));

export class ProtocolMagic {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProtocolMagic.prototype);
        obj.__wbg_ptr = ptr;
        ProtocolMagicFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProtocolMagicFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolmagic_free(ptr, 0);
    }
    /**
     * @param {number} pm
     * @returns {ProtocolMagic}
     */
    static new(pm) {
        const ret = wasm.protocolmagic_new(pm);
        return ProtocolMagic.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    to_int() {
        const ret = wasm.protocolmagic_to_int(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const ProtocolParamUpdateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protocolparamupdate_free(ptr >>> 0, 1));

export class ProtocolParamUpdate {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProtocolParamUpdate.prototype);
        obj.__wbg_ptr = ptr;
        ProtocolParamUpdateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProtocolParamUpdateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolparamupdate_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.protocolparamupdate_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.protocolparamupdate_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ProtocolParamUpdate}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolparamupdate_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolParamUpdate.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.protocolparamupdate_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.protocolparamupdate_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ProtocolParamUpdate}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolparamupdate_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolParamUpdate.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.protocolparamupdate_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.protocolparamupdate_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ProtocolParamUpdate}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolparamupdate_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolParamUpdate.__wrap(ret[0]);
    }
    /**
     * @param {bigint} minfee_a
     */
    set_minfee_a(minfee_a) {
        wasm.protocolparamupdate_set_minfee_a(this.__wbg_ptr, minfee_a);
    }
    /**
     * @returns {bigint | undefined}
     */
    minfee_a() {
        const ret = wasm.protocolparamupdate_minfee_a(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} minfee_b
     */
    set_minfee_b(minfee_b) {
        wasm.protocolparamupdate_set_minfee_b(this.__wbg_ptr, minfee_b);
    }
    /**
     * @returns {bigint | undefined}
     */
    minfee_b() {
        const ret = wasm.protocolparamupdate_minfee_b(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} max_block_body_size
     */
    set_max_block_body_size(max_block_body_size) {
        wasm.protocolparamupdate_set_max_block_body_size(this.__wbg_ptr, max_block_body_size);
    }
    /**
     * @returns {bigint | undefined}
     */
    max_block_body_size() {
        const ret = wasm.protocolparamupdate_max_block_body_size(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} max_transaction_size
     */
    set_max_transaction_size(max_transaction_size) {
        wasm.protocolparamupdate_set_max_transaction_size(this.__wbg_ptr, max_transaction_size);
    }
    /**
     * @returns {bigint | undefined}
     */
    max_transaction_size() {
        const ret = wasm.protocolparamupdate_max_transaction_size(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} max_block_header_size
     */
    set_max_block_header_size(max_block_header_size) {
        wasm.protocolparamupdate_set_max_block_header_size(this.__wbg_ptr, max_block_header_size);
    }
    /**
     * @returns {bigint | undefined}
     */
    max_block_header_size() {
        const ret = wasm.protocolparamupdate_max_block_header_size(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} key_deposit
     */
    set_key_deposit(key_deposit) {
        wasm.protocolparamupdate_set_key_deposit(this.__wbg_ptr, key_deposit);
    }
    /**
     * @returns {bigint | undefined}
     */
    key_deposit() {
        const ret = wasm.protocolparamupdate_key_deposit(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} pool_deposit
     */
    set_pool_deposit(pool_deposit) {
        wasm.protocolparamupdate_set_pool_deposit(this.__wbg_ptr, pool_deposit);
    }
    /**
     * @returns {bigint | undefined}
     */
    pool_deposit() {
        const ret = wasm.protocolparamupdate_pool_deposit(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} maximum_epoch
     */
    set_maximum_epoch(maximum_epoch) {
        wasm.protocolparamupdate_set_maximum_epoch(this.__wbg_ptr, maximum_epoch);
    }
    /**
     * @returns {bigint | undefined}
     */
    maximum_epoch() {
        const ret = wasm.protocolparamupdate_maximum_epoch(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} n_opt
     */
    set_n_opt(n_opt) {
        wasm.protocolparamupdate_set_n_opt(this.__wbg_ptr, n_opt);
    }
    /**
     * @returns {bigint | undefined}
     */
    n_opt() {
        const ret = wasm.protocolparamupdate_n_opt(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {Rational} pool_pledge_influence
     */
    set_pool_pledge_influence(pool_pledge_influence) {
        _assertClass(pool_pledge_influence, Rational);
        wasm.protocolparamupdate_set_pool_pledge_influence(this.__wbg_ptr, pool_pledge_influence.__wbg_ptr);
    }
    /**
     * @returns {Rational | undefined}
     */
    pool_pledge_influence() {
        const ret = wasm.protocolparamupdate_pool_pledge_influence(this.__wbg_ptr);
        return ret === 0 ? undefined : Rational.__wrap(ret);
    }
    /**
     * @param {UnitInterval} expansion_rate
     */
    set_expansion_rate(expansion_rate) {
        _assertClass(expansion_rate, UnitInterval);
        wasm.protocolparamupdate_set_expansion_rate(this.__wbg_ptr, expansion_rate.__wbg_ptr);
    }
    /**
     * @returns {UnitInterval | undefined}
     */
    expansion_rate() {
        const ret = wasm.protocolparamupdate_expansion_rate(this.__wbg_ptr);
        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
    }
    /**
     * @param {UnitInterval} treasury_growth_rate
     */
    set_treasury_growth_rate(treasury_growth_rate) {
        _assertClass(treasury_growth_rate, UnitInterval);
        wasm.protocolparamupdate_set_treasury_growth_rate(this.__wbg_ptr, treasury_growth_rate.__wbg_ptr);
    }
    /**
     * @returns {UnitInterval | undefined}
     */
    treasury_growth_rate() {
        const ret = wasm.protocolparamupdate_treasury_growth_rate(this.__wbg_ptr);
        return ret === 0 ? undefined : UnitInterval.__wrap(ret);
    }
    /**
     * @param {bigint} min_pool_cost
     */
    set_min_pool_cost(min_pool_cost) {
        wasm.protocolparamupdate_set_min_pool_cost(this.__wbg_ptr, min_pool_cost);
    }
    /**
     * @returns {bigint | undefined}
     */
    min_pool_cost() {
        const ret = wasm.protocolparamupdate_min_pool_cost(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} ada_per_utxo_byte
     */
    set_ada_per_utxo_byte(ada_per_utxo_byte) {
        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.__wbg_ptr, ada_per_utxo_byte);
    }
    /**
     * @returns {bigint | undefined}
     */
    ada_per_utxo_byte() {
        const ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {CostModels} cost_models_for_script_languages
     */
    set_cost_models_for_script_languages(cost_models_for_script_languages) {
        _assertClass(cost_models_for_script_languages, CostModels);
        wasm.protocolparamupdate_set_cost_models_for_script_languages(this.__wbg_ptr, cost_models_for_script_languages.__wbg_ptr);
    }
    /**
     * @returns {CostModels | undefined}
     */
    cost_models_for_script_languages() {
        const ret = wasm.protocolparamupdate_cost_models_for_script_languages(this.__wbg_ptr);
        return ret === 0 ? undefined : CostModels.__wrap(ret);
    }
    /**
     * @param {ExUnitPrices} execution_costs
     */
    set_execution_costs(execution_costs) {
        _assertClass(execution_costs, ExUnitPrices);
        wasm.protocolparamupdate_set_execution_costs(this.__wbg_ptr, execution_costs.__wbg_ptr);
    }
    /**
     * @returns {ExUnitPrices | undefined}
     */
    execution_costs() {
        const ret = wasm.protocolparamupdate_execution_costs(this.__wbg_ptr);
        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);
    }
    /**
     * @param {ExUnits} max_tx_ex_units
     */
    set_max_tx_ex_units(max_tx_ex_units) {
        _assertClass(max_tx_ex_units, ExUnits);
        wasm.protocolparamupdate_set_max_tx_ex_units(this.__wbg_ptr, max_tx_ex_units.__wbg_ptr);
    }
    /**
     * @returns {ExUnits | undefined}
     */
    max_tx_ex_units() {
        const ret = wasm.protocolparamupdate_max_tx_ex_units(this.__wbg_ptr);
        return ret === 0 ? undefined : ExUnits.__wrap(ret);
    }
    /**
     * @param {ExUnits} max_block_ex_units
     */
    set_max_block_ex_units(max_block_ex_units) {
        _assertClass(max_block_ex_units, ExUnits);
        wasm.protocolparamupdate_set_max_block_ex_units(this.__wbg_ptr, max_block_ex_units.__wbg_ptr);
    }
    /**
     * @returns {ExUnits | undefined}
     */
    max_block_ex_units() {
        const ret = wasm.protocolparamupdate_max_block_ex_units(this.__wbg_ptr);
        return ret === 0 ? undefined : ExUnits.__wrap(ret);
    }
    /**
     * @param {bigint} max_value_size
     */
    set_max_value_size(max_value_size) {
        wasm.protocolparamupdate_set_max_value_size(this.__wbg_ptr, max_value_size);
    }
    /**
     * @returns {bigint | undefined}
     */
    max_value_size() {
        const ret = wasm.protocolparamupdate_max_value_size(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} collateral_percentage
     */
    set_collateral_percentage(collateral_percentage) {
        wasm.protocolparamupdate_set_collateral_percentage(this.__wbg_ptr, collateral_percentage);
    }
    /**
     * @returns {bigint | undefined}
     */
    collateral_percentage() {
        const ret = wasm.protocolparamupdate_collateral_percentage(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} max_collateral_inputs
     */
    set_max_collateral_inputs(max_collateral_inputs) {
        wasm.protocolparamupdate_set_max_collateral_inputs(this.__wbg_ptr, max_collateral_inputs);
    }
    /**
     * @returns {bigint | undefined}
     */
    max_collateral_inputs() {
        const ret = wasm.protocolparamupdate_max_collateral_inputs(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {PoolVotingThresholds} pool_voting_thresholds
     */
    set_pool_voting_thresholds(pool_voting_thresholds) {
        _assertClass(pool_voting_thresholds, PoolVotingThresholds);
        wasm.protocolparamupdate_set_pool_voting_thresholds(this.__wbg_ptr, pool_voting_thresholds.__wbg_ptr);
    }
    /**
     * @returns {PoolVotingThresholds | undefined}
     */
    pool_voting_thresholds() {
        const ret = wasm.protocolparamupdate_pool_voting_thresholds(this.__wbg_ptr);
        return ret === 0 ? undefined : PoolVotingThresholds.__wrap(ret);
    }
    /**
     * @param {DRepVotingThresholds} d_rep_voting_thresholds
     */
    set_d_rep_voting_thresholds(d_rep_voting_thresholds) {
        _assertClass(d_rep_voting_thresholds, DRepVotingThresholds);
        wasm.protocolparamupdate_set_d_rep_voting_thresholds(this.__wbg_ptr, d_rep_voting_thresholds.__wbg_ptr);
    }
    /**
     * @returns {DRepVotingThresholds | undefined}
     */
    d_rep_voting_thresholds() {
        const ret = wasm.protocolparamupdate_d_rep_voting_thresholds(this.__wbg_ptr);
        return ret === 0 ? undefined : DRepVotingThresholds.__wrap(ret);
    }
    /**
     * @param {bigint} min_committee_size
     */
    set_min_committee_size(min_committee_size) {
        wasm.protocolparamupdate_set_min_committee_size(this.__wbg_ptr, min_committee_size);
    }
    /**
     * @returns {bigint | undefined}
     */
    min_committee_size() {
        const ret = wasm.protocolparamupdate_min_committee_size(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} committee_term_limit
     */
    set_committee_term_limit(committee_term_limit) {
        wasm.protocolparamupdate_set_committee_term_limit(this.__wbg_ptr, committee_term_limit);
    }
    /**
     * @returns {bigint | undefined}
     */
    committee_term_limit() {
        const ret = wasm.protocolparamupdate_committee_term_limit(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} governance_action_validity_period
     */
    set_governance_action_validity_period(governance_action_validity_period) {
        wasm.protocolparamupdate_set_governance_action_validity_period(this.__wbg_ptr, governance_action_validity_period);
    }
    /**
     * @returns {bigint | undefined}
     */
    governance_action_validity_period() {
        const ret = wasm.protocolparamupdate_governance_action_validity_period(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} governance_action_deposit
     */
    set_governance_action_deposit(governance_action_deposit) {
        wasm.protocolparamupdate_set_governance_action_deposit(this.__wbg_ptr, governance_action_deposit);
    }
    /**
     * @returns {bigint | undefined}
     */
    governance_action_deposit() {
        const ret = wasm.protocolparamupdate_governance_action_deposit(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} d_rep_deposit
     */
    set_d_rep_deposit(d_rep_deposit) {
        wasm.protocolparamupdate_set_d_rep_deposit(this.__wbg_ptr, d_rep_deposit);
    }
    /**
     * @returns {bigint | undefined}
     */
    d_rep_deposit() {
        const ret = wasm.protocolparamupdate_d_rep_deposit(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} d_rep_inactivity_period
     */
    set_d_rep_inactivity_period(d_rep_inactivity_period) {
        wasm.protocolparamupdate_set_d_rep_inactivity_period(this.__wbg_ptr, d_rep_inactivity_period);
    }
    /**
     * @returns {bigint | undefined}
     */
    d_rep_inactivity_period() {
        const ret = wasm.protocolparamupdate_d_rep_inactivity_period(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {Rational} min_fee_ref_script_cost_per_byte
     */
    set_min_fee_ref_script_cost_per_byte(min_fee_ref_script_cost_per_byte) {
        _assertClass(min_fee_ref_script_cost_per_byte, Rational);
        wasm.protocolparamupdate_set_min_fee_ref_script_cost_per_byte(this.__wbg_ptr, min_fee_ref_script_cost_per_byte.__wbg_ptr);
    }
    /**
     * @returns {Rational | undefined}
     */
    min_fee_ref_script_cost_per_byte() {
        const ret = wasm.protocolparamupdate_min_fee_ref_script_cost_per_byte(this.__wbg_ptr);
        return ret === 0 ? undefined : Rational.__wrap(ret);
    }
    /**
     * @returns {ProtocolParamUpdate}
     */
    static new() {
        const ret = wasm.protocolparamupdate_new();
        return ProtocolParamUpdate.__wrap(ret);
    }
}

const ProtocolVersionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_protocolversion_free(ptr >>> 0, 1));

export class ProtocolVersion {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProtocolVersion.prototype);
        obj.__wbg_ptr = ptr;
        ProtocolVersionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProtocolVersionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protocolversion_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.protocolversion_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.protocolversion_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ProtocolVersion}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolversion_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersion.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.protocolversion_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.protocolversion_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ProtocolVersion}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolversion_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersion.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.protocolversion_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.protocolversion_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ProtocolVersion}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.protocolversion_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ProtocolVersion.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    major() {
        const ret = wasm.protocolversion_major(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    minor() {
        const ret = wasm.protocolversion_minor(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} major
     * @param {bigint} minor
     * @returns {ProtocolVersion}
     */
    static new(major, minor) {
        const ret = wasm.protocolversion_new(major, minor);
        return ProtocolVersion.__wrap(ret);
    }
}

const PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0, 1));
/**
 * ED25519 key used as public key
 */
export class PublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr, 0);
    }
    /**
     * Get public key from its bech32 representation
     * Example:
     * ```javascript
     * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
     * ```
     * @param {string} bech32_str
     * @returns {PublicKey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.publickey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_bech32() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.publickey_to_bech32(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.publickey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {PublicKey}
     */
    static from_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.publickey_from_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return PublicKey.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} data
     * @param {Ed25519Signature} signature
     * @returns {boolean}
     */
    verify(data, signature) {
        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(signature, Ed25519Signature);
        const ret = wasm.publickey_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    hash() {
        const ret = wasm.publickey_hash(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
}

const RationalFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rational_free(ptr >>> 0, 1));

export class Rational {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Rational.prototype);
        obj.__wbg_ptr = ptr;
        RationalFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RationalFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rational_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.rational_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.rational_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Rational}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.rational_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Rational.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.rational_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.rational_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Rational}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.rational_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Rational.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.rational_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.rational_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Rational}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.rational_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Rational.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    numerator() {
        const ret = wasm.rational_numerator(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    denominator() {
        const ret = wasm.rational_denominator(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} numerator
     * @param {bigint} denominator
     * @returns {Rational}
     */
    static new(numerator, denominator) {
        const ret = wasm.rational_new(numerator, denominator);
        return Rational.__wrap(ret);
    }
}

const RedeemerKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemerkey_free(ptr >>> 0, 1));

export class RedeemerKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RedeemerKey.prototype);
        obj.__wbg_ptr = ptr;
        RedeemerKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemerKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerkey_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.redeemerkey_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.redeemerkey_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {RedeemerKey}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerkey_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerKey.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemerkey_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemerkey_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {RedeemerKey}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerkey_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerKey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.redeemerkey_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.redeemerkey_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {RedeemerKey}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerkey_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerKey.__wrap(ret[0]);
    }
    /**
     * @returns {RedeemerTag}
     */
    tag() {
        const ret = wasm.redeemerkey_tag(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {bigint}
     */
    index() {
        const ret = wasm.redeemerkey_index(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {RedeemerTag} tag
     * @param {bigint} index
     * @returns {RedeemerKey}
     */
    static new(tag, index) {
        const ret = wasm.redeemerkey_new(tag, index);
        return RedeemerKey.__wrap(ret);
    }
}

const RedeemerKeyListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemerkeylist_free(ptr >>> 0, 1));

export class RedeemerKeyList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RedeemerKeyList.prototype);
        obj.__wbg_ptr = ptr;
        RedeemerKeyListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemerKeyListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerkeylist_free(ptr, 0);
    }
    /**
     * @returns {RedeemerKeyList}
     */
    static new() {
        const ret = wasm.redeemerkeylist_new();
        return RedeemerKeyList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.redeemerkeylist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {RedeemerKey}
     */
    get(index) {
        const ret = wasm.redeemerkeylist_get(this.__wbg_ptr, index);
        return RedeemerKey.__wrap(ret);
    }
    /**
     * @param {RedeemerKey} elem
     */
    add(elem) {
        _assertClass(elem, RedeemerKey);
        wasm.redeemerkeylist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const RedeemerSetBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemersetbuilder_free(ptr >>> 0, 1));
/**
 * In order to calculate the index from the sorted set, "add_*" methods in this builder
 * must be called along with the "add_*" methods in transaction builder.
 */
export class RedeemerSetBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RedeemerSetBuilder.prototype);
        obj.__wbg_ptr = ptr;
        RedeemerSetBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemerSetBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemersetbuilder_free(ptr, 0);
    }
    /**
     * @returns {RedeemerSetBuilder}
     */
    static new() {
        const ret = wasm.redeemersetbuilder_new();
        return RedeemerSetBuilder.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm.redeemersetbuilder_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * note: will override existing value if called twice with the same key
     * @param {RedeemerWitnessKey} key
     * @param {ExUnits} ex_units
     */
    update_ex_units(key, ex_units) {
        _assertClass(key, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.redeemersetbuilder_update_ex_units(this.__wbg_ptr, key.__wbg_ptr, ex_units.__wbg_ptr);
    }
    /**
     * @param {InputBuilderResult} result
     */
    add_spend(result) {
        _assertClass(result, InputBuilderResult);
        wasm.redeemersetbuilder_add_spend(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {MintBuilderResult} result
     */
    add_mint(result) {
        _assertClass(result, MintBuilderResult);
        wasm.redeemersetbuilder_add_mint(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {WithdrawalBuilderResult} result
     */
    add_reward(result) {
        _assertClass(result, WithdrawalBuilderResult);
        wasm.redeemersetbuilder_add_reward(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {CertificateBuilderResult} result
     */
    add_cert(result) {
        _assertClass(result, CertificateBuilderResult);
        wasm.redeemersetbuilder_add_cert(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {ProposalBuilderResult} result
     */
    add_proposal(result) {
        _assertClass(result, ProposalBuilderResult);
        wasm.redeemersetbuilder_add_proposal(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {VoteBuilderResult} result
     */
    add_vote(result) {
        _assertClass(result, VoteBuilderResult);
        wasm.redeemersetbuilder_add_vote(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {boolean} default_to_dummy_exunits
     * @returns {Redeemers}
     */
    build(default_to_dummy_exunits) {
        const ret = wasm.redeemersetbuilder_build(this.__wbg_ptr, default_to_dummy_exunits);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Redeemers.__wrap(ret[0]);
    }
}

const RedeemerValFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemerval_free(ptr >>> 0, 1));

export class RedeemerVal {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RedeemerVal.prototype);
        obj.__wbg_ptr = ptr;
        RedeemerValFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemerValFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerval_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.redeemerval_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.redeemerval_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {RedeemerVal}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerval_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerVal.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemerval_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemerval_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {RedeemerVal}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerval_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerVal.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.redeemerval_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.redeemerval_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {RedeemerVal}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemerval_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RedeemerVal.__wrap(ret[0]);
    }
    /**
     * @returns {PlutusData}
     */
    data() {
        const ret = wasm.redeemerval_data(this.__wbg_ptr);
        return PlutusData.__wrap(ret);
    }
    /**
     * @returns {ExUnits}
     */
    ex_units() {
        const ret = wasm.redeemerval_ex_units(this.__wbg_ptr);
        return ExUnits.__wrap(ret);
    }
    /**
     * @param {PlutusData} data
     * @param {ExUnits} ex_units
     * @returns {RedeemerVal}
     */
    static new(data, ex_units) {
        _assertClass(data, PlutusData);
        _assertClass(ex_units, ExUnits);
        const ret = wasm.redeemerval_new(data.__wbg_ptr, ex_units.__wbg_ptr);
        return RedeemerVal.__wrap(ret);
    }
}

const RedeemerWitnessKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemerwitnesskey_free(ptr >>> 0, 1));

export class RedeemerWitnessKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RedeemerWitnessKey.prototype);
        obj.__wbg_ptr = ptr;
        RedeemerWitnessKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemerWitnessKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemerwitnesskey_free(ptr, 0);
    }
    /**
     * @param {RedeemerTag} tag
     * @param {bigint} index
     * @returns {RedeemerWitnessKey}
     */
    static new(tag, index) {
        const ret = wasm.redeemerwitnesskey_new(tag, index);
        return RedeemerWitnessKey.__wrap(ret);
    }
    /**
     * @param {LegacyRedeemer} redeemer
     * @returns {RedeemerWitnessKey}
     */
    static from_redeemer(redeemer) {
        _assertClass(redeemer, LegacyRedeemer);
        const ret = wasm.redeemerwitnesskey_from_redeemer(redeemer.__wbg_ptr);
        return RedeemerWitnessKey.__wrap(ret);
    }
}

const RedeemersFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_redeemers_free(ptr >>> 0, 1));

export class Redeemers {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Redeemers.prototype);
        obj.__wbg_ptr = ptr;
        RedeemersFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RedeemersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_redeemers_free(ptr, 0);
    }
    /**
     * @returns {LegacyRedeemerList}
     */
    to_flat_format() {
        const ret = wasm.redeemers_to_flat_format(this.__wbg_ptr);
        return LegacyRedeemerList.__wrap(ret);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.redeemers_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.redeemers_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Redeemers}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemers_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Redeemers.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemers_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.redeemers_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Redeemers}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemers_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Redeemers.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.redeemers_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.redeemers_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Redeemers}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.redeemers_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Redeemers.__wrap(ret[0]);
    }
    /**
     * @param {LegacyRedeemerList} arr_legacy_redeemer
     * @returns {Redeemers}
     */
    static new_arr_legacy_redeemer(arr_legacy_redeemer) {
        _assertClass(arr_legacy_redeemer, LegacyRedeemerList);
        const ret = wasm.redeemers_new_arr_legacy_redeemer(arr_legacy_redeemer.__wbg_ptr);
        return Redeemers.__wrap(ret);
    }
    /**
     * @param {MapRedeemerKeyToRedeemerVal} map_redeemer_key_to_redeemer_val
     * @returns {Redeemers}
     */
    static new_map_redeemer_key_to_redeemer_val(map_redeemer_key_to_redeemer_val) {
        _assertClass(map_redeemer_key_to_redeemer_val, MapRedeemerKeyToRedeemerVal);
        const ret = wasm.redeemers_new_map_redeemer_key_to_redeemer_val(map_redeemer_key_to_redeemer_val.__wbg_ptr);
        return Redeemers.__wrap(ret);
    }
    /**
     * @returns {RedeemersKind}
     */
    kind() {
        const ret = wasm.redeemers_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {LegacyRedeemerList | undefined}
     */
    as_arr_legacy_redeemer() {
        const ret = wasm.redeemers_as_arr_legacy_redeemer(this.__wbg_ptr);
        return ret === 0 ? undefined : LegacyRedeemerList.__wrap(ret);
    }
    /**
     * @returns {MapRedeemerKeyToRedeemerVal | undefined}
     */
    as_map_redeemer_key_to_redeemer_val() {
        const ret = wasm.redeemers_as_map_redeemer_key_to_redeemer_val(this.__wbg_ptr);
        return ret === 0 ? undefined : MapRedeemerKeyToRedeemerVal.__wrap(ret);
    }
}

const RegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_regcert_free(ptr >>> 0, 1));

export class RegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegCert.prototype);
        obj.__wbg_ptr = ptr;
        RegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_regcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.regcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.regcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {RegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.regcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.regcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {RegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.regcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.regcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {RegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.regcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.regcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {bigint} deposit
     * @returns {RegCert}
     */
    static new(stake_credential, deposit) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.regcert_new(stake_credential.__wbg_ptr, deposit);
        return RegCert.__wrap(ret);
    }
}

const RegDrepCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_regdrepcert_free(ptr >>> 0, 1));

export class RegDrepCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegDrepCert.prototype);
        obj.__wbg_ptr = ptr;
        RegDrepCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_regdrepcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.regdrepcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.regdrepcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {RegDrepCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regdrepcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegDrepCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.regdrepcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.regdrepcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {RegDrepCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regdrepcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.regdrepcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.regdrepcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {RegDrepCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.regdrepcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RegDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    drep_credential() {
        const ret = wasm.regdrepcert_drep_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.regdrepcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {Anchor | undefined}
     */
    anchor() {
        const ret = wasm.regdrepcert_anchor(this.__wbg_ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {bigint} deposit
     * @param {Anchor | null} [anchor]
     * @returns {RegDrepCert}
     */
    static new(drep_credential, deposit, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.regdrepcert_new(drep_credential.__wbg_ptr, deposit, ptr0);
        return RegDrepCert.__wrap(ret);
    }
}

const RelayFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relay_free(ptr >>> 0, 1));

export class Relay {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Relay.prototype);
        obj.__wbg_ptr = ptr;
        RelayFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relay_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.relay_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.relay_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Relay}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relay_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Relay.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.relay_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.relay_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Relay}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relay_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Relay.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.relay_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.relay_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Relay}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relay_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Relay.__wrap(ret[0]);
    }
    /**
     * @param {number | null} [port]
     * @param {Ipv4 | null} [ipv4]
     * @param {Ipv6 | null} [ipv6]
     * @returns {Relay}
     */
    static new_single_host_addr(port, ipv4, ipv6) {
        let ptr0 = 0;
        if (!isLikeNone(ipv4)) {
            _assertClass(ipv4, Ipv4);
            ptr0 = ipv4.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(ipv6)) {
            _assertClass(ipv6, Ipv6);
            ptr1 = ipv6.__destroy_into_raw();
        }
        const ret = wasm.relay_new_single_host_addr(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);
        return Relay.__wrap(ret);
    }
    /**
     * @param {number | null | undefined} port
     * @param {DNSName} dns_name
     * @returns {Relay}
     */
    static new_single_host_name(port, dns_name) {
        _assertClass(dns_name, DNSName);
        const ret = wasm.relay_new_single_host_name(isLikeNone(port) ? 0xFFFFFF : port, dns_name.__wbg_ptr);
        return Relay.__wrap(ret);
    }
    /**
     * @param {DNSName} dns_name
     * @returns {Relay}
     */
    static new_multi_host_name(dns_name) {
        _assertClass(dns_name, DNSName);
        const ret = wasm.relay_new_multi_host_name(dns_name.__wbg_ptr);
        return Relay.__wrap(ret);
    }
    /**
     * @returns {RelayKind}
     */
    kind() {
        const ret = wasm.relay_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {SingleHostAddr | undefined}
     */
    as_single_host_addr() {
        const ret = wasm.relay_as_single_host_addr(this.__wbg_ptr);
        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);
    }
    /**
     * @returns {SingleHostName | undefined}
     */
    as_single_host_name() {
        const ret = wasm.relay_as_single_host_name(this.__wbg_ptr);
        return ret === 0 ? undefined : SingleHostName.__wrap(ret);
    }
    /**
     * @returns {MultiHostName | undefined}
     */
    as_multi_host_name() {
        const ret = wasm.relay_as_multi_host_name(this.__wbg_ptr);
        return ret === 0 ? undefined : MultiHostName.__wrap(ret);
    }
}

const RelayListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaylist_free(ptr >>> 0, 1));

export class RelayList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayList.prototype);
        obj.__wbg_ptr = ptr;
        RelayListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaylist_free(ptr, 0);
    }
    /**
     * @returns {RelayList}
     */
    static new() {
        const ret = wasm.relaylist_new();
        return RelayList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.relaylist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Relay}
     */
    get(index) {
        const ret = wasm.relaylist_get(this.__wbg_ptr, index);
        return Relay.__wrap(ret);
    }
    /**
     * @param {Relay} elem
     */
    add(elem) {
        _assertClass(elem, Relay);
        wasm.relaylist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const RequiredWitnessSetFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_requiredwitnessset_free(ptr >>> 0, 1));

export class RequiredWitnessSet {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RequiredWitnessSet.prototype);
        obj.__wbg_ptr = ptr;
        RequiredWitnessSetFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RequiredWitnessSetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_requiredwitnessset_free(ptr, 0);
    }
    /**
     * @param {Ed25519KeyHash} hash
     */
    add_vkey_key_hash(hash) {
        _assertClass(hash, Ed25519KeyHash);
        wasm.requiredwitnessset_add_vkey_key_hash(this.__wbg_ptr, hash.__wbg_ptr);
    }
    /**
     * @param {ByronAddress} address
     */
    add_bootstrap(address) {
        _assertClass(address, ByronAddress);
        wasm.requiredwitnessset_add_bootstrap(this.__wbg_ptr, address.__wbg_ptr);
    }
    /**
     * @param {ScriptHash} script_hash
     */
    add_script_ref(script_hash) {
        _assertClass(script_hash, ScriptHash);
        wasm.requiredwitnessset_add_script_ref(this.__wbg_ptr, script_hash.__wbg_ptr);
    }
    /**
     * @param {ScriptHash} script_hash
     */
    add_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        wasm.requiredwitnessset_add_script_hash(this.__wbg_ptr, script_hash.__wbg_ptr);
    }
    /**
     * @param {DatumHash} plutus_datum
     */
    add_plutus_datum_hash(plutus_datum) {
        _assertClass(plutus_datum, DatumHash);
        wasm.requiredwitnessset_add_plutus_datum_hash(this.__wbg_ptr, plutus_datum.__wbg_ptr);
    }
    /**
     * @param {RedeemerWitnessKey} redeemer
     */
    add_redeemer_tag(redeemer) {
        _assertClass(redeemer, RedeemerWitnessKey);
        wasm.requiredwitnessset_add_redeemer_tag(this.__wbg_ptr, redeemer.__wbg_ptr);
    }
    /**
     * @param {RequiredWitnessSet} requirements
     */
    add_all(requirements) {
        _assertClass(requirements, RequiredWitnessSet);
        wasm.requiredwitnessset_add_all(this.__wbg_ptr, requirements.__wbg_ptr);
    }
    /**
     * @returns {RequiredWitnessSet}
     */
    static new() {
        const ret = wasm.requiredwitnessset_new();
        return RequiredWitnessSet.__wrap(ret);
    }
    /**
     * @param {RewardAddress} address
     */
    withdrawal_required_wits(address) {
        _assertClass(address, RewardAddress);
        wasm.requiredwitnessset_withdrawal_required_wits(this.__wbg_ptr, address.__wbg_ptr);
    }
}

const ResignCommitteeColdCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_resigncommitteecoldcert_free(ptr >>> 0, 1));

export class ResignCommitteeColdCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ResignCommitteeColdCert.prototype);
        obj.__wbg_ptr = ptr;
        ResignCommitteeColdCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResignCommitteeColdCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resigncommitteecoldcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.resigncommitteecoldcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.resigncommitteecoldcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ResignCommitteeColdCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.resigncommitteecoldcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResignCommitteeColdCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resigncommitteecoldcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.resigncommitteecoldcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ResignCommitteeColdCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.resigncommitteecoldcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResignCommitteeColdCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.resigncommitteecoldcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.resigncommitteecoldcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ResignCommitteeColdCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.resigncommitteecoldcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ResignCommitteeColdCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    committee_cold_credential() {
        const ret = wasm.resigncommitteecoldcert_committee_cold_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Anchor | undefined}
     */
    anchor() {
        const ret = wasm.resigncommitteecoldcert_anchor(this.__wbg_ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
     * @param {Credential} committee_cold_credential
     * @param {Anchor | null} [anchor]
     * @returns {ResignCommitteeColdCert}
     */
    static new(committee_cold_credential, anchor) {
        _assertClass(committee_cold_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.resigncommitteecoldcert_new(committee_cold_credential.__wbg_ptr, ptr0);
        return ResignCommitteeColdCert.__wrap(ret);
    }
}

const RewardAccountListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rewardaccountlist_free(ptr >>> 0, 1));

export class RewardAccountList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RewardAccountList.prototype);
        obj.__wbg_ptr = ptr;
        RewardAccountListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RewardAccountListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewardaccountlist_free(ptr, 0);
    }
    /**
     * @returns {RewardAccountList}
     */
    static new() {
        const ret = wasm.rewardaccountlist_new();
        return RewardAccountList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.rewardaccountlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {RewardAddress}
     */
    get(index) {
        const ret = wasm.rewardaccountlist_get(this.__wbg_ptr, index);
        return RewardAddress.__wrap(ret);
    }
    /**
     * @param {RewardAddress} elem
     */
    add(elem) {
        _assertClass(elem, RewardAddress);
        wasm.rewardaccountlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const RewardAddressFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_rewardaddress_free(ptr >>> 0, 1));

export class RewardAddress {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RewardAddress.prototype);
        obj.__wbg_ptr = ptr;
        RewardAddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RewardAddressFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewardaddress_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.rewardaddress_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.rewardaddress_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {RewardAddress}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.rewardaddress_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return RewardAddress.__wrap(ret[0]);
    }
    /**
     * @param {number} network
     * @param {Credential} payment
     * @returns {RewardAddress}
     */
    static new(network, payment) {
        _assertClass(payment, Credential);
        const ret = wasm.rewardaddress_new(network, payment.__wbg_ptr);
        return RewardAddress.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    to_address() {
        const ret = wasm.rewardaddress_to_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @returns {RewardAddress | undefined}
     */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.rewardaddress_from_address(address.__wbg_ptr);
        return ret === 0 ? undefined : RewardAddress.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    network_id() {
        const ret = wasm.rewardaddress_network_id(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Credential}
     */
    payment() {
        const ret = wasm.rewardaddress_payment(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
}

const ScriptFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_script_free(ptr >>> 0, 1));

export class Script {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Script.prototype);
        obj.__wbg_ptr = ptr;
        ScriptFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_script_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.script_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.script_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Script}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.script_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Script.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.script_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.script_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Script}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.script_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Script.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.script_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.script_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Script}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.script_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Script.__wrap(ret[0]);
    }
    /**
     * @param {NativeScript} script
     * @returns {Script}
     */
    static new_native(script) {
        _assertClass(script, NativeScript);
        const ret = wasm.script_new_native(script.__wbg_ptr);
        return Script.__wrap(ret);
    }
    /**
     * @param {PlutusV1Script} script
     * @returns {Script}
     */
    static new_plutus_v1(script) {
        _assertClass(script, PlutusV1Script);
        const ret = wasm.script_new_plutus_v1(script.__wbg_ptr);
        return Script.__wrap(ret);
    }
    /**
     * @param {PlutusV2Script} script
     * @returns {Script}
     */
    static new_plutus_v2(script) {
        _assertClass(script, PlutusV2Script);
        const ret = wasm.script_new_plutus_v2(script.__wbg_ptr);
        return Script.__wrap(ret);
    }
    /**
     * @param {PlutusV3Script} script
     * @returns {Script}
     */
    static new_plutus_v3(script) {
        _assertClass(script, PlutusV3Script);
        const ret = wasm.script_new_plutus_v3(script.__wbg_ptr);
        return Script.__wrap(ret);
    }
    /**
     * @returns {ScriptKind}
     */
    kind() {
        const ret = wasm.script_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {NativeScript | undefined}
     */
    as_native() {
        const ret = wasm.script_as_native(this.__wbg_ptr);
        return ret === 0 ? undefined : NativeScript.__wrap(ret);
    }
    /**
     * @returns {PlutusV1Script | undefined}
     */
    as_plutus_v1() {
        const ret = wasm.script_as_plutus_v1(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV1Script.__wrap(ret);
    }
    /**
     * @returns {PlutusV2Script | undefined}
     */
    as_plutus_v2() {
        const ret = wasm.script_as_plutus_v2(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV2Script.__wrap(ret);
    }
    /**
     * @returns {PlutusV3Script | undefined}
     */
    as_plutus_v3() {
        const ret = wasm.script_as_plutus_v3(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV3Script.__wrap(ret);
    }
    /**
     * @returns {ScriptHash}
     */
    hash() {
        const ret = wasm.script_hash(this.__wbg_ptr);
        return ScriptHash.__wrap(ret);
    }
    /**
     * @returns {Language | undefined}
     */
    language() {
        const ret = wasm.script_language(this.__wbg_ptr);
        return ret === 3 ? undefined : ret;
    }
}

const ScriptAllFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptall_free(ptr >>> 0, 1));

export class ScriptAll {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptAll.prototype);
        obj.__wbg_ptr = ptr;
        ScriptAllFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptAllFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptall_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptall_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptall_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptAll}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptall_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAll.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptall_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptall_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptAll}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptall_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAll.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptall_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptall_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptAll}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptall_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAll.__wrap(ret[0]);
    }
    /**
     * @returns {NativeScriptList}
     */
    native_scripts() {
        const ret = wasm.scriptall_native_scripts(this.__wbg_ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     * @returns {ScriptAll}
     */
    static new(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptall_new(native_scripts.__wbg_ptr);
        return ScriptAll.__wrap(ret);
    }
}

const ScriptAnyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptany_free(ptr >>> 0, 1));

export class ScriptAny {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptAny.prototype);
        obj.__wbg_ptr = ptr;
        ScriptAnyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptAnyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptany_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptany_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptany_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptAny}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptany_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAny.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptany_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptany_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptAny}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptany_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAny.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptany_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptany_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptAny}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptany_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptAny.__wrap(ret[0]);
    }
    /**
     * @returns {NativeScriptList}
     */
    native_scripts() {
        const ret = wasm.scriptany_native_scripts(this.__wbg_ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     * @returns {ScriptAny}
     */
    static new(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptany_new(native_scripts.__wbg_ptr);
        return ScriptAny.__wrap(ret);
    }
}

const ScriptDataHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptdatahash_free(ptr >>> 0, 1));

export class ScriptDataHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptDataHash.prototype);
        obj.__wbg_ptr = ptr;
        ScriptDataHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptDataHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptdatahash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.scriptdatahash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {ScriptDataHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptdatahash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptDataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.scriptdatahash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {ScriptDataHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptdatahash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptDataHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptdatahash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {ScriptDataHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptdatahash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptDataHash.__wrap(ret[0]);
    }
}

const ScriptHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scripthash_free(ptr >>> 0, 1));

export class ScriptHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptHash.prototype);
        obj.__wbg_ptr = ptr;
        ScriptHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scripthash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.scripthash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {ScriptHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scripthash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.scripthash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {ScriptHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scripthash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scripthash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {ScriptHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scripthash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptHash.__wrap(ret[0]);
    }
}

const ScriptInvalidBeforeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptinvalidbefore_free(ptr >>> 0, 1));

export class ScriptInvalidBefore {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptInvalidBefore.prototype);
        obj.__wbg_ptr = ptr;
        ScriptInvalidBeforeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptInvalidBeforeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptinvalidbefore_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptinvalidbefore_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptinvalidbefore_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptInvalidBefore}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidbefore_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidBefore.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptinvalidbefore_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptinvalidbefore_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptInvalidBefore}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidbefore_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidBefore.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptinvalidbefore_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptinvalidbefore_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptInvalidBefore}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidbefore_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidBefore.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    before() {
        const ret = wasm.scriptinvalidbefore_before(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} before
     * @returns {ScriptInvalidBefore}
     */
    static new(before) {
        const ret = wasm.scriptinvalidbefore_new(before);
        return ScriptInvalidBefore.__wrap(ret);
    }
}

const ScriptInvalidHereafterFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptinvalidhereafter_free(ptr >>> 0, 1));

export class ScriptInvalidHereafter {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptInvalidHereafter.prototype);
        obj.__wbg_ptr = ptr;
        ScriptInvalidHereafterFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptInvalidHereafterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptinvalidhereafter_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptinvalidhereafter_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptinvalidhereafter_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptInvalidHereafter}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidhereafter_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidHereafter.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptinvalidhereafter_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptinvalidhereafter_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptInvalidHereafter}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidhereafter_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidHereafter.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptinvalidhereafter_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptinvalidhereafter_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptInvalidHereafter}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptinvalidhereafter_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptInvalidHereafter.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    after() {
        const ret = wasm.scriptinvalidhereafter_after(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} after
     * @returns {ScriptInvalidHereafter}
     */
    static new(after) {
        const ret = wasm.scriptinvalidhereafter_new(after);
        return ScriptInvalidHereafter.__wrap(ret);
    }
}

const ScriptNOfKFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptnofk_free(ptr >>> 0, 1));

export class ScriptNOfK {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptNOfK.prototype);
        obj.__wbg_ptr = ptr;
        ScriptNOfKFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptNOfKFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptnofk_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptnofk_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptnofk_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptNOfK}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptnofk_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptNOfK.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptnofk_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptnofk_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptNOfK}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptnofk_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptNOfK.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptnofk_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptnofk_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptNOfK}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptnofk_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptNOfK.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    n() {
        const ret = wasm.scriptnofk_n(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {NativeScriptList}
     */
    native_scripts() {
        const ret = wasm.scriptnofk_native_scripts(this.__wbg_ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @param {bigint} n
     * @param {NativeScriptList} native_scripts
     * @returns {ScriptNOfK}
     */
    static new(n, native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        const ret = wasm.scriptnofk_new(n, native_scripts.__wbg_ptr);
        return ScriptNOfK.__wrap(ret);
    }
}

const ScriptPubkeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scriptpubkey_free(ptr >>> 0, 1));

export class ScriptPubkey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ScriptPubkey.prototype);
        obj.__wbg_ptr = ptr;
        ScriptPubkeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptPubkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptpubkey_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.scriptpubkey_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.scriptpubkey_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ScriptPubkey}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptpubkey_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptPubkey.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptpubkey_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.scriptpubkey_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ScriptPubkey}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptpubkey_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptPubkey.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.scriptpubkey_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.scriptpubkey_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ScriptPubkey}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scriptpubkey_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ScriptPubkey.__wrap(ret[0]);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    ed25519_key_hash() {
        const ret = wasm.scriptpubkey_ed25519_key_hash(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} ed25519_key_hash
     * @returns {ScriptPubkey}
     */
    static new(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.scriptpubkey_new(ed25519_key_hash.__wbg_ptr);
        return ScriptPubkey.__wrap(ret);
    }
}

const ShelleyMAFormatAuxDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_shelleymaformatauxdata_free(ptr >>> 0, 1));

export class ShelleyMAFormatAuxData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShelleyMAFormatAuxData.prototype);
        obj.__wbg_ptr = ptr;
        ShelleyMAFormatAuxDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShelleyMAFormatAuxDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shelleymaformatauxdata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.shelleymaformatauxdata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.shelleymaformatauxdata_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {ShelleyMAFormatAuxData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.shelleymaformatauxdata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ShelleyMAFormatAuxData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.shelleymaformatauxdata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.shelleymaformatauxdata_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {ShelleyMAFormatAuxData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.shelleymaformatauxdata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ShelleyMAFormatAuxData.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.shelleymaformatauxdata_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.shelleymaformatauxdata_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {ShelleyMAFormatAuxData}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.shelleymaformatauxdata_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ShelleyMAFormatAuxData.__wrap(ret[0]);
    }
    /**
     * @returns {Metadata}
     */
    transaction_metadata() {
        const ret = wasm.shelleymaformatauxdata_transaction_metadata(this.__wbg_ptr);
        return Metadata.__wrap(ret);
    }
    /**
     * @returns {NativeScriptList}
     */
    auxiliary_scripts() {
        const ret = wasm.shelleymaformatauxdata_auxiliary_scripts(this.__wbg_ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @param {Metadata} transaction_metadata
     * @param {NativeScriptList} auxiliary_scripts
     * @returns {ShelleyMAFormatAuxData}
     */
    static new(transaction_metadata, auxiliary_scripts) {
        _assertClass(transaction_metadata, Metadata);
        _assertClass(auxiliary_scripts, NativeScriptList);
        const ret = wasm.shelleymaformatauxdata_new(transaction_metadata.__wbg_ptr, auxiliary_scripts.__wbg_ptr);
        return ShelleyMAFormatAuxData.__wrap(ret);
    }
}

const SignedTxBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_signedtxbuilder_free(ptr >>> 0, 1));

export class SignedTxBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SignedTxBuilder.prototype);
        obj.__wbg_ptr = ptr;
        SignedTxBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SignedTxBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signedtxbuilder_free(ptr, 0);
    }
    /**
     * @param {TransactionBody} body
     * @param {TransactionWitnessSetBuilder} witness_set
     * @param {boolean} is_valid
     * @param {AuxiliaryData} auxiliary_data
     * @returns {SignedTxBuilder}
     */
    static new_with_data(body, witness_set, is_valid, auxiliary_data) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSetBuilder);
        _assertClass(auxiliary_data, AuxiliaryData);
        const ret = wasm.signedtxbuilder_new_with_data(body.__wbg_ptr, witness_set.__wbg_ptr, is_valid, auxiliary_data.__wbg_ptr);
        return SignedTxBuilder.__wrap(ret);
    }
    /**
     * @param {TransactionBody} body
     * @param {TransactionWitnessSetBuilder} witness_set
     * @param {boolean} is_valid
     * @returns {SignedTxBuilder}
     */
    static new_without_data(body, witness_set, is_valid) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSetBuilder);
        const ret = wasm.signedtxbuilder_new_without_data(body.__wbg_ptr, witness_set.__wbg_ptr, is_valid);
        return SignedTxBuilder.__wrap(ret);
    }
    /**
     *
     *     * Builds the final transaction and checks that all witnesses are there
     *
     * @returns {Transaction}
     */
    build_checked() {
        const ret = wasm.signedtxbuilder_build_checked(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Transaction.__wrap(ret[0]);
    }
    /**
     *
     *     * Builds the transaction without doing any witness checks.
     *     *
     *     * This can be useful if other witnesses will be added later.
     *     * e.g. CIP30 signing takes a Transaction with possible witnesses
     *     * to send to the wallet to fill in the missing ones.
     *
     * @returns {Transaction}
     */
    build_unchecked() {
        const ret = wasm.signedtxbuilder_build_unchecked(this.__wbg_ptr);
        return Transaction.__wrap(ret);
    }
    /**
     * @param {Vkeywitness} vkey
     */
    add_vkey(vkey) {
        _assertClass(vkey, Vkeywitness);
        wasm.signedtxbuilder_add_vkey(this.__wbg_ptr, vkey.__wbg_ptr);
    }
    /**
     * @param {BootstrapWitness} bootstrap
     */
    add_bootstrap(bootstrap) {
        _assertClass(bootstrap, BootstrapWitness);
        wasm.signedtxbuilder_add_bootstrap(this.__wbg_ptr, bootstrap.__wbg_ptr);
    }
    /**
     * @returns {TransactionBody}
     */
    body() {
        const ret = wasm.signedtxbuilder_body(this.__wbg_ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
     * @returns {TransactionWitnessSetBuilder}
     */
    witness_set() {
        const ret = wasm.signedtxbuilder_witness_set(this.__wbg_ptr);
        return TransactionWitnessSetBuilder.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    is_valid() {
        const ret = wasm.signedtxbuilder_is_valid(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {AuxiliaryData | undefined}
     */
    auxiliary_data() {
        const ret = wasm.signedtxbuilder_auxiliary_data(this.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
}

const SingleCertificateBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlecertificatebuilder_free(ptr >>> 0, 1));

export class SingleCertificateBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleCertificateBuilder.prototype);
        obj.__wbg_ptr = ptr;
        SingleCertificateBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleCertificateBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlecertificatebuilder_free(ptr, 0);
    }
    /**
     * @param {Certificate} cert
     * @returns {SingleCertificateBuilder}
     */
    static new(cert) {
        _assertClass(cert, Certificate);
        const ret = wasm.singlecertificatebuilder_new(cert.__wbg_ptr);
        return SingleCertificateBuilder.__wrap(ret);
    }
    /**
     * note: particularly useful for StakeRegistration which doesn't require witnessing
     * @returns {CertificateBuilderResult}
     */
    skip_witness() {
        const ret = wasm.singlecertificatebuilder_skip_witness(this.__wbg_ptr);
        return CertificateBuilderResult.__wrap(ret);
    }
    /**
     * @returns {CertificateBuilderResult}
     */
    payment_key() {
        const ret = wasm.singlecertificatebuilder_payment_key(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CertificateBuilderResult.__wrap(ret[0]);
    }
    /**
     * Signer keys don't have to be set. You can leave it empty and then add the required witnesses later
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {CertificateBuilderResult}
     */
    native_script(native_script, witness_info) {
        _assertClass(native_script, NativeScript);
        _assertClass(witness_info, NativeScriptWitnessInfo);
        const ret = wasm.singlecertificatebuilder_native_script(this.__wbg_ptr, native_script.__wbg_ptr, witness_info.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CertificateBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {CertificateBuilderResult}
     */
    plutus_script(partial_witness, required_signers) {
        const ptr = this.__destroy_into_raw();
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        const ret = wasm.singlecertificatebuilder_plutus_script(ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return CertificateBuilderResult.__wrap(ret[0]);
    }
}

const SingleHostAddrFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlehostaddr_free(ptr >>> 0, 1));

export class SingleHostAddr {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleHostAddr.prototype);
        obj.__wbg_ptr = ptr;
        SingleHostAddrFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleHostAddrFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlehostaddr_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.singlehostaddr_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.singlehostaddr_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {SingleHostAddr}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostaddr_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostAddr.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.singlehostaddr_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.singlehostaddr_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {SingleHostAddr}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostaddr_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostAddr.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.singlehostaddr_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.singlehostaddr_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {SingleHostAddr}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostaddr_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostAddr.__wrap(ret[0]);
    }
    /**
     * @returns {number | undefined}
     */
    port() {
        const ret = wasm.singlehostaddr_port(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
     * @returns {Ipv4 | undefined}
     */
    ipv4() {
        const ret = wasm.singlehostaddr_ipv4(this.__wbg_ptr);
        return ret === 0 ? undefined : Ipv4.__wrap(ret);
    }
    /**
     * @returns {Ipv6 | undefined}
     */
    ipv6() {
        const ret = wasm.singlehostaddr_ipv6(this.__wbg_ptr);
        return ret === 0 ? undefined : Ipv6.__wrap(ret);
    }
    /**
     * @param {number | null} [port]
     * @param {Ipv4 | null} [ipv4]
     * @param {Ipv6 | null} [ipv6]
     * @returns {SingleHostAddr}
     */
    static new(port, ipv4, ipv6) {
        let ptr0 = 0;
        if (!isLikeNone(ipv4)) {
            _assertClass(ipv4, Ipv4);
            ptr0 = ipv4.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(ipv6)) {
            _assertClass(ipv6, Ipv6);
            ptr1 = ipv6.__destroy_into_raw();
        }
        const ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);
        return SingleHostAddr.__wrap(ret);
    }
}

const SingleHostNameFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlehostname_free(ptr >>> 0, 1));

export class SingleHostName {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleHostName.prototype);
        obj.__wbg_ptr = ptr;
        SingleHostNameFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleHostNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlehostname_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.singlehostname_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.singlehostname_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {SingleHostName}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostname_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostName.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.singlehostname_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.singlehostname_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {SingleHostName}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostname_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostName.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.singlehostname_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.singlehostname_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {SingleHostName}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.singlehostname_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleHostName.__wrap(ret[0]);
    }
    /**
     * @returns {number | undefined}
     */
    port() {
        const ret = wasm.singlehostname_port(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
     * @returns {DNSName}
     */
    dns_name() {
        const ret = wasm.singlehostname_dns_name(this.__wbg_ptr);
        return DNSName.__wrap(ret);
    }
    /**
     * * `dns_name` - An A or AAAA DNS record
     * @param {number | null | undefined} port
     * @param {DNSName} dns_name
     * @returns {SingleHostName}
     */
    static new(port, dns_name) {
        _assertClass(dns_name, DNSName);
        const ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.__wbg_ptr);
        return SingleHostName.__wrap(ret);
    }
}

const SingleInputBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singleinputbuilder_free(ptr >>> 0, 1));

export class SingleInputBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleInputBuilder.prototype);
        obj.__wbg_ptr = ptr;
        SingleInputBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleInputBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singleinputbuilder_free(ptr, 0);
    }
    /**
     * @param {TransactionInput} input
     * @param {TransactionOutput} utxo_info
     * @returns {SingleInputBuilder}
     */
    static new(input, utxo_info) {
        _assertClass(input, TransactionInput);
        _assertClass(utxo_info, TransactionOutput);
        const ret = wasm.singleinputbuilder_new(input.__wbg_ptr, utxo_info.__wbg_ptr);
        return SingleInputBuilder.__wrap(ret);
    }
    /**
     * @param {TransactionUnspentOutput} utxo
     * @returns {SingleInputBuilder}
     */
    static from_transaction_unspent_output(utxo) {
        _assertClass(utxo, TransactionUnspentOutput);
        const ret = wasm.singleinputbuilder_from_transaction_unspent_output(utxo.__wbg_ptr);
        return SingleInputBuilder.__wrap(ret);
    }
    /**
     * @returns {InputBuilderResult}
     */
    payment_key() {
        const ret = wasm.singleinputbuilder_payment_key(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InputBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {InputBuilderResult}
     */
    native_script(native_script, witness_info) {
        _assertClass(native_script, NativeScript);
        _assertClass(witness_info, NativeScriptWitnessInfo);
        const ret = wasm.singleinputbuilder_native_script(this.__wbg_ptr, native_script.__wbg_ptr, witness_info.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InputBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @param {PlutusData} datum
     * @returns {InputBuilderResult}
     */
    plutus_script(partial_witness, required_signers, datum) {
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        _assertClass(datum, PlutusData);
        const ret = wasm.singleinputbuilder_plutus_script(this.__wbg_ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr, datum.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InputBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {InputBuilderResult}
     */
    plutus_script_inline_datum(partial_witness, required_signers) {
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        const ret = wasm.singleinputbuilder_plutus_script_inline_datum(this.__wbg_ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return InputBuilderResult.__wrap(ret[0]);
    }
}

const SingleMintBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlemintbuilder_free(ptr >>> 0, 1));

export class SingleMintBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleMintBuilder.prototype);
        obj.__wbg_ptr = ptr;
        SingleMintBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleMintBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlemintbuilder_free(ptr, 0);
    }
    /**
     * @param {MapAssetNameToNonZeroInt64} assets
     * @returns {SingleMintBuilder}
     */
    static new(assets) {
        _assertClass(assets, MapAssetNameToNonZeroInt64);
        const ret = wasm.singlemintbuilder_new(assets.__wbg_ptr);
        return SingleMintBuilder.__wrap(ret);
    }
    /**
     * @param {AssetName} asset
     * @param {bigint} amount
     * @returns {SingleMintBuilder}
     */
    static new_single_asset(asset, amount) {
        _assertClass(asset, AssetName);
        const ret = wasm.singlemintbuilder_new_single_asset(asset.__wbg_ptr, amount);
        return SingleMintBuilder.__wrap(ret);
    }
    /**
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {MintBuilderResult}
     */
    native_script(native_script, witness_info) {
        const ptr = this.__destroy_into_raw();
        _assertClass(native_script, NativeScript);
        _assertClass(witness_info, NativeScriptWitnessInfo);
        const ret = wasm.singlemintbuilder_native_script(ptr, native_script.__wbg_ptr, witness_info.__wbg_ptr);
        return MintBuilderResult.__wrap(ret);
    }
    /**
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {MintBuilderResult}
     */
    plutus_script(partial_witness, required_signers) {
        const ptr = this.__destroy_into_raw();
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        const ret = wasm.singlemintbuilder_plutus_script(ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr);
        return MintBuilderResult.__wrap(ret);
    }
}

const SingleOutputBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singleoutputbuilderresult_free(ptr >>> 0, 1));

export class SingleOutputBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleOutputBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        SingleOutputBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleOutputBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singleoutputbuilderresult_free(ptr, 0);
    }
    /**
     * @param {TransactionOutput} output
     * @returns {SingleOutputBuilderResult}
     */
    static new(output) {
        _assertClass(output, TransactionOutput);
        const ret = wasm.singleoutputbuilderresult_new(output.__wbg_ptr);
        return SingleOutputBuilderResult.__wrap(ret);
    }
    /**
     * @returns {TransactionOutput}
     */
    output() {
        const ret = wasm.singleoutputbuilderresult_output(this.__wbg_ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
     * @returns {PlutusData | undefined}
     */
    communication_datum() {
        const ret = wasm.singleoutputbuilderresult_communication_datum(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusData.__wrap(ret);
    }
}

const SingleWithdrawalBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlewithdrawalbuilder_free(ptr >>> 0, 1));

export class SingleWithdrawalBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleWithdrawalBuilder.prototype);
        obj.__wbg_ptr = ptr;
        SingleWithdrawalBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleWithdrawalBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlewithdrawalbuilder_free(ptr, 0);
    }
    /**
     * @param {RewardAddress} address
     * @param {bigint} amount
     * @returns {SingleWithdrawalBuilder}
     */
    static new(address, amount) {
        _assertClass(address, RewardAddress);
        const ret = wasm.singlewithdrawalbuilder_new(address.__wbg_ptr, amount);
        return SingleWithdrawalBuilder.__wrap(ret);
    }
    /**
     * @returns {WithdrawalBuilderResult}
     */
    payment_key() {
        const ret = wasm.singlewithdrawalbuilder_payment_key(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WithdrawalBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {WithdrawalBuilderResult}
     */
    native_script(native_script, witness_info) {
        const ptr = this.__destroy_into_raw();
        _assertClass(native_script, NativeScript);
        _assertClass(witness_info, NativeScriptWitnessInfo);
        const ret = wasm.singlewithdrawalbuilder_native_script(ptr, native_script.__wbg_ptr, witness_info.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WithdrawalBuilderResult.__wrap(ret[0]);
    }
    /**
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {WithdrawalBuilderResult}
     */
    plutus_script(partial_witness, required_signers) {
        const ptr = this.__destroy_into_raw();
        _assertClass(partial_witness, PartialPlutusWitness);
        var ptr0 = partial_witness.__destroy_into_raw();
        _assertClass(required_signers, Ed25519KeyHashList);
        var ptr1 = required_signers.__destroy_into_raw();
        const ret = wasm.singlewithdrawalbuilder_plutus_script(ptr, ptr0, ptr1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return WithdrawalBuilderResult.__wrap(ret[0]);
    }
}

const SpendingDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_spendingdata_free(ptr >>> 0, 1));

export class SpendingData {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SpendingData.prototype);
        obj.__wbg_ptr = ptr;
        SpendingDataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SpendingDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_spendingdata_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.spendingdata_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {SpendingData}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.spendingdata_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SpendingData.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.spendingdata_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {SpendingData}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.spendingdata_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SpendingData.__wrap(ret[0]);
    }
    /**
     * @param {Bip32PublicKey} pubkey
     * @returns {SpendingData}
     */
    static new_spending_data_pub_key(pubkey) {
        _assertClass(pubkey, Bip32PublicKey);
        const ret = wasm.spendingdata_new_spending_data_pub_key(pubkey.__wbg_ptr);
        return SpendingData.__wrap(ret);
    }
    /**
     * @param {ByronScript} script
     * @returns {SpendingData}
     */
    static new_spending_data_script(script) {
        _assertClass(script, ByronScript);
        const ret = wasm.spendingdata_new_spending_data_script(script.__wbg_ptr);
        return SpendingData.__wrap(ret);
    }
    /**
     * @param {PublicKey} redeem
     * @returns {SpendingData}
     */
    static new_spending_data_redeem(redeem) {
        _assertClass(redeem, PublicKey);
        const ret = wasm.spendingdata_new_spending_data_redeem(redeem.__wbg_ptr);
        return SpendingData.__wrap(ret);
    }
    /**
     * @returns {SpendingDataKind}
     */
    kind() {
        const ret = wasm.spendingdata_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Bip32PublicKey | undefined}
     */
    as_spending_data_pub_key() {
        const ret = wasm.spendingdata_as_spending_data_pub_key(this.__wbg_ptr);
        return ret === 0 ? undefined : Bip32PublicKey.__wrap(ret);
    }
    /**
     * @returns {ByronScript | undefined}
     */
    as_spending_data_script() {
        const ret = wasm.spendingdata_as_spending_data_script(this.__wbg_ptr);
        return ret === 0 ? undefined : ByronScript.__wrap(ret);
    }
    /**
     * @returns {PublicKey | undefined}
     */
    as_spending_data_redeem() {
        const ret = wasm.spendingdata_as_spending_data_redeem(this.__wbg_ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
}

const StakeCredentialListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakecredentiallist_free(ptr >>> 0, 1));

export class StakeCredentialList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeCredentialList.prototype);
        obj.__wbg_ptr = ptr;
        StakeCredentialListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeCredentialListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakecredentiallist_free(ptr, 0);
    }
    /**
     * @returns {StakeCredentialList}
     */
    static new() {
        const ret = wasm.stakecredentiallist_new();
        return StakeCredentialList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.stakecredentiallist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Credential}
     */
    get(index) {
        const ret = wasm.stakecredentiallist_get(this.__wbg_ptr, index);
        return Credential.__wrap(ret);
    }
    /**
     * @param {Credential} elem
     */
    add(elem) {
        _assertClass(elem, Credential);
        wasm.stakecredentiallist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const StakeDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakedelegation_free(ptr >>> 0, 1));

export class StakeDelegation {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeDelegation.prototype);
        obj.__wbg_ptr = ptr;
        StakeDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeDelegationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakedelegation_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakedelegation_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakedelegation_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeDelegation}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakedelegation_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDelegation.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakedelegation_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakedelegation_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeDelegation}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakedelegation_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDelegation.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakedelegation_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakedelegation_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeDelegation}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakedelegation_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDelegation.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakedelegation_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    pool() {
        const ret = wasm.stakedelegation_pool(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @returns {StakeDelegation}
     */
    static new(stake_credential, pool) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.stakedelegation_new(stake_credential.__wbg_ptr, pool.__wbg_ptr);
        return StakeDelegation.__wrap(ret);
    }
}

const StakeDeregistrationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakederegistration_free(ptr >>> 0, 1));

export class StakeDeregistration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeDeregistration.prototype);
        obj.__wbg_ptr = ptr;
        StakeDeregistrationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeDeregistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakederegistration_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakederegistration_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakederegistration_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeDeregistration}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakederegistration_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDeregistration.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakederegistration_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakederegistration_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeDeregistration}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakederegistration_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDeregistration.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakederegistration_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakederegistration_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeDeregistration}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakederegistration_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDeregistration.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakederegistration_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @param {Credential} stake_credential
     * @returns {StakeDeregistration}
     */
    static new(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.stakederegistration_new(stake_credential.__wbg_ptr);
        return StakeDeregistration.__wrap(ret);
    }
}

const StakeDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakedistribution_free(ptr >>> 0, 1));

export class StakeDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeDistribution.prototype);
        obj.__wbg_ptr = ptr;
        StakeDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakedistribution_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakedistribution_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeDistribution}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakedistribution_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDistribution.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakedistribution_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeDistribution}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakedistribution_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeDistribution.__wrap(ret[0]);
    }
    /**
     * @param {StakeholderId} stakeholder_id
     * @returns {StakeDistribution}
     */
    static new_single_key(stakeholder_id) {
        _assertClass(stakeholder_id, StakeholderId);
        const ret = wasm.stakedistribution_new_single_key(stakeholder_id.__wbg_ptr);
        return StakeDistribution.__wrap(ret);
    }
    /**
     * @returns {StakeDistribution}
     */
    static new_bootstrap_era() {
        const ret = wasm.stakedistribution_new_bootstrap_era();
        return StakeDistribution.__wrap(ret);
    }
    /**
     * @returns {StakeDistributionKind}
     */
    kind() {
        const ret = wasm.stakedistribution_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {StakeholderId | undefined}
     */
    as_single_key() {
        const ret = wasm.stakedistribution_as_single_key(this.__wbg_ptr);
        return ret === 0 ? undefined : StakeholderId.__wrap(ret);
    }
}

const StakeRegDelegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakeregdelegcert_free(ptr >>> 0, 1));

export class StakeRegDelegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeRegDelegCert.prototype);
        obj.__wbg_ptr = ptr;
        StakeRegDelegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeregdelegcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakeregdelegcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakeregdelegcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeRegDelegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregdelegcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegDelegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakeregdelegcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakeregdelegcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeRegDelegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregdelegcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakeregdelegcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakeregdelegcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeRegDelegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregdelegcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakeregdelegcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    pool() {
        const ret = wasm.stakeregdelegcert_pool(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.stakeregdelegcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {bigint} deposit
     * @returns {StakeRegDelegCert}
     */
    static new(stake_credential, pool, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        const ret = wasm.stakeregdelegcert_new(stake_credential.__wbg_ptr, pool.__wbg_ptr, deposit);
        return StakeRegDelegCert.__wrap(ret);
    }
}

const StakeRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakeregistration_free(ptr >>> 0, 1));

export class StakeRegistration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeRegistration.prototype);
        obj.__wbg_ptr = ptr;
        StakeRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeRegistrationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeregistration_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakeregistration_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakeregistration_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeRegistration}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregistration_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegistration.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakeregistration_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakeregistration_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeRegistration}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregistration_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakeregistration_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakeregistration_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeRegistration}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeregistration_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeRegistration.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakeregistration_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @param {Credential} stake_credential
     * @returns {StakeRegistration}
     */
    static new(stake_credential) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.stakeregistration_new(stake_credential.__wbg_ptr);
        return StakeRegistration.__wrap(ret);
    }
}

const StakeVoteDelegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakevotedelegcert_free(ptr >>> 0, 1));

export class StakeVoteDelegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeVoteDelegCert.prototype);
        obj.__wbg_ptr = ptr;
        StakeVoteDelegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeVoteDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakevotedelegcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakevotedelegcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakevotedelegcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeVoteDelegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevotedelegcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteDelegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakevotedelegcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakevotedelegcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeVoteDelegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevotedelegcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakevotedelegcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakevotedelegcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeVoteDelegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevotedelegcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakevotedelegcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    pool() {
        const ret = wasm.stakevotedelegcert_pool(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    d_rep() {
        const ret = wasm.stakevotedelegcert_d_rep(this.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {DRep} d_rep
     * @returns {StakeVoteDelegCert}
     */
    static new(stake_credential, pool, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.stakevotedelegcert_new(stake_credential.__wbg_ptr, pool.__wbg_ptr, d_rep.__wbg_ptr);
        return StakeVoteDelegCert.__wrap(ret);
    }
}

const StakeVoteRegDelegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakevoteregdelegcert_free(ptr >>> 0, 1));

export class StakeVoteRegDelegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeVoteRegDelegCert.prototype);
        obj.__wbg_ptr = ptr;
        StakeVoteRegDelegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeVoteRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakevoteregdelegcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.stakevoteregdelegcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.stakevoteregdelegcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {StakeVoteRegDelegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevoteregdelegcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakevoteregdelegcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakevoteregdelegcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {StakeVoteRegDelegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevoteregdelegcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.stakevoteregdelegcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.stakevoteregdelegcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {StakeVoteRegDelegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakevoteregdelegcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeVoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.stakevoteregdelegcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash}
     */
    pool() {
        const ret = wasm.stakevoteregdelegcert_pool(this.__wbg_ptr);
        return Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    d_rep() {
        const ret = wasm.stakevoteregdelegcert_d_rep(this.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.stakevoteregdelegcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {Ed25519KeyHash} pool
     * @param {DRep} d_rep
     * @param {bigint} deposit
     * @returns {StakeVoteRegDelegCert}
     */
    static new(stake_credential, pool, d_rep, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(pool, Ed25519KeyHash);
        _assertClass(d_rep, DRep);
        const ret = wasm.stakevoteregdelegcert_new(stake_credential.__wbg_ptr, pool.__wbg_ptr, d_rep.__wbg_ptr, deposit);
        return StakeVoteRegDelegCert.__wrap(ret);
    }
}

const StakeholderIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stakeholderid_free(ptr >>> 0, 1));

export class StakeholderId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(StakeholderId.prototype);
        obj.__wbg_ptr = ptr;
        StakeholderIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StakeholderIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stakeholderid_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.stakeholderid_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {StakeholderId}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeholderid_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeholderId.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.stakeholderid_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {StakeholderId}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeholderid_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeholderId.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.stakeholderid_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {StakeholderId}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.stakeholderid_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return StakeholderId.__wrap(ret[0]);
    }
    /**
     * @param {Bip32PublicKey} pubk
     * @returns {StakeholderId}
     */
    static new(pubk) {
        _assertClass(pubk, Bip32PublicKey);
        const ret = wasm.stakeholderid_new(pubk.__wbg_ptr);
        return StakeholderId.__wrap(ret);
    }
}

const SubCoinFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_subcoin_free(ptr >>> 0, 1));

export class SubCoin {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SubCoinFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_subcoin_free(ptr, 0);
    }
    /**
     * Converts base 10 floats to SubCoin.
     * This is the format used by blockfrost for ex units
     * Warning: If the passed in float was not meant to be base 10
     * this might result in a slightly inaccurate fraction.
     * @param {number} f
     * @returns {Rational}
     */
    static from_base10_f32(f) {
        const ret = wasm.subcoin_from_base10_f32(f);
        return Rational.__wrap(ret);
    }
}

const TransactionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transaction_free(ptr >>> 0, 1));

export class Transaction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Transaction.prototype);
        obj.__wbg_ptr = ptr;
        TransactionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transaction_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transaction_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.transaction_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Transaction}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transaction_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Transaction.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transaction_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transaction_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Transaction}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transaction_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Transaction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transaction_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.transaction_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Transaction}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transaction_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Transaction.__wrap(ret[0]);
    }
    /**
     * @returns {TransactionBody}
     */
    body() {
        const ret = wasm.transaction_body(this.__wbg_ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
     * @returns {TransactionWitnessSet}
     */
    witness_set() {
        const ret = wasm.transaction_witness_set(this.__wbg_ptr);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    is_valid() {
        const ret = wasm.transaction_is_valid(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {AuxiliaryData | undefined}
     */
    auxiliary_data() {
        const ret = wasm.transaction_auxiliary_data(this.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
     * @param {TransactionBody} body
     * @param {TransactionWitnessSet} witness_set
     * @param {boolean} is_valid
     * @param {AuxiliaryData | null} [auxiliary_data]
     * @returns {Transaction}
     */
    static new(body, witness_set, is_valid, auxiliary_data) {
        _assertClass(body, TransactionBody);
        _assertClass(witness_set, TransactionWitnessSet);
        let ptr0 = 0;
        if (!isLikeNone(auxiliary_data)) {
            _assertClass(auxiliary_data, AuxiliaryData);
            ptr0 = auxiliary_data.__destroy_into_raw();
        }
        const ret = wasm.transaction_new(body.__wbg_ptr, witness_set.__wbg_ptr, is_valid, ptr0);
        return Transaction.__wrap(ret);
    }
}

const TransactionBodyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionbody_free(ptr >>> 0, 1));

export class TransactionBody {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionBody.prototype);
        obj.__wbg_ptr = ptr;
        TransactionBodyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionBodyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbody_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactionbody_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.transactionbody_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionBody}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionbody_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionBody.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionbody_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionbody_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TransactionBody}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionbody_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionBody.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transactionbody_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.transactionbody_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TransactionBody}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionbody_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionBody.__wrap(ret[0]);
    }
    /**
     * @returns {TransactionInputList}
     */
    inputs() {
        const ret = wasm.transactionbody_inputs(this.__wbg_ptr);
        return TransactionInputList.__wrap(ret);
    }
    /**
     * @returns {TransactionOutputList}
     */
    outputs() {
        const ret = wasm.transactionbody_outputs(this.__wbg_ptr);
        return TransactionOutputList.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    fee() {
        const ret = wasm.transactionbody_fee(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} ttl
     */
    set_ttl(ttl) {
        wasm.transactionbody_set_ttl(this.__wbg_ptr, ttl);
    }
    /**
     * @returns {bigint | undefined}
     */
    ttl() {
        const ret = wasm.transactionbody_ttl(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {CertificateList} certs
     */
    set_certs(certs) {
        _assertClass(certs, CertificateList);
        wasm.transactionbody_set_certs(this.__wbg_ptr, certs.__wbg_ptr);
    }
    /**
     * @returns {CertificateList | undefined}
     */
    certs() {
        const ret = wasm.transactionbody_certs(this.__wbg_ptr);
        return ret === 0 ? undefined : CertificateList.__wrap(ret);
    }
    /**
     * @param {MapRewardAccountToCoin} withdrawals
     */
    set_withdrawals(withdrawals) {
        _assertClass(withdrawals, MapRewardAccountToCoin);
        wasm.transactionbody_set_withdrawals(this.__wbg_ptr, withdrawals.__wbg_ptr);
    }
    /**
     * @returns {MapRewardAccountToCoin | undefined}
     */
    withdrawals() {
        const ret = wasm.transactionbody_withdrawals(this.__wbg_ptr);
        return ret === 0 ? undefined : MapRewardAccountToCoin.__wrap(ret);
    }
    /**
     * @param {AuxiliaryDataHash} auxiliary_data_hash
     */
    set_auxiliary_data_hash(auxiliary_data_hash) {
        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);
        wasm.transactionbody_set_auxiliary_data_hash(this.__wbg_ptr, auxiliary_data_hash.__wbg_ptr);
    }
    /**
     * @returns {AuxiliaryDataHash | undefined}
     */
    auxiliary_data_hash() {
        const ret = wasm.transactionbody_auxiliary_data_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);
    }
    /**
     * @param {bigint} validity_interval_start
     */
    set_validity_interval_start(validity_interval_start) {
        wasm.transactionbody_set_validity_interval_start(this.__wbg_ptr, validity_interval_start);
    }
    /**
     * @returns {bigint | undefined}
     */
    validity_interval_start() {
        const ret = wasm.transactionbody_validity_interval_start(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {Mint} mint
     */
    set_mint(mint) {
        _assertClass(mint, Mint);
        wasm.transactionbody_set_mint(this.__wbg_ptr, mint.__wbg_ptr);
    }
    /**
     * @returns {Mint | undefined}
     */
    mint() {
        const ret = wasm.transactionbody_mint(this.__wbg_ptr);
        return ret === 0 ? undefined : Mint.__wrap(ret);
    }
    /**
     * @param {ScriptDataHash} script_data_hash
     */
    set_script_data_hash(script_data_hash) {
        _assertClass(script_data_hash, ScriptDataHash);
        wasm.transactionbody_set_script_data_hash(this.__wbg_ptr, script_data_hash.__wbg_ptr);
    }
    /**
     * @returns {ScriptDataHash | undefined}
     */
    script_data_hash() {
        const ret = wasm.transactionbody_script_data_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);
    }
    /**
     * @param {TransactionInputList} collateral_inputs
     */
    set_collateral_inputs(collateral_inputs) {
        _assertClass(collateral_inputs, TransactionInputList);
        wasm.transactionbody_set_collateral_inputs(this.__wbg_ptr, collateral_inputs.__wbg_ptr);
    }
    /**
     * @returns {TransactionInputList | undefined}
     */
    collateral_inputs() {
        const ret = wasm.transactionbody_collateral_inputs(this.__wbg_ptr);
        return ret === 0 ? undefined : TransactionInputList.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHashList} required_signers
     */
    set_required_signers(required_signers) {
        _assertClass(required_signers, Ed25519KeyHashList);
        wasm.transactionbody_set_required_signers(this.__wbg_ptr, required_signers.__wbg_ptr);
    }
    /**
     * @returns {Ed25519KeyHashList | undefined}
     */
    required_signers() {
        const ret = wasm.transactionbody_required_signers(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHashList.__wrap(ret);
    }
    /**
     * @param {NetworkId} network_id
     */
    set_network_id(network_id) {
        _assertClass(network_id, NetworkId);
        wasm.transactionbody_set_network_id(this.__wbg_ptr, network_id.__wbg_ptr);
    }
    /**
     * @returns {NetworkId | undefined}
     */
    network_id() {
        const ret = wasm.transactionbody_network_id(this.__wbg_ptr);
        return ret === 0 ? undefined : NetworkId.__wrap(ret);
    }
    /**
     * @param {TransactionOutput} collateral_return
     */
    set_collateral_return(collateral_return) {
        _assertClass(collateral_return, TransactionOutput);
        wasm.transactionbody_set_collateral_return(this.__wbg_ptr, collateral_return.__wbg_ptr);
    }
    /**
     * @returns {TransactionOutput | undefined}
     */
    collateral_return() {
        const ret = wasm.transactionbody_collateral_return(this.__wbg_ptr);
        return ret === 0 ? undefined : TransactionOutput.__wrap(ret);
    }
    /**
     * @param {bigint} total_collateral
     */
    set_total_collateral(total_collateral) {
        wasm.transactionbody_set_total_collateral(this.__wbg_ptr, total_collateral);
    }
    /**
     * @returns {bigint | undefined}
     */
    total_collateral() {
        const ret = wasm.transactionbody_total_collateral(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {TransactionInputList} reference_inputs
     */
    set_reference_inputs(reference_inputs) {
        _assertClass(reference_inputs, TransactionInputList);
        wasm.transactionbody_set_reference_inputs(this.__wbg_ptr, reference_inputs.__wbg_ptr);
    }
    /**
     * @returns {TransactionInputList | undefined}
     */
    reference_inputs() {
        const ret = wasm.transactionbody_reference_inputs(this.__wbg_ptr);
        return ret === 0 ? undefined : TransactionInputList.__wrap(ret);
    }
    /**
     * @param {VotingProcedures} voting_procedures
     */
    set_voting_procedures(voting_procedures) {
        _assertClass(voting_procedures, VotingProcedures);
        wasm.transactionbody_set_voting_procedures(this.__wbg_ptr, voting_procedures.__wbg_ptr);
    }
    /**
     * @returns {VotingProcedures | undefined}
     */
    voting_procedures() {
        const ret = wasm.transactionbody_voting_procedures(this.__wbg_ptr);
        return ret === 0 ? undefined : VotingProcedures.__wrap(ret);
    }
    /**
     * @param {ProposalProcedureList} proposal_procedures
     */
    set_proposal_procedures(proposal_procedures) {
        _assertClass(proposal_procedures, ProposalProcedureList);
        wasm.transactionbody_set_proposal_procedures(this.__wbg_ptr, proposal_procedures.__wbg_ptr);
    }
    /**
     * @returns {ProposalProcedureList | undefined}
     */
    proposal_procedures() {
        const ret = wasm.transactionbody_proposal_procedures(this.__wbg_ptr);
        return ret === 0 ? undefined : ProposalProcedureList.__wrap(ret);
    }
    /**
     * @param {bigint} current_treasury_value
     */
    set_current_treasury_value(current_treasury_value) {
        wasm.transactionbody_set_current_treasury_value(this.__wbg_ptr, current_treasury_value);
    }
    /**
     * @returns {bigint | undefined}
     */
    current_treasury_value() {
        const ret = wasm.transactionbody_current_treasury_value(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint} donation
     */
    set_donation(donation) {
        wasm.transactionbody_set_donation(this.__wbg_ptr, donation);
    }
    /**
     * @returns {bigint | undefined}
     */
    donation() {
        const ret = wasm.transactionbody_donation(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {TransactionInputList} inputs
     * @param {TransactionOutputList} outputs
     * @param {bigint} fee
     * @returns {TransactionBody}
     */
    static new(inputs, outputs, fee) {
        _assertClass(inputs, TransactionInputList);
        _assertClass(outputs, TransactionOutputList);
        const ret = wasm.transactionbody_new(inputs.__wbg_ptr, outputs.__wbg_ptr, fee);
        return TransactionBody.__wrap(ret);
    }
}

const TransactionBodyListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionbodylist_free(ptr >>> 0, 1));

export class TransactionBodyList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionBodyList.prototype);
        obj.__wbg_ptr = ptr;
        TransactionBodyListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionBodyListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbodylist_free(ptr, 0);
    }
    /**
     * @returns {TransactionBodyList}
     */
    static new() {
        const ret = wasm.transactionbodylist_new();
        return TransactionBodyList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactionbodylist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionBody}
     */
    get(index) {
        const ret = wasm.transactionbodylist_get(this.__wbg_ptr, index);
        return TransactionBody.__wrap(ret);
    }
    /**
     * @param {TransactionBody} elem
     */
    add(elem) {
        _assertClass(elem, TransactionBody);
        wasm.transactionbodylist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const TransactionBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilder_free(ptr >>> 0, 1));

export class TransactionBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TransactionBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilder_free(ptr, 0);
    }
    /**
     * This automatically selects and adds inputs from {inputs} consisting of just enough to cover
     * the outputs that have already been added.
     * This should be called after adding all certs/outputs/etc and will be an error otherwise.
     * Uses CIP2: https://github.com/cardano-foundation/CIPs/blob/master/CIP-0002/CIP-0002.md
     * Adding a change output must be called after via TransactionBuilder::add_change_if_needed()
     * This function, diverging from CIP2, takes into account fees and will attempt to add additional
     * inputs to cover the minimum fees. This does not, however, set the txbuilder's fee.
     * @param {CoinSelectionStrategyCIP2} strategy
     */
    select_utxos(strategy) {
        const ret = wasm.transactionbuilder_select_utxos(this.__wbg_ptr, strategy);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {InputBuilderResult} result
     */
    add_input(result) {
        _assertClass(result, InputBuilderResult);
        const ret = wasm.transactionbuilder_add_input(this.__wbg_ptr, result.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {InputBuilderResult} result
     */
    add_utxo(result) {
        _assertClass(result, InputBuilderResult);
        wasm.transactionbuilder_add_utxo(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * calculates how much the fee would increase if you added a given output
     * @param {InputBuilderResult} result
     * @returns {bigint}
     */
    fee_for_input(result) {
        _assertClass(result, InputBuilderResult);
        const ret = wasm.transactionbuilder_fee_for_input(this.__wbg_ptr, result.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInt.asUintN(64, ret[0]);
    }
    /**
     * Add a reference input. Must be called BEFORE adding anything (inputs, certs, etc) that refer to this reference input.
     * @param {TransactionUnspentOutput} utxo
     */
    add_reference_input(utxo) {
        _assertClass(utxo, TransactionUnspentOutput);
        wasm.transactionbuilder_add_reference_input(this.__wbg_ptr, utxo.__wbg_ptr);
    }
    /**
     * Add explicit output via a TransactionOutput object
     * @param {SingleOutputBuilderResult} builder_result
     */
    add_output(builder_result) {
        _assertClass(builder_result, SingleOutputBuilderResult);
        const ret = wasm.transactionbuilder_add_output(this.__wbg_ptr, builder_result.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * calculates how much the fee would increase if you added a given output
     * @param {SingleOutputBuilderResult} builder
     * @returns {bigint}
     */
    fee_for_output(builder) {
        _assertClass(builder, SingleOutputBuilderResult);
        const ret = wasm.transactionbuilder_fee_for_output(this.__wbg_ptr, builder.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInt.asUintN(64, ret[0]);
    }
    /**
     * @param {bigint} fee
     */
    set_fee(fee) {
        wasm.transactionbuilder_set_fee(this.__wbg_ptr, fee);
    }
    /**
     * @param {bigint} donation
     */
    set_donation(donation) {
        wasm.transactionbuilder_set_donation(this.__wbg_ptr, donation);
    }
    /**
     * @param {bigint} current_treasury_value
     */
    set_current_treasury_value(current_treasury_value) {
        wasm.transactionbuilder_set_current_treasury_value(this.__wbg_ptr, current_treasury_value);
    }
    /**
     * @param {bigint} ttl
     */
    set_ttl(ttl) {
        wasm.transactionbuilder_set_ttl(this.__wbg_ptr, ttl);
    }
    /**
     * @param {bigint} validity_start_interval
     */
    set_validity_start_interval(validity_start_interval) {
        wasm.transactionbuilder_set_validity_start_interval(this.__wbg_ptr, validity_start_interval);
    }
    /**
     * @param {CertificateBuilderResult} result
     */
    add_cert(result) {
        _assertClass(result, CertificateBuilderResult);
        wasm.transactionbuilder_add_cert(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @param {ProposalBuilderResult} result
     */
    add_proposal(result) {
        _assertClass(result, ProposalBuilderResult);
        var ptr0 = result.__destroy_into_raw();
        wasm.transactionbuilder_add_proposal(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {VoteBuilderResult} result
     */
    add_vote(result) {
        _assertClass(result, VoteBuilderResult);
        var ptr0 = result.__destroy_into_raw();
        wasm.transactionbuilder_add_vote(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {MapRewardAccountToCoin | undefined}
     */
    get_withdrawals() {
        const ret = wasm.transactionbuilder_get_withdrawals(this.__wbg_ptr);
        return ret === 0 ? undefined : MapRewardAccountToCoin.__wrap(ret);
    }
    /**
     * @param {WithdrawalBuilderResult} result
     */
    add_withdrawal(result) {
        _assertClass(result, WithdrawalBuilderResult);
        wasm.transactionbuilder_add_withdrawal(this.__wbg_ptr, result.__wbg_ptr);
    }
    /**
     * @returns {AuxiliaryData | undefined}
     */
    get_auxiliary_data() {
        const ret = wasm.transactionbuilder_get_auxiliary_data(this.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
     * @param {AuxiliaryData} new_aux_data
     */
    set_auxiliary_data(new_aux_data) {
        _assertClass(new_aux_data, AuxiliaryData);
        wasm.transactionbuilder_set_auxiliary_data(this.__wbg_ptr, new_aux_data.__wbg_ptr);
    }
    /**
     * @param {AuxiliaryData} new_aux_data
     */
    add_auxiliary_data(new_aux_data) {
        _assertClass(new_aux_data, AuxiliaryData);
        wasm.transactionbuilder_add_auxiliary_data(this.__wbg_ptr, new_aux_data.__wbg_ptr);
    }
    /**
     * @param {MintBuilderResult} result
     */
    add_mint(result) {
        _assertClass(result, MintBuilderResult);
        const ret = wasm.transactionbuilder_add_mint(this.__wbg_ptr, result.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * Returns a copy of the current mint state in the builder
     * @returns {Mint | undefined}
     */
    get_mint() {
        const ret = wasm.transactionbuilder_get_mint(this.__wbg_ptr);
        return ret === 0 ? undefined : Mint.__wrap(ret);
    }
    /**
     * @param {TransactionBuilderConfig} cfg
     * @returns {TransactionBuilder}
     */
    static new(cfg) {
        _assertClass(cfg, TransactionBuilderConfig);
        const ret = wasm.transactionbuilder_new(cfg.__wbg_ptr);
        return TransactionBuilder.__wrap(ret);
    }
    /**
     * @param {InputBuilderResult} result
     */
    add_collateral(result) {
        _assertClass(result, InputBuilderResult);
        const ret = wasm.transactionbuilder_add_collateral(this.__wbg_ptr, result.__wbg_ptr);
        if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
        }
    }
    /**
     * @param {Ed25519KeyHash} hash
     */
    add_required_signer(hash) {
        _assertClass(hash, Ed25519KeyHash);
        wasm.transactionbuilder_add_required_signer(this.__wbg_ptr, hash.__wbg_ptr);
    }
    /**
     * @param {NetworkId} network_id
     */
    set_network_id(network_id) {
        _assertClass(network_id, NetworkId);
        wasm.transactionbuilder_set_network_id(this.__wbg_ptr, network_id.__wbg_ptr);
    }
    /**
     * @returns {NetworkId | undefined}
     */
    network_id() {
        const ret = wasm.transactionbuilder_network_id(this.__wbg_ptr);
        return ret === 0 ? undefined : NetworkId.__wrap(ret);
    }
    /**
     * does not include refunds or withdrawals
     * @returns {Value}
     */
    get_explicit_input() {
        const ret = wasm.transactionbuilder_get_explicit_input(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * withdrawals and refunds
     * @returns {Value}
     */
    get_implicit_input() {
        const ret = wasm.transactionbuilder_get_implicit_input(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * Return explicit input plus implicit input plus mint
     * @returns {Value}
     */
    get_total_input() {
        const ret = wasm.transactionbuilder_get_total_input(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * Return explicit output plus implicit output plus burn (does not consider fee directly)
     * @returns {Value}
     */
    get_total_output() {
        const ret = wasm.transactionbuilder_get_total_output(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * does not include fee
     * @returns {Value}
     */
    get_explicit_output() {
        const ret = wasm.transactionbuilder_get_explicit_output(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    get_deposit() {
        const ret = wasm.transactionbuilder_get_deposit(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInt.asUintN(64, ret[0]);
    }
    /**
     * @returns {bigint | undefined}
     */
    get_fee_if_set() {
        const ret = wasm.transactionbuilder_get_fee_if_set(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {TransactionOutput} output
     */
    set_collateral_return(output) {
        _assertClass(output, TransactionOutput);
        wasm.transactionbuilder_set_collateral_return(this.__wbg_ptr, output.__wbg_ptr);
    }
    /**
     * @returns {number}
     */
    full_size() {
        const ret = wasm.transactionbuilder_full_size(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] >>> 0;
    }
    /**
     * @returns {Uint32Array}
     */
    output_sizes() {
        const ret = wasm.transactionbuilder_output_sizes(this.__wbg_ptr);
        var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Builds the transaction and moves to the next step redeemer units can be added and a draft tx can
     * be evaluated
     * NOTE: is_valid set to true
     * @param {ChangeSelectionAlgo} algo
     * @param {Address} change_address
     * @returns {TxRedeemerBuilder}
     */
    build_for_evaluation(algo, change_address) {
        _assertClass(change_address, Address);
        const ret = wasm.transactionbuilder_build_for_evaluation(this.__wbg_ptr, algo, change_address.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TxRedeemerBuilder.__wrap(ret[0]);
    }
    /**
     * Builds the transaction and moves to the next step where any real witness can be added
     * NOTE: is_valid set to true
     * @param {ChangeSelectionAlgo} algo
     * @param {Address} change_address
     * @returns {SignedTxBuilder}
     */
    build(algo, change_address) {
        _assertClass(change_address, Address);
        const ret = wasm.transactionbuilder_build(this.__wbg_ptr, algo, change_address.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SignedTxBuilder.__wrap(ret[0]);
    }
    /**
     * used to override the exunit values initially provided when adding inputs
     * @param {RedeemerWitnessKey} redeemer
     * @param {ExUnits} ex_units
     */
    set_exunits(redeemer, ex_units) {
        _assertClass(redeemer, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.transactionbuilder_set_exunits(this.__wbg_ptr, redeemer.__wbg_ptr, ex_units.__wbg_ptr);
    }
    /**
     * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it
     * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)
     * this is done to simplify the library code, but can be fixed later
     * @param {boolean} script_calulation
     * @returns {bigint}
     */
    min_fee(script_calulation) {
        const ret = wasm.transactionbuilder_min_fee(this.__wbg_ptr, script_calulation);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return BigInt.asUintN(64, ret[0]);
    }
    /**
     * Warning: this function will mutate the /fee/ field
     * Make sure to call this function last after setting all other tx-body properties
     * Editing inputs, outputs, mint, etc. after change been calculated
     * might cause a mismatch in calculated fee versus the required fee
     * @param {Address} address
     * @param {boolean} include_exunits
     * @returns {boolean}
     */
    add_change_if_needed(address, include_exunits) {
        _assertClass(address, Address);
        const ret = wasm.transactionbuilder_add_change_if_needed(this.__wbg_ptr, address.__wbg_ptr, include_exunits);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return ret[0] !== 0;
    }
}

const TransactionBuilderConfigFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilderconfig_free(ptr >>> 0, 1));

export class TransactionBuilderConfig {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionBuilderConfig.prototype);
        obj.__wbg_ptr = ptr;
        TransactionBuilderConfigFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionBuilderConfigFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilderconfig_free(ptr, 0);
    }
}

const TransactionBuilderConfigBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionbuilderconfigbuilder_free(ptr >>> 0, 1));

export class TransactionBuilderConfigBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionBuilderConfigBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TransactionBuilderConfigBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionBuilderConfigBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionbuilderconfigbuilder_free(ptr, 0);
    }
    /**
     * @returns {TransactionBuilderConfigBuilder}
     */
    static new() {
        const ret = wasm.transactionbuilderconfigbuilder_new();
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {LinearFee} fee_algo
     * @returns {TransactionBuilderConfigBuilder}
     */
    fee_algo(fee_algo) {
        _assertClass(fee_algo, LinearFee);
        const ret = wasm.transactionbuilderconfigbuilder_fee_algo(this.__wbg_ptr, fee_algo.__wbg_ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {bigint} coins_per_utxo_byte
     * @returns {TransactionBuilderConfigBuilder}
     */
    coins_per_utxo_byte(coins_per_utxo_byte) {
        const ret = wasm.transactionbuilderconfigbuilder_coins_per_utxo_byte(this.__wbg_ptr, coins_per_utxo_byte);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {bigint} pool_deposit
     * @returns {TransactionBuilderConfigBuilder}
     */
    pool_deposit(pool_deposit) {
        const ret = wasm.transactionbuilderconfigbuilder_pool_deposit(this.__wbg_ptr, pool_deposit);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {bigint} key_deposit
     * @returns {TransactionBuilderConfigBuilder}
     */
    key_deposit(key_deposit) {
        const ret = wasm.transactionbuilderconfigbuilder_key_deposit(this.__wbg_ptr, key_deposit);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {number} max_value_size
     * @returns {TransactionBuilderConfigBuilder}
     */
    max_value_size(max_value_size) {
        const ret = wasm.transactionbuilderconfigbuilder_max_value_size(this.__wbg_ptr, max_value_size);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {number} max_tx_size
     * @returns {TransactionBuilderConfigBuilder}
     */
    max_tx_size(max_tx_size) {
        const ret = wasm.transactionbuilderconfigbuilder_max_tx_size(this.__wbg_ptr, max_tx_size);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {boolean} prefer_pure_change
     * @returns {TransactionBuilderConfigBuilder}
     */
    prefer_pure_change(prefer_pure_change) {
        const ret = wasm.transactionbuilderconfigbuilder_prefer_pure_change(this.__wbg_ptr, prefer_pure_change);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {ExUnitPrices} ex_unit_prices
     * @returns {TransactionBuilderConfigBuilder}
     */
    ex_unit_prices(ex_unit_prices) {
        _assertClass(ex_unit_prices, ExUnitPrices);
        const ret = wasm.transactionbuilderconfigbuilder_ex_unit_prices(this.__wbg_ptr, ex_unit_prices.__wbg_ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {CostModels} cost_models
     * @returns {TransactionBuilderConfigBuilder}
     */
    cost_models(cost_models) {
        _assertClass(cost_models, CostModels);
        const ret = wasm.transactionbuilderconfigbuilder_cost_models(this.__wbg_ptr, cost_models.__wbg_ptr);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {number} collateral_percentage
     * @returns {TransactionBuilderConfigBuilder}
     */
    collateral_percentage(collateral_percentage) {
        const ret = wasm.transactionbuilderconfigbuilder_collateral_percentage(this.__wbg_ptr, collateral_percentage);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @param {number} max_collateral_inputs
     * @returns {TransactionBuilderConfigBuilder}
     */
    max_collateral_inputs(max_collateral_inputs) {
        const ret = wasm.transactionbuilderconfigbuilder_max_collateral_inputs(this.__wbg_ptr, max_collateral_inputs);
        return TransactionBuilderConfigBuilder.__wrap(ret);
    }
    /**
     * @returns {TransactionBuilderConfig}
     */
    build() {
        const ret = wasm.transactionbuilderconfigbuilder_build(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionBuilderConfig.__wrap(ret[0]);
    }
}

const TransactionHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionhash_free(ptr >>> 0, 1));

export class TransactionHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionHash.prototype);
        obj.__wbg_ptr = ptr;
        TransactionHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.transactionhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {TransactionHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.transactionhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {TransactionHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {TransactionHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionHash.__wrap(ret[0]);
    }
}

const TransactionInputFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactioninput_free(ptr >>> 0, 1));

export class TransactionInput {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionInput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionInputFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionInputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactioninput_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactioninput_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.transactioninput_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionInput}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactioninput_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionInput.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactioninput_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactioninput_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TransactionInput}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactioninput_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionInput.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transactioninput_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.transactioninput_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TransactionInput}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactioninput_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionInput.__wrap(ret[0]);
    }
    /**
     * @returns {TransactionHash}
     */
    transaction_id() {
        const ret = wasm.transactioninput_transaction_id(this.__wbg_ptr);
        return TransactionHash.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    index() {
        const ret = wasm.transactioninput_index(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {TransactionHash} transaction_id
     * @param {bigint} index
     * @returns {TransactionInput}
     */
    static new(transaction_id, index) {
        _assertClass(transaction_id, TransactionHash);
        const ret = wasm.transactioninput_new(transaction_id.__wbg_ptr, index);
        return TransactionInput.__wrap(ret);
    }
}

const TransactionInputListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactioninputlist_free(ptr >>> 0, 1));

export class TransactionInputList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionInputList.prototype);
        obj.__wbg_ptr = ptr;
        TransactionInputListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionInputListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactioninputlist_free(ptr, 0);
    }
    /**
     * @returns {TransactionInputList}
     */
    static new() {
        const ret = wasm.transactioninputlist_new();
        return TransactionInputList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactioninputlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionInput}
     */
    get(index) {
        const ret = wasm.transactioninputlist_get(this.__wbg_ptr, index);
        return TransactionInput.__wrap(ret);
    }
    /**
     * @param {TransactionInput} elem
     */
    add(elem) {
        _assertClass(elem, TransactionInput);
        wasm.transactioninputlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const TransactionMetadatumFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatum_free(ptr >>> 0, 1));

export class TransactionMetadatum {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionMetadatum.prototype);
        obj.__wbg_ptr = ptr;
        TransactionMetadatumFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionMetadatumFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatum_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactionmetadatum_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionMetadatum}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionmetadatum_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionMetadatum.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transactionmetadatum_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_json_value() {
        const ret = wasm.transactionmetadatum_to_json_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TransactionMetadatum}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionmetadatum_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionMetadatum.__wrap(ret[0]);
    }
    /**
     * @param {MetadatumMap} map
     * @returns {TransactionMetadatum}
     */
    static new_map(map) {
        _assertClass(map, MetadatumMap);
        const ret = wasm.transactionmetadatum_new_map(map.__wbg_ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {MetadatumList} elements
     * @returns {TransactionMetadatum}
     */
    static new_list(elements) {
        _assertClass(elements, MetadatumList);
        const ret = wasm.transactionmetadatum_new_list(elements.__wbg_ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {Int} int
     * @returns {TransactionMetadatum}
     */
    static new_int(int) {
        _assertClass(int, Int);
        const ret = wasm.transactionmetadatum_new_int(int.__wbg_ptr);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionMetadatum}
     */
    static new_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionmetadatum_new_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionMetadatum.__wrap(ret[0]);
    }
    /**
     * @param {string} text
     * @returns {TransactionMetadatum}
     */
    static new_text(text) {
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionmetadatum_new_text(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionMetadatum.__wrap(ret[0]);
    }
    /**
     * @returns {TransactionMetadatumKind}
     */
    kind() {
        const ret = wasm.transactionmetadatum_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {MetadatumMap | undefined}
     */
    as_map() {
        const ret = wasm.transactionmetadatum_as_map(this.__wbg_ptr);
        return ret === 0 ? undefined : MetadatumMap.__wrap(ret);
    }
    /**
     * @returns {MetadatumList | undefined}
     */
    as_list() {
        const ret = wasm.transactionmetadatum_as_list(this.__wbg_ptr);
        return ret === 0 ? undefined : MetadatumList.__wrap(ret);
    }
    /**
     * @returns {Int | undefined}
     */
    as_int() {
        const ret = wasm.transactionmetadatum_as_int(this.__wbg_ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
     * @returns {Uint8Array | undefined}
     */
    as_bytes() {
        const ret = wasm.transactionmetadatum_as_bytes(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {string | undefined}
     */
    as_text() {
        const ret = wasm.transactionmetadatum_as_text(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
}

const TransactionMetadatumLabelsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatumlabels_free(ptr >>> 0, 1));

export class TransactionMetadatumLabels {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionMetadatumLabels.prototype);
        obj.__wbg_ptr = ptr;
        TransactionMetadatumLabelsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionMetadatumLabelsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatumlabels_free(ptr, 0);
    }
    /**
     * @returns {TransactionMetadatumLabels}
     */
    static new() {
        const ret = wasm.transactionmetadatumlabels_new();
        return TransactionMetadatumLabels.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactionmetadatumlabels_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {bigint}
     */
    get(index) {
        const ret = wasm.transactionmetadatumlabels_get(this.__wbg_ptr, index);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} elem
     */
    add(elem) {
        wasm.transactionmetadatumlabels_add(this.__wbg_ptr, elem);
    }
}

const TransactionMetadatumListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionmetadatumlist_free(ptr >>> 0, 1));

export class TransactionMetadatumList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionMetadatumList.prototype);
        obj.__wbg_ptr = ptr;
        TransactionMetadatumListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionMetadatumListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionmetadatumlist_free(ptr, 0);
    }
    /**
     * @returns {TransactionMetadatumList}
     */
    static new() {
        const ret = wasm.transactionmetadatumlist_new();
        return TransactionMetadatumList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactionmetadatumlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionMetadatum}
     */
    get(index) {
        const ret = wasm.transactionmetadatumlist_get(this.__wbg_ptr, index);
        return TransactionMetadatum.__wrap(ret);
    }
    /**
     * @param {TransactionMetadatum} elem
     */
    add(elem) {
        _assertClass(elem, TransactionMetadatum);
        wasm.transactionmetadatumlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const TransactionOutputFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionoutput_free(ptr >>> 0, 1));

export class TransactionOutput {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionOutput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutput_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactionoutput_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.transactionoutput_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionOutput}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionoutput_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionOutput.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionoutput_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionoutput_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TransactionOutput}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionoutput_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionOutput.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transactionoutput_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.transactionoutput_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TransactionOutput}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionoutput_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionOutput.__wrap(ret[0]);
    }
    /**
     * @param {AlonzoFormatTxOut} alonzo_format_tx_out
     * @returns {TransactionOutput}
     */
    static new_alonzo_format_tx_out(alonzo_format_tx_out) {
        _assertClass(alonzo_format_tx_out, AlonzoFormatTxOut);
        const ret = wasm.transactionoutput_new_alonzo_format_tx_out(alonzo_format_tx_out.__wbg_ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
     * @param {ConwayFormatTxOut} conway_format_tx_out
     * @returns {TransactionOutput}
     */
    static new_conway_format_tx_out(conway_format_tx_out) {
        _assertClass(conway_format_tx_out, ConwayFormatTxOut);
        const ret = wasm.transactionoutput_new_conway_format_tx_out(conway_format_tx_out.__wbg_ptr);
        return TransactionOutput.__wrap(ret);
    }
    /**
     * @returns {TransactionOutputKind}
     */
    kind() {
        const ret = wasm.transactionoutput_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {AlonzoFormatTxOut | undefined}
     */
    as_alonzo_format_tx_out() {
        const ret = wasm.transactionoutput_as_alonzo_format_tx_out(this.__wbg_ptr);
        return ret === 0 ? undefined : AlonzoFormatTxOut.__wrap(ret);
    }
    /**
     * @returns {ConwayFormatTxOut | undefined}
     */
    as_conway_format_tx_out() {
        const ret = wasm.transactionoutput_as_conway_format_tx_out(this.__wbg_ptr);
        return ret === 0 ? undefined : ConwayFormatTxOut.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @param {Value} amount
     * @param {DatumOption | null} [datum_option]
     * @param {Script | null} [script_reference]
     * @returns {TransactionOutput}
     */
    static new(address, amount, datum_option, script_reference) {
        _assertClass(address, Address);
        _assertClass(amount, Value);
        let ptr0 = 0;
        if (!isLikeNone(datum_option)) {
            _assertClass(datum_option, DatumOption);
            ptr0 = datum_option.__destroy_into_raw();
        }
        let ptr1 = 0;
        if (!isLikeNone(script_reference)) {
            _assertClass(script_reference, Script);
            ptr1 = script_reference.__destroy_into_raw();
        }
        const ret = wasm.transactionoutput_new(address.__wbg_ptr, amount.__wbg_ptr, ptr0, ptr1);
        return TransactionOutput.__wrap(ret);
    }
    /**
     * @returns {Address}
     */
    address() {
        const ret = wasm.transactionoutput_address(this.__wbg_ptr);
        return Address.__wrap(ret);
    }
    /**
     * @param {Address} addr
     */
    set_address(addr) {
        _assertClass(addr, Address);
        wasm.transactionoutput_set_address(this.__wbg_ptr, addr.__wbg_ptr);
    }
    /**
     * @returns {Value}
     */
    amount() {
        const ret = wasm.transactionoutput_amount(this.__wbg_ptr);
        return Value.__wrap(ret);
    }
    /**
     * @param {Value} amount
     */
    set_amount(amount) {
        _assertClass(amount, Value);
        wasm.transactionoutput_set_amount(this.__wbg_ptr, amount.__wbg_ptr);
    }
    /**
     * @returns {DatumOption | undefined}
     */
    datum() {
        const ret = wasm.transactionoutput_datum(this.__wbg_ptr);
        return ret === 0 ? undefined : DatumOption.__wrap(ret);
    }
    /**
     * Get the datum hash from a tx output if present as a hash.
     * Returns None if there is no datum, or the datum is inlined.
     * Use TransactionOutput::datum() for inlined datums.
     * @returns {DatumHash | undefined}
     */
    datum_hash() {
        const ret = wasm.transactionoutput_datum_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : DatumHash.__wrap(ret);
    }
    /**
     * @returns {Script | undefined}
     */
    script_ref() {
        const ret = wasm.transactionoutput_script_ref(this.__wbg_ptr);
        return ret === 0 ? undefined : Script.__wrap(ret);
    }
}

const TransactionOutputAmountBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputamountbuilder_free(ptr >>> 0, 1));

export class TransactionOutputAmountBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionOutputAmountBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputAmountBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputAmountBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputamountbuilder_free(ptr, 0);
    }
    /**
     * @param {Value} amount
     * @returns {TransactionOutputAmountBuilder}
     */
    with_value(amount) {
        _assertClass(amount, Value);
        const ret = wasm.transactionoutputamountbuilder_with_value(this.__wbg_ptr, amount.__wbg_ptr);
        return TransactionOutputAmountBuilder.__wrap(ret);
    }
    /**
     * @param {MultiAsset} multiasset
     * @param {bigint} coins_per_utxo_byte
     * @returns {TransactionOutputAmountBuilder}
     */
    with_asset_and_min_required_coin(multiasset, coins_per_utxo_byte) {
        _assertClass(multiasset, MultiAsset);
        const ret = wasm.transactionoutputamountbuilder_with_asset_and_min_required_coin(this.__wbg_ptr, multiasset.__wbg_ptr, coins_per_utxo_byte);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionOutputAmountBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {SingleOutputBuilderResult}
     */
    build() {
        const ret = wasm.transactionoutputamountbuilder_build(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return SingleOutputBuilderResult.__wrap(ret[0]);
    }
}

const TransactionOutputBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputbuilder_free(ptr >>> 0, 1));
/**
 * We introduce a builder-pattern format for creating transaction outputs
 * This is because:
 * 1. Some fields (i.e. data hash) are optional, and we can't easily expose Option<> in WASM
 * 2. Some fields like amounts have many ways it could be set (some depending on other field values being known)
 * 3. Easier to adapt as the output format gets more complicated in future Cardano releases
 */
export class TransactionOutputBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionOutputBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputbuilder_free(ptr, 0);
    }
    /**
     * @returns {TransactionOutputBuilder}
     */
    static new() {
        const ret = wasm.transactionoutputbuilder_new();
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
     * @param {Address} address
     * @returns {TransactionOutputBuilder}
     */
    with_address(address) {
        _assertClass(address, Address);
        const ret = wasm.transactionoutputbuilder_with_address(this.__wbg_ptr, address.__wbg_ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
     * A communication datum is one where the data hash is used in the tx output
     * Yet the full datum is included in the witness of the same transaction
     * @param {PlutusData} datum
     * @returns {TransactionOutputBuilder}
     */
    with_communication_data(datum) {
        _assertClass(datum, PlutusData);
        const ret = wasm.transactionoutputbuilder_with_communication_data(this.__wbg_ptr, datum.__wbg_ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
     * @param {DatumOption} datum
     * @returns {TransactionOutputBuilder}
     */
    with_data(datum) {
        _assertClass(datum, DatumOption);
        const ret = wasm.transactionoutputbuilder_with_data(this.__wbg_ptr, datum.__wbg_ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
     * @param {Script} script_ref
     * @returns {TransactionOutputBuilder}
     */
    with_reference_script(script_ref) {
        _assertClass(script_ref, Script);
        const ret = wasm.transactionoutputbuilder_with_reference_script(this.__wbg_ptr, script_ref.__wbg_ptr);
        return TransactionOutputBuilder.__wrap(ret);
    }
    /**
     * @returns {TransactionOutputAmountBuilder}
     */
    next() {
        const ret = wasm.transactionoutputbuilder_next(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionOutputAmountBuilder.__wrap(ret[0]);
    }
}

const TransactionOutputListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionoutputlist_free(ptr >>> 0, 1));

export class TransactionOutputList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionOutputList.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutputlist_free(ptr, 0);
    }
    /**
     * @returns {TransactionOutputList}
     */
    static new() {
        const ret = wasm.transactionoutputlist_new();
        return TransactionOutputList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactionoutputlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionOutput}
     */
    get(index) {
        const ret = wasm.transactionoutputlist_get(this.__wbg_ptr, index);
        return TransactionOutput.__wrap(ret);
    }
    /**
     * @param {TransactionOutput} elem
     */
    add(elem) {
        _assertClass(elem, TransactionOutput);
        wasm.transactionoutputlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const TransactionUnspentOutputFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionunspentoutput_free(ptr >>> 0, 1));

export class TransactionUnspentOutput {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionUnspentOutput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionUnspentOutputFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionUnspentOutputFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionunspentoutput_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes.
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactionunspentoutput_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionUnspentOutput}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionunspentoutput_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionUnspentOutput.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type does NOT support fine-tuned encoding options so this may or may not be
     *             * canonical CBOR and may or may not preserve round-trip encodings.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionunspentoutput_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TransactionUnspentOutput}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionunspentoutput_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionUnspentOutput.__wrap(ret[0]);
    }
    /**
     * @param {TransactionInput} input
     * @param {TransactionOutput} output
     * @returns {TransactionUnspentOutput}
     */
    static new(input, output) {
        _assertClass(input, TransactionInput);
        _assertClass(output, TransactionOutput);
        const ret = wasm.transactionunspentoutput_new(input.__wbg_ptr, output.__wbg_ptr);
        return TransactionUnspentOutput.__wrap(ret);
    }
    /**
     * @returns {TransactionInput}
     */
    input() {
        const ret = wasm.transactionunspentoutput_input(this.__wbg_ptr);
        return TransactionInput.__wrap(ret);
    }
    /**
     * @returns {TransactionOutput}
     */
    output() {
        const ret = wasm.transactionunspentoutput_output(this.__wbg_ptr);
        return TransactionOutput.__wrap(ret);
    }
}

const TransactionWitnessSetFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnessset_free(ptr >>> 0, 1));

export class TransactionWitnessSet {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionWitnessSet.prototype);
        obj.__wbg_ptr = ptr;
        TransactionWitnessSetFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionWitnessSetFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnessset_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.transactionwitnessset_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.transactionwitnessset_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TransactionWitnessSet}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionwitnessset_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionWitnessSet.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionwitnessset_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.transactionwitnessset_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TransactionWitnessSet}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionwitnessset_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionWitnessSet.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.transactionwitnessset_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.transactionwitnessset_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TransactionWitnessSet}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.transactionwitnessset_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionWitnessSet.__wrap(ret[0]);
    }
    /**
     * @param {VkeywitnessList} vkeywitnesses
     */
    set_vkeywitnesses(vkeywitnesses) {
        _assertClass(vkeywitnesses, VkeywitnessList);
        wasm.transactionwitnessset_set_vkeywitnesses(this.__wbg_ptr, vkeywitnesses.__wbg_ptr);
    }
    /**
     * @returns {VkeywitnessList | undefined}
     */
    vkeywitnesses() {
        const ret = wasm.transactionwitnessset_vkeywitnesses(this.__wbg_ptr);
        return ret === 0 ? undefined : VkeywitnessList.__wrap(ret);
    }
    /**
     * @param {NativeScriptList} native_scripts
     */
    set_native_scripts(native_scripts) {
        _assertClass(native_scripts, NativeScriptList);
        wasm.transactionwitnessset_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);
    }
    /**
     * @returns {NativeScriptList | undefined}
     */
    native_scripts() {
        const ret = wasm.transactionwitnessset_native_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : NativeScriptList.__wrap(ret);
    }
    /**
     * @param {BootstrapWitnessList} bootstrap_witnesses
     */
    set_bootstrap_witnesses(bootstrap_witnesses) {
        _assertClass(bootstrap_witnesses, BootstrapWitnessList);
        wasm.transactionwitnessset_set_bootstrap_witnesses(this.__wbg_ptr, bootstrap_witnesses.__wbg_ptr);
    }
    /**
     * @returns {BootstrapWitnessList | undefined}
     */
    bootstrap_witnesses() {
        const ret = wasm.transactionwitnessset_bootstrap_witnesses(this.__wbg_ptr);
        return ret === 0 ? undefined : BootstrapWitnessList.__wrap(ret);
    }
    /**
     * @param {PlutusV1ScriptList} plutus_v1_scripts
     */
    set_plutus_v1_scripts(plutus_v1_scripts) {
        _assertClass(plutus_v1_scripts, PlutusV1ScriptList);
        wasm.transactionwitnessset_set_plutus_v1_scripts(this.__wbg_ptr, plutus_v1_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV1ScriptList | undefined}
     */
    plutus_v1_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v1_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV1ScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusDataList} plutus_datums
     */
    set_plutus_datums(plutus_datums) {
        _assertClass(plutus_datums, PlutusDataList);
        wasm.transactionwitnessset_set_plutus_datums(this.__wbg_ptr, plutus_datums.__wbg_ptr);
    }
    /**
     * @returns {PlutusDataList | undefined}
     */
    plutus_datums() {
        const ret = wasm.transactionwitnessset_plutus_datums(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusDataList.__wrap(ret);
    }
    /**
     * @param {Redeemers} redeemers
     */
    set_redeemers(redeemers) {
        _assertClass(redeemers, Redeemers);
        wasm.transactionwitnessset_set_redeemers(this.__wbg_ptr, redeemers.__wbg_ptr);
    }
    /**
     * @returns {Redeemers | undefined}
     */
    redeemers() {
        const ret = wasm.transactionwitnessset_redeemers(this.__wbg_ptr);
        return ret === 0 ? undefined : Redeemers.__wrap(ret);
    }
    /**
     * @param {PlutusV2ScriptList} plutus_v2_scripts
     */
    set_plutus_v2_scripts(plutus_v2_scripts) {
        _assertClass(plutus_v2_scripts, PlutusV2ScriptList);
        wasm.transactionwitnessset_set_plutus_v2_scripts(this.__wbg_ptr, plutus_v2_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV2ScriptList | undefined}
     */
    plutus_v2_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v2_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV2ScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusV3ScriptList} plutus_v3_scripts
     */
    set_plutus_v3_scripts(plutus_v3_scripts) {
        _assertClass(plutus_v3_scripts, PlutusV3ScriptList);
        wasm.transactionwitnessset_set_plutus_v3_scripts(this.__wbg_ptr, plutus_v3_scripts.__wbg_ptr);
    }
    /**
     * @returns {PlutusV3ScriptList | undefined}
     */
    plutus_v3_scripts() {
        const ret = wasm.transactionwitnessset_plutus_v3_scripts(this.__wbg_ptr);
        return ret === 0 ? undefined : PlutusV3ScriptList.__wrap(ret);
    }
    /**
     * @returns {TransactionWitnessSet}
     */
    static new() {
        const ret = wasm.transactionwitnessset_new();
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
     * @param {TransactionWitnessSet} other
     */
    add_all_witnesses(other) {
        _assertClass(other, TransactionWitnessSet);
        wasm.transactionwitnessset_add_all_witnesses(this.__wbg_ptr, other.__wbg_ptr);
    }
    /**
     * @returns {LanguageList}
     */
    languages() {
        const ret = wasm.transactionwitnessset_languages(this.__wbg_ptr);
        return LanguageList.__wrap(ret);
    }
}

const TransactionWitnessSetBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnesssetbuilder_free(ptr >>> 0, 1));
/**
 * Builder de-duplicates witnesses as they are added
 */
export class TransactionWitnessSetBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionWitnessSetBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TransactionWitnessSetBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionWitnessSetBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnesssetbuilder_free(ptr, 0);
    }
    /**
     * @param {Vkeywitness} vkey_witness
     */
    add_vkey(vkey_witness) {
        _assertClass(vkey_witness, Vkeywitness);
        wasm.transactionwitnesssetbuilder_add_vkey(this.__wbg_ptr, vkey_witness.__wbg_ptr);
    }
    /**
     * @param {BootstrapWitness} bootstrap
     */
    add_bootstrap(bootstrap) {
        _assertClass(bootstrap, BootstrapWitness);
        wasm.transactionwitnesssetbuilder_add_bootstrap(this.__wbg_ptr, bootstrap.__wbg_ptr);
    }
    /**
     * @param {Script} script
     */
    add_script(script) {
        _assertClass(script, Script);
        wasm.transactionwitnesssetbuilder_add_script(this.__wbg_ptr, script.__wbg_ptr);
    }
    /**
     * @returns {NativeScriptList}
     */
    get_native_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_native_script(this.__wbg_ptr);
        return NativeScriptList.__wrap(ret);
    }
    /**
     * @returns {PlutusV1ScriptList}
     */
    get_plutus_v1_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_v1_script(this.__wbg_ptr);
        return PlutusV1ScriptList.__wrap(ret);
    }
    /**
     * @returns {PlutusV2ScriptList}
     */
    get_plutus_v2_script() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_v2_script(this.__wbg_ptr);
        return PlutusV2ScriptList.__wrap(ret);
    }
    /**
     * @param {PlutusData} plutus_datum
     */
    add_plutus_datum(plutus_datum) {
        _assertClass(plutus_datum, PlutusData);
        var ptr0 = plutus_datum.__destroy_into_raw();
        wasm.transactionwitnesssetbuilder_add_plutus_datum(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {PlutusDataList}
     */
    get_plutus_datum() {
        const ret = wasm.transactionwitnesssetbuilder_get_plutus_datum(this.__wbg_ptr);
        return PlutusDataList.__wrap(ret);
    }
    /**
     * @param {LegacyRedeemer} redeemer
     */
    add_redeemer(redeemer) {
        _assertClass(redeemer, LegacyRedeemer);
        wasm.transactionwitnesssetbuilder_add_redeemer(this.__wbg_ptr, redeemer.__wbg_ptr);
    }
    /**
     * @returns {LegacyRedeemerList}
     */
    get_redeemer() {
        const ret = wasm.transactionwitnesssetbuilder_get_redeemer(this.__wbg_ptr);
        return LegacyRedeemerList.__wrap(ret);
    }
    /**
     * @param {RequiredWitnessSet} required_wits
     */
    add_required_wits(required_wits) {
        _assertClass(required_wits, RequiredWitnessSet);
        wasm.transactionwitnesssetbuilder_add_required_wits(this.__wbg_ptr, required_wits.__wbg_ptr);
    }
    /**
     * @returns {TransactionWitnessSetBuilder}
     */
    static new() {
        const ret = wasm.transactionwitnesssetbuilder_new();
        return TransactionWitnessSetBuilder.__wrap(ret);
    }
    /**
     * @param {TransactionWitnessSet} wit_set
     */
    add_existing(wit_set) {
        _assertClass(wit_set, TransactionWitnessSet);
        wasm.transactionwitnesssetbuilder_add_existing(this.__wbg_ptr, wit_set.__wbg_ptr);
    }
    /**
     * @returns {TransactionWitnessSet}
     */
    build() {
        const ret = wasm.transactionwitnesssetbuilder_build(this.__wbg_ptr);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
     * @returns {RequiredWitnessSet}
     */
    remaining_wits() {
        const ret = wasm.transactionwitnesssetbuilder_remaining_wits(this.__wbg_ptr);
        return RequiredWitnessSet.__wrap(ret);
    }
    /**
     * @returns {TransactionWitnessSet}
     */
    try_build() {
        const ret = wasm.transactionwitnesssetbuilder_try_build(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TransactionWitnessSet.__wrap(ret[0]);
    }
    /**
     * @param {RequiredWitnessSet} required_wits
     */
    merge_fake_witness(required_wits) {
        _assertClass(required_wits, RequiredWitnessSet);
        wasm.transactionwitnesssetbuilder_merge_fake_witness(this.__wbg_ptr, required_wits.__wbg_ptr);
    }
}

const TransactionWitnessSetListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_transactionwitnesssetlist_free(ptr >>> 0, 1));

export class TransactionWitnessSetList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TransactionWitnessSetList.prototype);
        obj.__wbg_ptr = ptr;
        TransactionWitnessSetListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionWitnessSetListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionwitnesssetlist_free(ptr, 0);
    }
    /**
     * @returns {TransactionWitnessSetList}
     */
    static new() {
        const ret = wasm.transactionwitnesssetlist_new();
        return TransactionWitnessSetList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.transactionwitnesssetlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {TransactionWitnessSet}
     */
    get(index) {
        const ret = wasm.transactionwitnesssetlist_get(this.__wbg_ptr, index);
        return TransactionWitnessSet.__wrap(ret);
    }
    /**
     * @param {TransactionWitnessSet} elem
     */
    add(elem) {
        _assertClass(elem, TransactionWitnessSet);
        wasm.transactionwitnesssetlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const TreasuryWithdrawalsActionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_treasurywithdrawalsaction_free(ptr >>> 0, 1));

export class TreasuryWithdrawalsAction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TreasuryWithdrawalsAction.prototype);
        obj.__wbg_ptr = ptr;
        TreasuryWithdrawalsActionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TreasuryWithdrawalsActionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_treasurywithdrawalsaction_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.treasurywithdrawalsaction_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.treasurywithdrawalsaction_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {TreasuryWithdrawalsAction}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.treasurywithdrawalsaction_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TreasuryWithdrawalsAction.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.treasurywithdrawalsaction_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.treasurywithdrawalsaction_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {TreasuryWithdrawalsAction}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.treasurywithdrawalsaction_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TreasuryWithdrawalsAction.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.treasurywithdrawalsaction_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.treasurywithdrawalsaction_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {TreasuryWithdrawalsAction}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.treasurywithdrawalsaction_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return TreasuryWithdrawalsAction.__wrap(ret[0]);
    }
    /**
     * @returns {MapRewardAccountToCoin}
     */
    withdrawal() {
        const ret = wasm.treasurywithdrawalsaction_withdrawal(this.__wbg_ptr);
        return MapRewardAccountToCoin.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    policy_hash() {
        const ret = wasm.treasurywithdrawalsaction_policy_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     * @param {MapRewardAccountToCoin} withdrawal
     * @param {ScriptHash | null} [policy_hash]
     * @returns {TreasuryWithdrawalsAction}
     */
    static new(withdrawal, policy_hash) {
        _assertClass(withdrawal, MapRewardAccountToCoin);
        let ptr0 = 0;
        if (!isLikeNone(policy_hash)) {
            _assertClass(policy_hash, ScriptHash);
            ptr0 = policy_hash.__destroy_into_raw();
        }
        const ret = wasm.treasurywithdrawalsaction_new(withdrawal.__wbg_ptr, ptr0);
        return TreasuryWithdrawalsAction.__wrap(ret);
    }
}

const TxRedeemerBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_txredeemerbuilder_free(ptr >>> 0, 1));

export class TxRedeemerBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TxRedeemerBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TxRedeemerBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TxRedeemerBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_txredeemerbuilder_free(ptr, 0);
    }
    /**
     * Builds the transaction and moves to the next step where any real witness can be added
     * NOTE: is_valid set to true
     * Will NOT require you to have set required signers & witnesses
     * @returns {Redeemers}
     */
    build() {
        const ret = wasm.txredeemerbuilder_build(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Redeemers.__wrap(ret[0]);
    }
    /**
     * used to override the exunit values initially provided when adding inputs
     * @param {RedeemerWitnessKey} redeemer
     * @param {ExUnits} ex_units
     */
    set_exunits(redeemer, ex_units) {
        _assertClass(redeemer, RedeemerWitnessKey);
        _assertClass(ex_units, ExUnits);
        wasm.txredeemerbuilder_set_exunits(this.__wbg_ptr, redeemer.__wbg_ptr, ex_units.__wbg_ptr);
    }
    /**
     * Transaction body with a dummy values for redeemers & script_data_hash
     * Used for calculating exunits or required signers
     * @returns {TransactionBody}
     */
    draft_body() {
        const ret = wasm.txredeemerbuilder_draft_body(this.__wbg_ptr);
        return TransactionBody.__wrap(ret);
    }
    /**
     * @returns {AuxiliaryData | undefined}
     */
    auxiliary_data() {
        const ret = wasm.txredeemerbuilder_auxiliary_data(this.__wbg_ptr);
        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
    }
    /**
     * Transaction body with a dummy values for redeemers & script_data_hash and padded with dummy witnesses
     * Used for calculating exunits
     * note: is_valid set to true
     * @returns {Transaction}
     */
    draft_tx() {
        const ret = wasm.txredeemerbuilder_draft_tx(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Transaction.__wrap(ret[0]);
    }
}

const UnitIntervalFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unitinterval_free(ptr >>> 0, 1));

export class UnitInterval {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnitInterval.prototype);
        obj.__wbg_ptr = ptr;
        UnitIntervalFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnitIntervalFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unitinterval_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.unitinterval_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.unitinterval_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {UnitInterval}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unitinterval_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnitInterval.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unitinterval_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unitinterval_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {UnitInterval}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unitinterval_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnitInterval.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.unitinterval_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.unitinterval_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {UnitInterval}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unitinterval_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnitInterval.__wrap(ret[0]);
    }
    /**
     * @returns {bigint}
     */
    start() {
        const ret = wasm.unitinterval_start(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {bigint}
     */
    end() {
        const ret = wasm.unitinterval_end(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} start
     * @param {bigint} end
     * @returns {UnitInterval}
     */
    static new(start, end) {
        const ret = wasm.unitinterval_new(start, end);
        return UnitInterval.__wrap(ret);
    }
}

const UnregCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unregcert_free(ptr >>> 0, 1));

export class UnregCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnregCert.prototype);
        obj.__wbg_ptr = ptr;
        UnregCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnregCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unregcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.unregcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.unregcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {UnregCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unregcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unregcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {UnregCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.unregcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.unregcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {UnregCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.unregcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.unregcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {bigint} deposit
     * @returns {UnregCert}
     */
    static new(stake_credential, deposit) {
        _assertClass(stake_credential, Credential);
        const ret = wasm.unregcert_new(stake_credential.__wbg_ptr, deposit);
        return UnregCert.__wrap(ret);
    }
}

const UnregDrepCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unregdrepcert_free(ptr >>> 0, 1));

export class UnregDrepCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnregDrepCert.prototype);
        obj.__wbg_ptr = ptr;
        UnregDrepCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnregDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unregdrepcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.unregdrepcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.unregdrepcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {UnregDrepCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregdrepcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregDrepCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unregdrepcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.unregdrepcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {UnregDrepCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregdrepcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.unregdrepcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.unregdrepcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {UnregDrepCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.unregdrepcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UnregDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    drep_credential() {
        const ret = wasm.unregdrepcert_drep_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.unregdrepcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {bigint} deposit
     * @returns {UnregDrepCert}
     */
    static new(drep_credential, deposit) {
        _assertClass(drep_credential, Credential);
        const ret = wasm.unregdrepcert_new(drep_credential.__wbg_ptr, deposit);
        return UnregDrepCert.__wrap(ret);
    }
}

const UntaggedRedeemerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_untaggedredeemer_free(ptr >>> 0, 1));
/**
 * Redeemer without the tag of index
 * This allows builder code to return partial redeemers
 * and then later have them placed in the right context
 */
export class UntaggedRedeemer {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UntaggedRedeemer.prototype);
        obj.__wbg_ptr = ptr;
        UntaggedRedeemerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UntaggedRedeemerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_untaggedredeemer_free(ptr, 0);
    }
    /**
     * @param {PlutusData} data
     * @param {ExUnits} ex_units
     * @returns {UntaggedRedeemer}
     */
    static new(data, ex_units) {
        _assertClass(data, PlutusData);
        _assertClass(ex_units, ExUnits);
        const ret = wasm.untaggedredeemer_new(data.__wbg_ptr, ex_units.__wbg_ptr);
        return UntaggedRedeemer.__wrap(ret);
    }
}

const UpdateCommitteeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_updatecommittee_free(ptr >>> 0, 1));

export class UpdateCommittee {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UpdateCommittee.prototype);
        obj.__wbg_ptr = ptr;
        UpdateCommitteeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UpdateCommitteeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_updatecommittee_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.updatecommittee_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.updatecommittee_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {UpdateCommittee}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatecommittee_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateCommittee.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.updatecommittee_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.updatecommittee_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {UpdateCommittee}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatecommittee_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateCommittee.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.updatecommittee_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.updatecommittee_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {UpdateCommittee}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatecommittee_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateCommittee.__wrap(ret[0]);
    }
    /**
     * @returns {GovActionId | undefined}
     */
    action_id() {
        const ret = wasm.updatecommittee_action_id(this.__wbg_ptr);
        return ret === 0 ? undefined : GovActionId.__wrap(ret);
    }
    /**
     * @returns {CommitteeColdCredentialList}
     */
    cold_credentials() {
        const ret = wasm.updatecommittee_cold_credentials(this.__wbg_ptr);
        return CommitteeColdCredentialList.__wrap(ret);
    }
    /**
     * @returns {MapCommitteeColdCredentialToEpoch}
     */
    credentials() {
        const ret = wasm.updatecommittee_credentials(this.__wbg_ptr);
        return MapCommitteeColdCredentialToEpoch.__wrap(ret);
    }
    /**
     * @returns {UnitInterval}
     */
    unit_interval() {
        const ret = wasm.updatecommittee_unit_interval(this.__wbg_ptr);
        return UnitInterval.__wrap(ret);
    }
    /**
     * @param {GovActionId | null | undefined} action_id
     * @param {CommitteeColdCredentialList} cold_credentials
     * @param {MapCommitteeColdCredentialToEpoch} credentials
     * @param {UnitInterval} unit_interval
     * @returns {UpdateCommittee}
     */
    static new(action_id, cold_credentials, credentials, unit_interval) {
        let ptr0 = 0;
        if (!isLikeNone(action_id)) {
            _assertClass(action_id, GovActionId);
            ptr0 = action_id.__destroy_into_raw();
        }
        _assertClass(cold_credentials, CommitteeColdCredentialList);
        _assertClass(credentials, MapCommitteeColdCredentialToEpoch);
        _assertClass(unit_interval, UnitInterval);
        const ret = wasm.updatecommittee_new(ptr0, cold_credentials.__wbg_ptr, credentials.__wbg_ptr, unit_interval.__wbg_ptr);
        return UpdateCommittee.__wrap(ret);
    }
}

const UpdateDrepCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_updatedrepcert_free(ptr >>> 0, 1));

export class UpdateDrepCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UpdateDrepCert.prototype);
        obj.__wbg_ptr = ptr;
        UpdateDrepCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UpdateDrepCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_updatedrepcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.updatedrepcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.updatedrepcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {UpdateDrepCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatedrepcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateDrepCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.updatedrepcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.updatedrepcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {UpdateDrepCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatedrepcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.updatedrepcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.updatedrepcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {UpdateDrepCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.updatedrepcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return UpdateDrepCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    drep_credential() {
        const ret = wasm.updatedrepcert_drep_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {Anchor | undefined}
     */
    anchor() {
        const ret = wasm.updatedrepcert_anchor(this.__wbg_ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
     * @param {Credential} drep_credential
     * @param {Anchor | null} [anchor]
     * @returns {UpdateDrepCert}
     */
    static new(drep_credential, anchor) {
        _assertClass(drep_credential, Credential);
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.updatedrepcert_new(drep_credential.__wbg_ptr, ptr0);
        return UpdateDrepCert.__wrap(ret);
    }
}

const UrlFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_url_free(ptr >>> 0, 1));

export class Url {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Url.prototype);
        obj.__wbg_ptr = ptr;
        UrlFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UrlFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_url_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.url_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.url_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Url}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.url_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Url.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.url_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.url_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Url}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.url_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Url.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.url_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.url_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Url}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.url_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Url.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    get() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.url_get(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const VRFCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vrfcert_free(ptr >>> 0, 1));

export class VRFCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VRFCert.prototype);
        obj.__wbg_ptr = ptr;
        VRFCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VRFCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.vrfcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.vrfcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {VRFCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vrfcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vrfcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {VRFCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.vrfcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.vrfcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {VRFCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFCert.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    output() {
        const ret = wasm.vrfcert_output(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @returns {Uint8Array}
     */
    proof() {
        const ret = wasm.vrfcert_proof(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} output
     * @param {Uint8Array} proof
     * @returns {VRFCert}
     */
    static new(output, proof) {
        const ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.vrfcert_new(ptr0, len0, ptr1, len1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFCert.__wrap(ret[0]);
    }
}

const VRFKeyHashFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vrfkeyhash_free(ptr >>> 0, 1));

export class VRFKeyHash {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VRFKeyHash.prototype);
        obj.__wbg_ptr = ptr;
        VRFKeyHashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VRFKeyHashFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfkeyhash_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.vrfkeyhash_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {VRFKeyHash}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfkeyhash_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFKeyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.vrfkeyhash_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {VRFKeyHash}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfkeyhash_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFKeyHash.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vrfkeyhash_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {VRFKeyHash}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfkeyhash_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFKeyHash.__wrap(ret[0]);
    }
}

const VRFVkeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vrfvkey_free(ptr >>> 0, 1));

export class VRFVkey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VRFVkey.prototype);
        obj.__wbg_ptr = ptr;
        VRFVkeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VRFVkeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vrfvkey_free(ptr, 0);
    }
    /**
     * @param {string} prefix
     * @returns {string}
     */
    to_bech32(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
            const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm.vrfvkey_to_bech32(this.__wbg_ptr, ptr0, len0);
            var ptr2 = ret[0];
            var len2 = ret[1];
            if (ret[3]) {
                ptr2 = 0; len2 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
        }
    }
    /**
     * @param {string} bech32_str
     * @returns {VRFVkey}
     */
    static from_bech32(bech32_str) {
        const ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfvkey_from_bech32(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFVkey.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure
     *
     * @returns {Uint8Array}
     */
    to_raw_bytes() {
        const ret = wasm.vrfvkey_to_raw_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Parse from the direct raw bytes, without any CBOR structure
     *
     * @param {Uint8Array} bytes
     * @returns {VRFVkey}
     */
    static from_raw_bytes(bytes) {
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfvkey_from_raw_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFVkey.__wrap(ret[0]);
    }
    /**
     *
     *             * Direct raw bytes without any CBOR structure, as a hex-encoded string
     *
     * @returns {string}
     */
    to_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vrfvkey_to_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Parse from a hex string of the direct raw bytes, without any CBOR structure
     *
     * @param {string} input
     * @returns {VRFVkey}
     */
    static from_hex(input) {
        const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vrfvkey_from_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VRFVkey.__wrap(ret[0]);
    }
}

const ValueFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_value_free(ptr >>> 0, 1));

export class Value {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Value.prototype);
        obj.__wbg_ptr = ptr;
        ValueFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ValueFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_value_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.value_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.value_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Value}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.value_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.value_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.value_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Value}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.value_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.value_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.value_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Value}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.value_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * @param {bigint} coin
     * @returns {Value}
     */
    static from_coin(coin) {
        const ret = wasm.value_from_coin(coin);
        return Value.__wrap(ret);
    }
    /**
     * @param {bigint} coin
     * @param {MultiAsset} multiasset
     * @returns {Value}
     */
    static new(coin, multiasset) {
        _assertClass(multiasset, MultiAsset);
        const ret = wasm.value_new(coin, multiasset.__wbg_ptr);
        return Value.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    coin() {
        const ret = wasm.value_coin(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @returns {MultiAsset}
     */
    multi_asset() {
        const ret = wasm.value_multi_asset(this.__wbg_ptr);
        return MultiAsset.__wrap(ret);
    }
    /**
     * @returns {Value}
     */
    static zero() {
        const ret = wasm.value_zero();
        return Value.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    is_zero() {
        const ret = wasm.value_is_zero(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    has_multiassets() {
        const ret = wasm.value_has_multiassets(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {Value} rhs
     * @returns {Value}
     */
    checked_add(rhs) {
        _assertClass(rhs, Value);
        const ret = wasm.value_checked_add(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * Subtract ADA and/or assets
     * Removes an asset from the list if the result is 0 or less
     * Does not modify this object, instead the result is returned
     * None is returned if there would be integer underflow
     * @param {Value} rhs
     * @returns {Value}
     */
    checked_sub(rhs) {
        _assertClass(rhs, Value);
        const ret = wasm.value_checked_sub(this.__wbg_ptr, rhs.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Value.__wrap(ret[0]);
    }
    /**
     * @param {Value} rhs
     * @returns {Value}
     */
    clamped_sub(rhs) {
        _assertClass(rhs, Value);
        const ret = wasm.value_clamped_sub(this.__wbg_ptr, rhs.__wbg_ptr);
        return Value.__wrap(ret);
    }
}

const VkeywitnessFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vkeywitness_free(ptr >>> 0, 1));

export class Vkeywitness {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Vkeywitness.prototype);
        obj.__wbg_ptr = ptr;
        VkeywitnessFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VkeywitnessFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vkeywitness_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.vkeywitness_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.vkeywitness_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Vkeywitness}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vkeywitness_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Vkeywitness.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vkeywitness_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.vkeywitness_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Vkeywitness}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vkeywitness_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Vkeywitness.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.vkeywitness_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.vkeywitness_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Vkeywitness}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.vkeywitness_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Vkeywitness.__wrap(ret[0]);
    }
    /**
     * @returns {PublicKey}
     */
    vkey() {
        const ret = wasm.vkeywitness_vkey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
     * @returns {Ed25519Signature}
     */
    ed25519_signature() {
        const ret = wasm.vkeywitness_ed25519_signature(this.__wbg_ptr);
        return Ed25519Signature.__wrap(ret);
    }
    /**
     * @param {PublicKey} vkey
     * @param {Ed25519Signature} ed25519_signature
     * @returns {Vkeywitness}
     */
    static new(vkey, ed25519_signature) {
        _assertClass(vkey, PublicKey);
        _assertClass(ed25519_signature, Ed25519Signature);
        const ret = wasm.vkeywitness_new(vkey.__wbg_ptr, ed25519_signature.__wbg_ptr);
        return Vkeywitness.__wrap(ret);
    }
}

const VkeywitnessListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_vkeywitnesslist_free(ptr >>> 0, 1));

export class VkeywitnessList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VkeywitnessList.prototype);
        obj.__wbg_ptr = ptr;
        VkeywitnessListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VkeywitnessListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vkeywitnesslist_free(ptr, 0);
    }
    /**
     * @returns {VkeywitnessList}
     */
    static new() {
        const ret = wasm.vkeywitnesslist_new();
        return VkeywitnessList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.vkeywitnesslist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Vkeywitness}
     */
    get(index) {
        const ret = wasm.vkeywitnesslist_get(this.__wbg_ptr, index);
        return Vkeywitness.__wrap(ret);
    }
    /**
     * @param {Vkeywitness} elem
     */
    add(elem) {
        _assertClass(elem, Vkeywitness);
        wasm.vkeywitnesslist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const VoteBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votebuilder_free(ptr >>> 0, 1));

export class VoteBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VoteBuilder.prototype);
        obj.__wbg_ptr = ptr;
        VoteBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoteBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votebuilder_free(ptr, 0);
    }
    /**
     * @returns {VoteBuilder}
     */
    static new() {
        const ret = wasm.votebuilder_new();
        return VoteBuilder.__wrap(ret);
    }
    /**
     * @param {Voter} voter
     * @param {GovActionId} gov_action_id
     * @param {VotingProcedure} procedure
     * @returns {VoteBuilder}
     */
    with_vote(voter, gov_action_id, procedure) {
        _assertClass(voter, Voter);
        _assertClass(gov_action_id, GovActionId);
        _assertClass(procedure, VotingProcedure);
        const ret = wasm.votebuilder_with_vote(this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, procedure.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteBuilder.__wrap(ret[0]);
    }
    /**
     * @param {Voter} voter
     * @param {GovActionId} gov_action_id
     * @param {VotingProcedure} procedure
     * @param {NativeScript} native_script
     * @param {NativeScriptWitnessInfo} witness_info
     * @returns {VoteBuilder}
     */
    with_native_script_vote(voter, gov_action_id, procedure, native_script, witness_info) {
        _assertClass(voter, Voter);
        _assertClass(gov_action_id, GovActionId);
        _assertClass(procedure, VotingProcedure);
        _assertClass(native_script, NativeScript);
        var ptr0 = native_script.__destroy_into_raw();
        _assertClass(witness_info, NativeScriptWitnessInfo);
        var ptr1 = witness_info.__destroy_into_raw();
        const ret = wasm.votebuilder_with_native_script_vote(this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, procedure.__wbg_ptr, ptr0, ptr1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteBuilder.__wrap(ret[0]);
    }
    /**
     * @param {Voter} voter
     * @param {GovActionId} gov_action_id
     * @param {VotingProcedure} procedure
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @param {PlutusData} datum
     * @returns {VoteBuilder}
     */
    with_plutus_vote(voter, gov_action_id, procedure, partial_witness, required_signers, datum) {
        _assertClass(voter, Voter);
        _assertClass(gov_action_id, GovActionId);
        _assertClass(procedure, VotingProcedure);
        _assertClass(partial_witness, PartialPlutusWitness);
        _assertClass(required_signers, Ed25519KeyHashList);
        _assertClass(datum, PlutusData);
        const ret = wasm.votebuilder_with_plutus_vote(this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, procedure.__wbg_ptr, partial_witness.__wbg_ptr, required_signers.__wbg_ptr, datum.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteBuilder.__wrap(ret[0]);
    }
    /**
     * @param {Voter} voter
     * @param {GovActionId} gov_action_id
     * @param {VotingProcedure} procedure
     * @param {PartialPlutusWitness} partial_witness
     * @param {Ed25519KeyHashList} required_signers
     * @returns {VoteBuilder}
     */
    with_plutus_vote_inline_datum(voter, gov_action_id, procedure, partial_witness, required_signers) {
        _assertClass(voter, Voter);
        _assertClass(gov_action_id, GovActionId);
        _assertClass(procedure, VotingProcedure);
        _assertClass(partial_witness, PartialPlutusWitness);
        var ptr0 = partial_witness.__destroy_into_raw();
        _assertClass(required_signers, Ed25519KeyHashList);
        var ptr1 = required_signers.__destroy_into_raw();
        const ret = wasm.votebuilder_with_plutus_vote_inline_datum(this.__wbg_ptr, voter.__wbg_ptr, gov_action_id.__wbg_ptr, procedure.__wbg_ptr, ptr0, ptr1);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {VoteBuilderResult}
     */
    build() {
        const ret = wasm.votebuilder_build(this.__wbg_ptr);
        return VoteBuilderResult.__wrap(ret);
    }
}

const VoteBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votebuilderresult_free(ptr >>> 0, 1));

export class VoteBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VoteBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        VoteBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoteBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votebuilderresult_free(ptr, 0);
    }
}

const VoteDelegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votedelegcert_free(ptr >>> 0, 1));

export class VoteDelegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VoteDelegCert.prototype);
        obj.__wbg_ptr = ptr;
        VoteDelegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoteDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votedelegcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.votedelegcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.votedelegcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {VoteDelegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votedelegcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteDelegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votedelegcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votedelegcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {VoteDelegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votedelegcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.votedelegcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.votedelegcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {VoteDelegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votedelegcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.votedelegcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    d_rep() {
        const ret = wasm.votedelegcert_d_rep(this.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {DRep} d_rep
     * @returns {VoteDelegCert}
     */
    static new(stake_credential, d_rep) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.votedelegcert_new(stake_credential.__wbg_ptr, d_rep.__wbg_ptr);
        return VoteDelegCert.__wrap(ret);
    }
}

const VoteRegDelegCertFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_voteregdelegcert_free(ptr >>> 0, 1));

export class VoteRegDelegCert {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VoteRegDelegCert.prototype);
        obj.__wbg_ptr = ptr;
        VoteRegDelegCertFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoteRegDelegCertFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voteregdelegcert_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.voteregdelegcert_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.voteregdelegcert_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {VoteRegDelegCert}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voteregdelegcert_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.voteregdelegcert_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.voteregdelegcert_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {VoteRegDelegCert}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voteregdelegcert_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.voteregdelegcert_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.voteregdelegcert_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {VoteRegDelegCert}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voteregdelegcert_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VoteRegDelegCert.__wrap(ret[0]);
    }
    /**
     * @returns {Credential}
     */
    stake_credential() {
        const ret = wasm.voteregdelegcert_stake_credential(this.__wbg_ptr);
        return Credential.__wrap(ret);
    }
    /**
     * @returns {DRep}
     */
    d_rep() {
        const ret = wasm.voteregdelegcert_d_rep(this.__wbg_ptr);
        return DRep.__wrap(ret);
    }
    /**
     * @returns {bigint}
     */
    deposit() {
        const ret = wasm.voteregdelegcert_deposit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {Credential} stake_credential
     * @param {DRep} d_rep
     * @param {bigint} deposit
     * @returns {VoteRegDelegCert}
     */
    static new(stake_credential, d_rep, deposit) {
        _assertClass(stake_credential, Credential);
        _assertClass(d_rep, DRep);
        const ret = wasm.voteregdelegcert_new(stake_credential.__wbg_ptr, d_rep.__wbg_ptr, deposit);
        return VoteRegDelegCert.__wrap(ret);
    }
}

const VoterFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_voter_free(ptr >>> 0, 1));

export class Voter {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Voter.prototype);
        obj.__wbg_ptr = ptr;
        VoterFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voter_free(ptr, 0);
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    key_hash() {
        const ret = wasm.voter_key_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    script_hash() {
        const ret = wasm.voter_script_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.voter_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.voter_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {Voter}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voter_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Voter.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.voter_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.voter_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {Voter}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voter_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Voter.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.voter_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.voter_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {Voter}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.voter_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return Voter.__wrap(ret[0]);
    }
    /**
     * @param {Ed25519KeyHash} ed25519_key_hash
     * @returns {Voter}
     */
    static new_constitutional_committee_hot_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_constitutional_committee_hot_key_hash(ed25519_key_hash.__wbg_ptr);
        return Voter.__wrap(ret);
    }
    /**
     * @param {ScriptHash} script_hash
     * @returns {Voter}
     */
    static new_constitutional_committee_hot_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.voter_new_constitutional_committee_hot_script_hash(script_hash.__wbg_ptr);
        return Voter.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} ed25519_key_hash
     * @returns {Voter}
     */
    static new_d_rep_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_d_rep_key_hash(ed25519_key_hash.__wbg_ptr);
        return Voter.__wrap(ret);
    }
    /**
     * @param {ScriptHash} script_hash
     * @returns {Voter}
     */
    static new_d_rep_script_hash(script_hash) {
        _assertClass(script_hash, ScriptHash);
        const ret = wasm.voter_new_d_rep_script_hash(script_hash.__wbg_ptr);
        return Voter.__wrap(ret);
    }
    /**
     * @param {Ed25519KeyHash} ed25519_key_hash
     * @returns {Voter}
     */
    static new_staking_pool_key_hash(ed25519_key_hash) {
        _assertClass(ed25519_key_hash, Ed25519KeyHash);
        const ret = wasm.voter_new_staking_pool_key_hash(ed25519_key_hash.__wbg_ptr);
        return Voter.__wrap(ret);
    }
    /**
     * @returns {VoterKind}
     */
    kind() {
        const ret = wasm.voter_kind(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    as_constitutional_committee_hot_key_hash() {
        const ret = wasm.voter_as_constitutional_committee_hot_key_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    as_constitutional_committee_hot_script_hash() {
        const ret = wasm.voter_as_constitutional_committee_hot_script_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    as_d_rep_key_hash() {
        const ret = wasm.voter_as_d_rep_key_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
    /**
     * @returns {ScriptHash | undefined}
     */
    as_d_rep_script_hash() {
        const ret = wasm.voter_as_d_rep_script_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : ScriptHash.__wrap(ret);
    }
    /**
     * @returns {Ed25519KeyHash | undefined}
     */
    as_staking_pool_key_hash() {
        const ret = wasm.voter_as_staking_pool_key_hash(this.__wbg_ptr);
        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
    }
}

const VoterListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_voterlist_free(ptr >>> 0, 1));

export class VoterList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VoterList.prototype);
        obj.__wbg_ptr = ptr;
        VoterListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VoterListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_voterlist_free(ptr, 0);
    }
    /**
     * @returns {VoterList}
     */
    static new() {
        const ret = wasm.voterlist_new();
        return VoterList.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.voterlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {Voter}
     */
    get(index) {
        const ret = wasm.voterlist_get(this.__wbg_ptr, index);
        return Voter.__wrap(ret);
    }
    /**
     * @param {Voter} elem
     */
    add(elem) {
        _assertClass(elem, Voter);
        wasm.voterlist_add(this.__wbg_ptr, elem.__wbg_ptr);
    }
}

const VotingProcedureFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votingprocedure_free(ptr >>> 0, 1));

export class VotingProcedure {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VotingProcedure.prototype);
        obj.__wbg_ptr = ptr;
        VotingProcedureFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VotingProcedureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votingprocedure_free(ptr, 0);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {Uint8Array}
     */
    to_cbor_bytes() {
        const ret = wasm.votingprocedure_to_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings
     *
     * @returns {Uint8Array}
     */
    to_canonical_cbor_bytes() {
        const ret = wasm.votingprocedure_to_canonical_cbor_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     *
     *             * Create this type from CBOR bytes
     *
     * @param {Uint8Array} cbor_bytes
     * @returns {VotingProcedure}
     */
    static from_cbor_bytes(cbor_bytes) {
        const ptr0 = passArray8ToWasm0(cbor_bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votingprocedure_from_cbor_bytes(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VotingProcedure.__wrap(ret[0]);
    }
    /**
     *
     *             * Serialize this type to CBOR bytes encoded as a hex string (useful for working with CIP30).
     *             * This type type supports encoding preservation so this will preserve round-trip CBOR formats.
     *             * If created from scratch the CBOR will be canonical.
     *
     * @returns {string}
     */
    to_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votingprocedure_to_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Serialize this type to CBOR bytes using canonical CBOR encodings as hex bytes
     *
     * @returns {string}
     */
    to_canonical_cbor_hex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.votingprocedure_to_canonical_cbor_hex(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     *
     *             * Create this type from the CBOR bytes encoded as a hex string.
     *             * This is useful for interfacing with CIP30
     *
     * @param {string} cbor_bytes
     * @returns {VotingProcedure}
     */
    static from_cbor_hex(cbor_bytes) {
        const ptr0 = passStringToWasm0(cbor_bytes, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votingprocedure_from_cbor_hex(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VotingProcedure.__wrap(ret[0]);
    }
    /**
     * @returns {string}
     */
    to_json() {
        let deferred2_0;
        let deferred2_1;
        try {
            const ret = wasm.votingprocedure_to_json(this.__wbg_ptr);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
                ptr1 = 0; len1 = 0;
                throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
     * @returns {any}
     */
    to_js_value() {
        const ret = wasm.votingprocedure_to_js_value(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return takeFromExternrefTable0(ret[0]);
    }
    /**
     * @param {string} json
     * @returns {VotingProcedure}
     */
    static from_json(json) {
        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.votingprocedure_from_json(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
        }
        return VotingProcedure.__wrap(ret[0]);
    }
    /**
     * @returns {Vote}
     */
    vote() {
        const ret = wasm.votingprocedure_vote(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Anchor | undefined}
     */
    anchor() {
        const ret = wasm.votingprocedure_anchor(this.__wbg_ptr);
        return ret === 0 ? undefined : Anchor.__wrap(ret);
    }
    /**
     * @param {Vote} vote
     * @param {Anchor | null} [anchor]
     * @returns {VotingProcedure}
     */
    static new(vote, anchor) {
        let ptr0 = 0;
        if (!isLikeNone(anchor)) {
            _assertClass(anchor, Anchor);
            ptr0 = anchor.__destroy_into_raw();
        }
        const ret = wasm.votingprocedure_new(vote, ptr0);
        return VotingProcedure.__wrap(ret);
    }
}

const VotingProceduresFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_votingprocedures_free(ptr >>> 0, 1));

export class VotingProcedures {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(VotingProcedures.prototype);
        obj.__wbg_ptr = ptr;
        VotingProceduresFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        VotingProceduresFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_votingprocedures_free(ptr, 0);
    }
    /**
     * @returns {VotingProcedures}
     */
    static new() {
        const ret = wasm.votingprocedures_new();
        return VotingProcedures.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm.votingprocedures_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {Voter} key
     * @param {MapGovActionIdToVotingProcedure} value
     * @returns {MapGovActionIdToVotingProcedure | undefined}
     */
    insert(key, value) {
        _assertClass(key, Voter);
        _assertClass(value, MapGovActionIdToVotingProcedure);
        const ret = wasm.votingprocedures_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
        return ret === 0 ? undefined : MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
     * @param {Voter} key
     * @returns {MapGovActionIdToVotingProcedure | undefined}
     */
    get(key) {
        _assertClass(key, Voter);
        const ret = wasm.votingprocedures_get(this.__wbg_ptr, key.__wbg_ptr);
        return ret === 0 ? undefined : MapGovActionIdToVotingProcedure.__wrap(ret);
    }
    /**
     * @returns {VoterList}
     */
    keys() {
        const ret = wasm.votingprocedures_keys(this.__wbg_ptr);
        return VoterList.__wrap(ret);
    }
}

const WithdrawalBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_withdrawalbuilderresult_free(ptr >>> 0, 1));

export class WithdrawalBuilderResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WithdrawalBuilderResult.prototype);
        obj.__wbg_ptr = ptr;
        WithdrawalBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WithdrawalBuilderResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_withdrawalbuilderresult_free(ptr, 0);
    }
}

export function __wbg_String_fed4d24b68977888(arg0, arg1) {
    const ret = String(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
};

export function __wbg_buffer_609cc3eee51ed158(arg0) {
    const ret = arg0.buffer;
    return ret;
};

export function __wbg_call_672a4d21634d4a24() { return handleError(function (arg0, arg1) {
    const ret = arg0.call(arg1);
    return ret;
}, arguments) };

export function __wbg_call_7cccdd69e0791ae2() { return handleError(function (arg0, arg1, arg2) {
    const ret = arg0.call(arg1, arg2);
    return ret;
}, arguments) };

export function __wbg_crypto_574e78ad8b13b65f(arg0) {
    const ret = arg0.crypto;
    return ret;
};

export function __wbg_getRandomValues_b8f5dbd5f3995a9e() { return handleError(function (arg0, arg1) {
    arg0.getRandomValues(arg1);
}, arguments) };

export function __wbg_msCrypto_a61aeb35a24c1329(arg0) {
    const ret = arg0.msCrypto;
    return ret;
};

export function __wbg_new_405e22f390576ce2() {
    const ret = new Object();
    return ret;
};

export function __wbg_new_5e0be73521bc8c17() {
    const ret = new Map();
    return ret;
};

export function __wbg_new_78feb108b6472713() {
    const ret = new Array();
    return ret;
};

export function __wbg_new_a12002a7f91c75be(arg0) {
    const ret = new Uint8Array(arg0);
    return ret;
};

export function __wbg_newnoargs_105ed471475aaf50(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return ret;
};

export function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a(arg0, arg1, arg2) {
    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
};

export function __wbg_newwithlength_a381634e90c276d4(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return ret;
};

export function __wbg_node_905d3e251edff8a2(arg0) {
    const ret = arg0.node;
    return ret;
};

export function __wbg_process_dc0fbacc7c1c06f7(arg0) {
    const ret = arg0.process;
    return ret;
};

export function __wbg_randomFillSync_ac0988aba3254290() { return handleError(function (arg0, arg1) {
    arg0.randomFillSync(arg1);
}, arguments) };

export function __wbg_require_60cc747a6bc5215a() { return handleError(function () {
    const ret = module.require;
    return ret;
}, arguments) };

export function __wbg_set_37837023f3d740e8(arg0, arg1, arg2) {
    arg0[arg1 >>> 0] = arg2;
};

export function __wbg_set_3fda3bac07393de4(arg0, arg1, arg2) {
    arg0[arg1] = arg2;
};

export function __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
};

export function __wbg_set_8fc6bf8a5b1071d1(arg0, arg1, arg2) {
    const ret = arg0.set(arg1, arg2);
    return ret;
};

export function __wbg_static_accessor_GLOBAL_88a902d13a557d07() {
    const ret = typeof global === 'undefined' ? null : global;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
};

export function __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0() {
    const ret = typeof globalThis === 'undefined' ? null : globalThis;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
};

export function __wbg_static_accessor_SELF_37c5d418e4bf5819() {
    const ret = typeof self === 'undefined' ? null : self;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
};

export function __wbg_static_accessor_WINDOW_5de37043a91a9c40() {
    const ret = typeof window === 'undefined' ? null : window;
    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
};

export function __wbg_subarray_aa9065fa9dc5df96(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
};

export function __wbg_versions_c01dfd4722a88165(arg0) {
    const ret = arg0.versions;
    return ret;
};

export function __wbindgen_bigint_from_i64(arg0) {
    const ret = arg0;
    return ret;
};

export function __wbindgen_bigint_from_u64(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return ret;
};

export function __wbindgen_error_new(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return ret;
};

export function __wbindgen_init_externref_table() {
    const table = wasm.__wbindgen_export_4;
    const offset = table.grow(4);
    table.set(0, undefined);
    table.set(offset + 0, undefined);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
    ;
};

export function __wbindgen_is_function(arg0) {
    const ret = typeof(arg0) === 'function';
    return ret;
};

export function __wbindgen_is_object(arg0) {
    const val = arg0;
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

export function __wbindgen_is_string(arg0) {
    const ret = typeof(arg0) === 'string';
    return ret;
};

export function __wbindgen_is_undefined(arg0) {
    const ret = arg0 === undefined;
    return ret;
};

export function __wbindgen_memory() {
    const ret = wasm.memory;
    return ret;
};

export function __wbindgen_number_new(arg0) {
    const ret = arg0;
    return ret;
};

export function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
};

export function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

